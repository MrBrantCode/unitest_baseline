{
  "task_id": "taco_2669",
  "entry_point": "can_transform_values",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] / (N + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] / (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] + (N + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] + (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] ** (N + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] ** (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "num = 0",
      "mutated_line": "num = 1",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 1\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "num = 0",
      "mutated_line": "num = -1",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = -1\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "num = 0",
      "mutated_line": "num = 1",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 1\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "num += 1",
      "mutated_line": "num -= 1",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num -= 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] * (N - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N - 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] * (N * 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N * 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(2, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(0, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(0, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(-1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N - 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N * 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if li2[i] != 0:",
      "mutated_line": "if li2[i] == 0:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] == 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "num += 1",
      "mutated_line": "num += 2",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 2\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "num += 1",
      "mutated_line": "num += 0",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 0\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "num += 1",
      "mutated_line": "num += 0",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 0\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "num += 1",
      "mutated_line": "num += -1",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += -1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(2, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(0, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(0, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(-1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N - 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N * 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if A != B:",
      "mutated_line": "if A == B:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A == B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [1] * (N + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [1] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [-1] * (N + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [-1] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [1] * (N + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [1] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] * (N + 2)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 2)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] * (N + 0)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 0)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] * (N + 0)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 0)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "li2 = [0] * (N + 1)",
      "mutated_line": "li2 = [0] * (N + -1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + -1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 2):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 0):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 0):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + -1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if li2[i] != 0:",
      "mutated_line": "if li2[i] != 1:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 1:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if li2[i] != 0:",
      "mutated_line": "if li2[i] != -1:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != -1:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if li2[i] != 0:",
      "mutated_line": "if li2[i] != 1:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 1:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 2):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 0):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 0):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + -1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 1].append(i + 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i + 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 1].append(i * 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i * 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return True\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "li = [[] for _ in range(N + 1)]",
      "mutated_line": "for (c, d) in edges:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N - 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "li = [[] for _ in range(N + 1)]",
      "mutated_line": "for (c, d) in edges:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N * 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = deque.pop(0)",
      "mutated_line": "x = deque.pop(1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(1)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = deque.pop(0)",
      "mutated_line": "x = deque.pop(-1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(-1)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "x = deque.pop(0)",
      "mutated_line": "x = deque.pop(1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(1)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if li2[j] == 0:",
      "mutated_line": "if li2[j] != 0:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] != 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 1].append(i - 2)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 2)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 1].append(i - 0)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 0)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 1].append(i - 0)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 0)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 1].append(i - -1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - -1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "li = [[] for _ in range(N + 1)]",
      "mutated_line": "for (c, d) in edges:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 2)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "li = [[] for _ in range(N + 1)]",
      "mutated_line": "for (c, d) in edges:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 0)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "li = [[] for _ in range(N + 1)]",
      "mutated_line": "for (c, d) in edges:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 0)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "li = [[] for _ in range(N + 1)]",
      "mutated_line": "for (c, d) in edges:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + -1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if li2[j] == 0:",
      "mutated_line": "if li2[j] == 1:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 1:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if li2[j] == 0:",
      "mutated_line": "if li2[j] == -1:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == -1:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if li2[j] == 0:",
      "mutated_line": "if li2[j] == 1:",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 1:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] + 1].append(i - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] + 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] * 1].append(i - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] * 1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 2].append(i - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 2].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 0].append(i - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 0].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - 0].append(i - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - 0].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "li3[li2[i] - 1].append(i - 1)",
      "mutated_line": "li3[li2[i] - -1].append(i - 1)",
      "code": "def can_transform_values(N, M, a, b, edges):\n    from collections import deque\n    li = [[] for _ in range(N + 1)]\n    for (c, d) in edges:\n        li[c].append(d)\n        li[d].append(c)\n    li2 = [0] * (N + 1)\n    num = 0\n    for i in range(1, N + 1):\n        if li2[i] != 0:\n            continue\n        num += 1\n        deque = [i]\n        li2[i] = num\n        while deque:\n            x = deque.pop(0)\n            for j in li[x]:\n                if li2[j] == 0:\n                    li2[j] = num\n                    deque.append(j)\n    li3 = [[] for _ in range(num)]\n    for i in range(1, N + 1):\n        li3[li2[i] - -1].append(i - 1)\n    for i in range(len(li3)):\n        A = sum((a[j] for j in li3[i]))\n        B = sum((b[j] for j in li3[i]))\n        if A != B:\n            return False\n    return True"
    }
  ]
}