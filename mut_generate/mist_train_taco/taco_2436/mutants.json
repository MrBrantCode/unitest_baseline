{
  "task_id": "taco_2436",
  "entry_point": "find_impact_zones",
  "mutant_count": 101,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visit[tr][tc] = 1",
      "mutated_line": "visit[tr][tc] = 2",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 2\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visit[tr][tc] = 1",
      "mutated_line": "visit[tr][tc] = 0",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 0\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visit[tr][tc] = 1",
      "mutated_line": "visit[tr][tc] = 0",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 0\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "visit[tr][tc] = 1",
      "mutated_line": "visit[tr][tc] = -1",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = -1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[-1] / n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] / n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[-1] + n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] + n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[-1] ** n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] ** n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "visit = [[0] * m for _ in range(n)]",
      "mutated_line": "visit = [[0] / m for _ in range(n)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] / m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "visit = [[0] * m for _ in range(n)]",
      "mutated_line": "visit = [[0] + m for _ in range(n)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] + m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "visit = [[0] * m for _ in range(n)]",
      "mutated_line": "visit = [[0] ** m for _ in range(n)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] ** m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if grid[r][c] == 'B':",
      "mutated_line": "if grid[r][c] != 'B':",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] != 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if grid[i][j] == 'O':",
      "mutated_line": "if grid[i][j] != 'O':",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((tr, tc, 0))",
      "mutated_line": "q.append((tr, tc, 1))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 1))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((tr, tc, 0))",
      "mutated_line": "q.append((tr, tc, -1))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, -1))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "q.append((tr, tc, 0))",
      "mutated_line": "q.append((tr, tc, 1))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 1))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(r, c, s) = q.pop(0)",
      "mutated_line": "(r, c, s) = q.pop(1)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(1)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(r, c, s) = q.pop(0)",
      "mutated_line": "(r, c, s) = q.pop(-1)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(-1)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "(r, c, s) = q.pop(0)",
      "mutated_line": "(r, c, s) = q.pop(1)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(1)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if grid[r][c] == 'B':",
      "mutated_line": "if grid[r][c] == '':",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == '':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n or nr >= 0 or nc < m or (nc >= 0) or (grid[nr][nc] != 'W') or (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n or nr >= 0 or nc < m or (nc >= 0) or (grid[nr][nc] != 'W') or (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[+1] * n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[+1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if grid[i][j] == 'O':",
      "mutated_line": "if grid[i][j] == '':",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif grid[i][j] == 'B':",
      "mutated_line": "elif grid[i][j] != 'B':",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] != 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(n, m) = (len(grid), len(grid[0]))",
      "mutated_line": "(n, m) = (len(grid), len(grid[1]))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[1]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(n, m) = (len(grid), len(grid[0]))",
      "mutated_line": "(n, m) = (len(grid), len(grid[-1]))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[-1]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(n, m) = (len(grid), len(grid[0]))",
      "mutated_line": "(n, m) = (len(grid), len(grid[1]))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[1]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "visit = [[0] * m for _ in range(n)]",
      "mutated_line": "visit = [[1] * m for _ in range(n)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[1] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "visit = [[0] * m for _ in range(n)]",
      "mutated_line": "visit = [[-1] * m for _ in range(n)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[-1] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "visit = [[0] * m for _ in range(n)]",
      "mutated_line": "visit = [[1] * m for _ in range(n)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[1] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[+1, 0], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[+1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 1], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 1], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, -1], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, -1], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 1], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 1], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [2, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [2, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [0, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [0, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [0, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [0, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [-1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [-1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 1], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 1], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, -1], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, -1], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 1], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 1], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [1, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [1, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [-1, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [-1, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [1, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [1, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, +1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, +1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [1, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [1, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [-1, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [-1, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [1, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [1, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 2]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 2]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 0]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 0]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 0]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 0]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -1], [0, -1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, -1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(nr, nc) = (r + i, c + j)",
      "mutated_line": "(nr, nc) = (r - i, c + j)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r - i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(nr, nc) = (r + i, c + j)",
      "mutated_line": "(nr, nc) = (r * i, c + j)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r * i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(nr, nc) = (r + i, c + j)",
      "mutated_line": "(nr, nc) = (r + i, c - j)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c - j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "(nr, nc) = (r + i, c + j)",
      "mutated_line": "(nr, nc) = (r + i, c * j)",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c * j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr <= n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr <= n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr >= n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr >= n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr != n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr != n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr > 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr > 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr < 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr < 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr == 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr == 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc <= m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc <= m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc >= m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc >= m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc != m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc != m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc > 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc > 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc < 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc < 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc == 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc == 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] == 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] == 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visit[nr][nc] = 1",
      "mutated_line": "visit[nr][nc] = 2",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 2\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visit[nr][nc] = 1",
      "mutated_line": "visit[nr][nc] = 0",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 0\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visit[nr][nc] = 1",
      "mutated_line": "visit[nr][nc] = 0",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 0\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "visit[nr][nc] = 1",
      "mutated_line": "visit[nr][nc] = -1",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = -1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[-2] * n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-2] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[-0] * n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[-0] * n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "dis = [[-1] * n for _ in range(m)]",
      "mutated_line": "dis = [[--1] * n for _ in range(m)]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[--1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "elif grid[i][j] == 'B':",
      "mutated_line": "elif grid[i][j] == '':",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == '':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dis[i][j] = 0",
      "mutated_line": "dis[i][j] = 1",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 1\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dis[i][j] = 0",
      "mutated_line": "dis[i][j] = -1",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = -1\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dis[i][j] = 0",
      "mutated_line": "dis[i][j] = 1",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 1\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-2, 0], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-2, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-0, 0], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-0, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-0, 0], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-0, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[--1, 0], [1, 0], [0, -1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[--1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -2], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -2], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -0], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -0], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, -0], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -0], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "l = [[-1, 0], [1, 0], [0, -1], [0, 1]]",
      "mutated_line": "l = [[-1, 0], [1, 0], [0, --1], [0, 1]]",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, --1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 1 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 1 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= -1 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= -1 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 1 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 1 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 1) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 1) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= -1) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= -1) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 1) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 1) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):",
      "mutated_line": "if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != '') and (not visit[nr][nc]):",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != '') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.append((nr, nc, s + 1))",
      "mutated_line": "q.append((nr, nc, s - 1))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s - 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "q.append((nr, nc, s + 1))",
      "mutated_line": "q.append((nr, nc, s * 1))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s * 1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append((nr, nc, s + 1))",
      "mutated_line": "q.append((nr, nc, s + 2))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 2))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append((nr, nc, s + 1))",
      "mutated_line": "q.append((nr, nc, s + 0))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 0))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append((nr, nc, s + 1))",
      "mutated_line": "q.append((nr, nc, s + 0))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + 0))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "q.append((nr, nc, s + 1))",
      "mutated_line": "q.append((nr, nc, s + -1))",
      "code": "def find_impact_zones(grid, m, n):\n\n    def bfs(tr, tc, grid, dis):\n        (n, m) = (len(grid), len(grid[0]))\n        visit = [[0] * m for _ in range(n)]\n        q = []\n        q.append((tr, tc, 0))\n        visit[tr][tc] = 1\n        while q:\n            (r, c, s) = q.pop(0)\n            if grid[r][c] == 'B':\n                dis[tr][tc] = s\n                break\n            l = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n            for (i, j) in l:\n                (nr, nc) = (r + i, c + j)\n                if nr < n and nr >= 0 and (nc < m) and (nc >= 0) and (grid[nr][nc] != 'W') and (not visit[nr][nc]):\n                    visit[nr][nc] = 1\n                    q.append((nr, nc, s + -1))\n    dis = [[-1] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'O':\n                bfs(i, j, grid, dis)\n            elif grid[i][j] == 'B':\n                dis[i][j] = 0\n    return dis"
    }
  ]
}