{
  "task_id": "taco_13791",
  "entry_point": "minimum_time_to_planet",
  "mutant_count": 191,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] / (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] + (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] ** (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n - 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n * 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst and lst[0] > val and (lst[-1] < val):",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst and lst[0] > val and (lst[-1] < val):\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if v < len(lst) and lst[v] == val:",
      "mutated_line": "if v < len(lst) or lst[v] == val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) or lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] / (n + 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] / (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] + (n + 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] + (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] ** (n + 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] ** (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dij_modified(delays, 0)",
      "mutated_line": "dij_modified(delays, 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 1)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dij_modified(delays, 0)",
      "mutated_line": "dij_modified(delays, -1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, -1)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "dij_modified(delays, 0)",
      "mutated_line": "dij_modified(delays, 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 1)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] <= 10000000000 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] <= 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] >= 10000000000 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] >= 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] != 10000000000 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] != 10000000000 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 10000000000 else +1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else +1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000001] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [9999999999] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [0] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [1] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [-10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 2)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 0)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 0)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = [10000000000] * (n + 1)",
      "mutated_line": "",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + -1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] >= val or lst[-1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] >= val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] <= val or lst[-1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] <= val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] != val or lst[-1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] != val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[-1] <= val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] <= val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[-1] >= val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] >= val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[-1] != val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] != val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if v < len(lst) and lst[v] == val:",
      "mutated_line": "if v <= len(lst) and lst[v] == val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v <= len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if v < len(lst) and lst[v] == val:",
      "mutated_line": "if v >= len(lst) and lst[v] == val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v >= len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if v < len(lst) and lst[v] == val:",
      "mutated_line": "if v != len(lst) and lst[v] == val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v != len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if v < len(lst) and lst[v] == val:",
      "mutated_line": "if v < len(lst) and lst[v] != val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] != val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 1",
      "mutated_line": "l = 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 2\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 1",
      "mutated_line": "l = 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 0\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 1",
      "mutated_line": "l = 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 0\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = 1",
      "mutated_line": "l = -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = -1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "h = len(lst) - v",
      "mutated_line": "h = len(lst) + v",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) + v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "h = len(lst) - v",
      "mutated_line": "h = len(lst) * v",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) * v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = 20000000000",
      "mutated_line": "z = 20000000001",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000001\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = 20000000000",
      "mutated_line": "z = 19999999999",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 19999999999\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = 20000000000",
      "mutated_line": "z = 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 0\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = 20000000000",
      "mutated_line": "z = 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 1\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "z = 20000000000",
      "mutated_line": "z = -20000000000",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = -20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while l < h:",
      "mutated_line": "while l <= h:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l <= h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while l < h:",
      "mutated_line": "while l >= h:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l >= h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while l < h:",
      "mutated_line": "while l != h:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l != h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) - val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) - val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) * val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) * val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n - 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n - 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n * 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n * 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dist[1] = t",
      "mutated_line": "dist[2] = t",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[2] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dist[1] = t",
      "mutated_line": "dist[0] = t",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[0] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dist[1] = t",
      "mutated_line": "dist[0] = t",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[0] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dist[1] = t",
      "mutated_line": "dist[-1] = t",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[-1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[1]] == 0:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] == 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[1]] = 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 2\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[1]] = 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 0\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[1]] = 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 0\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[1]] = -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = -1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "LCR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) > 0 or x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 or x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 10000000001 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000001 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 9999999999 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 9999999999 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 0 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 1 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < -10000000000 else -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < -10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 10000000000 else -2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -2"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 10000000000 else -0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 10000000000 else -0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return dist[n] if dist[n] < 10000000000 else -1",
      "mutated_line": "return dist[n] if dist[n] < 10000000000 else --1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else --1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "l = [[] for _ in range(n + 1)]",
      "mutated_line": "l = [[] for _ in range(n - 1)]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n - 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "l = [[] for _ in range(n + 1)]",
      "mutated_line": "l = [[] for _ in range(n * 1)]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n * 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) / 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) / 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) * 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) * 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m < len(lst) or val + m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) or val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [1] * (n + 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [1] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [-1] * (n + 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [-1] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [1] * (n + 1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [1] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 2)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 2)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 0)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 0)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + 0)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 0)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "vis = [0] * (n + 1)",
      "mutated_line": "vis = [0] * (n + -1)",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + -1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heappush(h, (t, 1))",
      "mutated_line": "heappush(h, (t, 2))",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 2))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heappush(h, (t, 1))",
      "mutated_line": "heappush(h, (t, 0))",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 0))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heappush(h, (t, 1))",
      "mutated_line": "heappush(h, (t, 0))",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 0))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "heappush(h, (t, 1))",
      "mutated_line": "heappush(h, (t, -1))",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, -1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[1]] != 1:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 1:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[1]] != -1:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != -1:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[1]] != 1:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 1:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = val[1]",
      "mutated_line": "x = val[2]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[2]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = val[1]",
      "mutated_line": "x = val[0]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[0]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = val[1]",
      "mutated_line": "x = val[0]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[0]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "x = val[1]",
      "mutated_line": "x = val[-1]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[-1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) >= 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) >= 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) <= 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) <= 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) != 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) != 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) > 0 and x == n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x == n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if dist[x] + d < dist[e]:",
      "mutated_line": "if dist[x] + d <= dist[e]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d <= dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if dist[x] + d < dist[e]:",
      "mutated_line": "if dist[x] + d >= dist[e]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d >= dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if dist[x] + d < dist[e]:",
      "mutated_line": "if dist[x] + d != dist[e]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d != dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "l = [[] for _ in range(n + 1)]",
      "mutated_line": "l = [[] for _ in range(n + 2)]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 2)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "l = [[] for _ in range(n + 1)]",
      "mutated_line": "l = [[] for _ in range(n + 0)]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 0)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "l = [[] for _ in range(n + 1)]",
      "mutated_line": "l = [[] for _ in range(n + 0)]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 0)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "l = [[] for _ in range(n + 1)]",
      "mutated_line": "l = [[] for _ in range(n + -1)]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + -1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[1] > val or lst[-1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[1] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[-1] > val or lst[-1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[-1] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[1] > val or lst[-1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[1] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[+1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[+1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l - h) // 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l - h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = l * h // 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = l * h // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) // 3",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 3\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) // 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 1\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) // 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 0\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) // 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 1\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = (l + h) // 2",
      "mutated_line": "m = (l + h) // -2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // -2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m <= len(lst) and val + m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m <= len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m >= len(lst) and val + m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m >= len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m != len(lst) and val + m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m != len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m < len(lst) and val + m != lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m != lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = m + 1",
      "mutated_line": "l = m - 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m - 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "l = m + 1",
      "mutated_line": "l = m * 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m * 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z != 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z != 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 + val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 + val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return ((lst[-1] + 1) * val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return ((lst[-1] + 1) * val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[2]] = 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[2]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[0]] = 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[0]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[0]] = 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[0]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "vis[val[1]] = 1",
      "mutated_line": "vis[val[-1]] = 1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[-1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) > 1 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 1 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) > -1 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > -1 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 1]) > 1 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 1 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d = i[0]",
      "mutated_line": "d = i[1]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[1]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d = i[0]",
      "mutated_line": "d = i[-1]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[-1]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "d = i[0]",
      "mutated_line": "d = i[1]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[1]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "e = i[1]",
      "mutated_line": "e = i[2]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[2]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "e = i[1]",
      "mutated_line": "e = i[0]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[0]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "e = i[1]",
      "mutated_line": "e = i[0]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[0]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "e = i[1]",
      "mutated_line": "e = i[-1]",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[-1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dist[x] + d < dist[e]:",
      "mutated_line": "if dist[x] - d < dist[e]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] - d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if dist[x] + d < dist[e]:",
      "mutated_line": "if dist[x] * d < dist[e]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] * d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dist[e] = dist[x] + d",
      "mutated_line": "dist[e] = dist[x] - d",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] - d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "dist[e] = dist[x] + d",
      "mutated_line": "dist[e] = dist[x] * d",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] * d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[-2] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-2] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[-0] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-0] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[-0] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-0] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if not lst or lst[0] > val or lst[-1] < val:",
      "mutated_line": "if not lst or lst[0] > val or lst[--1] < val:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[--1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v - m < len(lst) and val + m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v - m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v * m < len(lst) and val + m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v * m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m < len(lst) and val - m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val - m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m < len(lst) and val * m == lst[v + m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val * m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + 2",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 2\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 0\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + 0",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 0\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "l = m + 1",
      "mutated_line": "l = m + -1",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + -1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == 20000000001 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000001 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == 19999999999 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 19999999999 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == 0 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 0 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == 1 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 1 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 1 - val if z == -20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == -20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] - 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] - 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] * 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] * 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[2]] != 0:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[2]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[0]] != 0:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[0]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[0]] != 0:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[0]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if vis[val[1]] != 0:",
      "mutated_line": "if vis[val[-1]] != 0:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[-1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dist[x] = helper(delay[x - 1], dist[x])",
      "mutated_line": "dist[x] = helper(delay[x + 1], dist[x])",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x + 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "dist[x] = helper(delay[x - 1], dist[x])",
      "mutated_line": "dist[x] = helper(delay[x * 1], dist[x])",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x * 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m < len(lst) and val + m == lst[v - m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v - m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if v + m < len(lst) and val + m == lst[v + m]:",
      "mutated_line": "if v + m < len(lst) and val + m == lst[v * m]:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v * m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 2 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 2 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 0 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 0 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + 0 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 0 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-1] + -1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + -1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x + 1]) > 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x + 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x * 1]) > 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x * 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[x] = helper(delay[x - 1], dist[x])",
      "mutated_line": "dist[x] = helper(delay[x - 2], dist[x])",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 2], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[x] = helper(delay[x - 1], dist[x])",
      "mutated_line": "dist[x] = helper(delay[x - 0], dist[x])",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 0], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[x] = helper(delay[x - 1], dist[x])",
      "mutated_line": "dist[x] = helper(delay[x - 0], dist[x])",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 0], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "dist[x] = helper(delay[x - 1], dist[x])",
      "mutated_line": "dist[x] = helper(delay[x - -1], dist[x])",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - -1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[+1] + 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[+1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 2]) > 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 2]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 0]) > 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 0]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - 0]) > 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 0]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "if len(delay[x - 1]) > 0 and x != n:",
      "mutated_line": "if len(delay[x - -1]) > 0 and x != n:",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - -1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-2] + 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-2] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-0] + 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-0] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[-0] + 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[-0] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return (lst[-1] + 1 - val if z == 20000000000 else z) + val",
      "mutated_line": "return (lst[--1] + 1 - val if z == 20000000000 else z) + val",
      "code": "from heapq import heappush, heappop, heapify\nfrom bisect import bisect_left\n\ndef minimum_time_to_planet(n, m, connections, delays):\n    l = [[] for _ in range(n + 1)]\n    for (a, b, c) in connections:\n        l[a].append((c, b))\n        l[b].append((c, a))\n    dist = [10000000000] * (n + 1)\n\n    def helper(lst, val):\n        if not lst or lst[0] > val or lst[-1] < val:\n            return val\n        v = bisect_left(lst, val)\n        if v < len(lst) and lst[v] == val:\n            l = 1\n            h = len(lst) - v\n            z = 20000000000\n            while l < h:\n                m = (l + h) // 2\n                if v + m < len(lst) and val + m == lst[v + m]:\n                    l = m + 1\n                else:\n                    (h, z) = (m, m)\n            return (lst[--1] + 1 - val if z == 20000000000 else z) + val\n        return val\n\n    def dij_modified(delay, t):\n        vis = [0] * (n + 1)\n        dist[1] = t\n        h = []\n        heappush(h, (t, 1))\n        heapify(h)\n        while h:\n            val = heappop(h)\n            if vis[val[1]] != 0:\n                continue\n            vis[val[1]] = 1\n            x = val[1]\n            if len(delay[x - 1]) > 0 and x != n:\n                dist[x] = helper(delay[x - 1], dist[x])\n            for i in l[x]:\n                d = i[0]\n                e = i[1]\n                if dist[x] + d < dist[e]:\n                    dist[e] = dist[x] + d\n                    heappush(h, (dist[e], e))\n    dij_modified(delays, 0)\n    return dist[n] if dist[n] < 10000000000 else -1"
    }
  ]
}