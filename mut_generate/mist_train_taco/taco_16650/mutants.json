{
  "task_id": "taco_16650",
  "entry_point": "find_lexicographically_smallest_permutation",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):",
      "mutated_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=3):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=3):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):",
      "mutated_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=1):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=1):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):",
      "mutated_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=0):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=0):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):",
      "mutated_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=1):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=1):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):",
      "mutated_line": "def find_lexicographically_smallest_permutation(permutation, max_swaps=-2):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=-2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a = a[onepos:] + a[:onepos]",
      "mutated_line": "a = a[onepos:] - a[:onepos]",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] - a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "a = a[onepos:] + a[:onepos]",
      "mutated_line": "a = a[onepos:] * a[:onepos]",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] * a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "swaps -= 1",
      "mutated_line": "swaps += 1",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps += 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "onepos = permutation.index(1)",
      "mutated_line": "onepos = permutation.index(2)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(2)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "onepos = permutation.index(1)",
      "mutated_line": "onepos = permutation.index(0)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(0)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "onepos = permutation.index(1)",
      "mutated_line": "onepos = permutation.index(0)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(0)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "onepos = permutation.index(1)",
      "mutated_line": "onepos = permutation.index(-1)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(-1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if permutation[i] == 2:",
      "mutated_line": "if permutation[i] != 2:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] != 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if permutation[i] == 3:",
      "mutated_line": "if permutation[i] != 3:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] != 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "onepos = a.index(1)",
      "mutated_line": "onepos = a.index(2)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(2)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "onepos = a.index(1)",
      "mutated_line": "onepos = a.index(0)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(0)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "onepos = a.index(1)",
      "mutated_line": "onepos = a.index(0)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(0)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "onepos = a.index(1)",
      "mutated_line": "onepos = a.index(-1)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(-1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(2, len(a)):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(2, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(0, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(0, len(a)):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(0, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(1, len(a)):",
      "mutated_line": "for i in range(-1, len(a)):",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(-1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 and a[i] == i + 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 and a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "swaps -= 1",
      "mutated_line": "swaps -= 2",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 2\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "swaps -= 1",
      "mutated_line": "swaps -= 0",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 0\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "swaps -= 1",
      "mutated_line": "swaps -= 0",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 0\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "swaps -= 1",
      "mutated_line": "swaps -= -1",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= -1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if permutation[i] == 2:",
      "mutated_line": "if permutation[i] == 3:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 3:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if permutation[i] == 2:",
      "mutated_line": "if permutation[i] == 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 1:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if permutation[i] == 2:",
      "mutated_line": "if permutation[i] == 0:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 0:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if permutation[i] == 2:",
      "mutated_line": "if permutation[i] == 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 1:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if permutation[i] == 2:",
      "mutated_line": "if permutation[i] == -2:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == -2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if permutation[i] == 3:",
      "mutated_line": "if permutation[i] == 4:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 4:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if permutation[i] == 3:",
      "mutated_line": "if permutation[i] == 2:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 2:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if permutation[i] == 3:",
      "mutated_line": "if permutation[i] == 0:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 0:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if permutation[i] == 3:",
      "mutated_line": "if permutation[i] == 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 1:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if permutation[i] == 3:",
      "mutated_line": "if permutation[i] == -3:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == -3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps != 0 or a[i] == i + 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps != 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] != i + 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] != i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pos = a.index(i + 1)",
      "mutated_line": "pos = a.index(i - 1)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i - 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "pos = a.index(i + 1)",
      "mutated_line": "pos = a.index(i * 1)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i * 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append((i - 1) * n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) * n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append(i - 1 + n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append(i - 1 + n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 2) * n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) * n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append(i - 2 + n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append(i - 2 + n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 2) * n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) * n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append(i - 2 + n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append(i - 2 + n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = min(ans, solve(permutation[:], max_swaps - 1))",
      "mutated_line": "ans = min(ans, solve(permutation[:], max_swaps + 1))",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps + 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ans = min(ans, solve(permutation[:], max_swaps - 1))",
      "mutated_line": "ans = min(ans, solve(permutation[:], max_swaps * 1))",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps * 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 1 or a[i] == i + 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 1 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == -1 or a[i] == i + 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == -1 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 1 or a[i] == i + 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 1 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] == i - 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i - 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] == i * 1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i * 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = a.index(i + 1)",
      "mutated_line": "pos = a.index(i + 2)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 2)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = a.index(i + 1)",
      "mutated_line": "pos = a.index(i + 0)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 0)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = a.index(i + 1)",
      "mutated_line": "pos = a.index(i + 0)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 0)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "pos = a.index(i + 1)",
      "mutated_line": "pos = a.index(i + -1)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + -1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append((i + 1) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i + 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append(i * 1 % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append(i * 1 % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i + 2) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i + 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append(i * 2 % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append(i * 2 % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i + 2) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i + 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append(i * 2 % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append(i * 2 % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = min(ans, solve(permutation[:], max_swaps - 1))",
      "mutated_line": "ans = min(ans, solve(permutation[:], max_swaps - 2))",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 2))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = min(ans, solve(permutation[:], max_swaps - 1))",
      "mutated_line": "ans = min(ans, solve(permutation[:], max_swaps - 0))",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 0))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = min(ans, solve(permutation[:], max_swaps - 1))",
      "mutated_line": "ans = min(ans, solve(permutation[:], max_swaps - 0))",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 0))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans = min(ans, solve(permutation[:], max_swaps - 1))",
      "mutated_line": "ans = min(ans, solve(permutation[:], max_swaps - -1))",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - -1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] == i + 2:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 2:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] == i + 0:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 0:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] == i + 0:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 0:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if swaps == 0 or a[i] == i + 1:",
      "mutated_line": "if swaps == 0 or a[i] == i + -1:",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + -1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append((i - 2) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 2) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append((i - 0) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 0) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append((i - 0) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 0) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "starts.append((i - 1) % n)",
      "mutated_line": "starts.append((i - -1) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - -1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 3) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 3) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 1) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 1) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 0) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 0) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 1) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 1) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - -2) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - -2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 3) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 3) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 1) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 1) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 0) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 0) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - 1) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - 1) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "starts.append((i - 2) % n)",
      "mutated_line": "starts.append((i - -2) % n)",
      "code": "def find_lexicographically_smallest_permutation(permutation, max_swaps=2):\n\n    def solve(a, swaps):\n        onepos = a.index(1)\n        a = a[onepos:] + a[:onepos]\n        for i in range(1, len(a)):\n            if swaps == 0 or a[i] == i + 1:\n                continue\n            pos = a.index(i + 1)\n            swaps -= 1\n            (a[i], a[pos]) = (a[pos], a[i])\n        return a\n    n = len(permutation)\n    ans = solve(permutation[:], max_swaps)\n    onepos = permutation.index(1)\n    starts = []\n    for i in range(n):\n        if permutation[i] == 2:\n            starts.append(i)\n            starts.append((i - 1) % n)\n            starts.append((i - 2) % n)\n        if permutation[i] == 3:\n            starts.append((i - -2) % n)\n            starts.append(i)\n    for x in starts:\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n        ans = min(ans, solve(permutation[:], max_swaps - 1))\n        (permutation[onepos], permutation[x]) = (permutation[x], permutation[onepos])\n    return ans"
    }
  ]
}