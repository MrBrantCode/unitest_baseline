{
  "task_id": "taco_2893",
  "entry_point": "calculate_bfs_spanning_trees",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244354\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244352\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 0\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 1\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = -998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] / n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] + n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] ** n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [-1] / n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] / n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [-1] + n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] + n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [-1] ** n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] ** n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[i] = 0",
      "mutated_line": "D[i] = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 1\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[i] = 0",
      "mutated_line": "D[i] = -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = -1\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "D[i] = 0",
      "mutated_line": "D[i] = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 1\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v + 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v + 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v * 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v * 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u + 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u + 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u * 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u * 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i - 1):",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i - 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i * 1):",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i * 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "failed = False",
      "mutated_line": "failed = True",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = True\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "while node != i:",
      "mutated_line": "while node == i:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node == i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "call = 1",
      "mutated_line": "call = 2",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 2\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "call = 1",
      "mutated_line": "call = 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 0\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "call = 1",
      "mutated_line": "call = 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 0\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "call = 1",
      "mutated_line": "call = -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = -1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 2)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 2)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - -1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - -1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 2)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 2)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - -1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - -1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[+1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [+1] * n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [+1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if D[neighbor] == -1:",
      "mutated_line": "if D[neighbor] != -1:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] != -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 2):",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 2):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 0):",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 0):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + 0):",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 0):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for j in range(i + 1):",
      "mutated_line": "for j in range(i + -1):",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + -1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 1\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = -1\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 1\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "next_node = -1",
      "mutated_line": "next_node = +1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = +1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if c == 1:",
      "mutated_line": "if c != 1:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c != 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "combs[i][j] = combs[j][i] = 0",
      "mutated_line": "combs[i][j] = combs[j][i] = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 1\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "combs[i][j] = combs[j][i] = 0",
      "mutated_line": "combs[i][j] = combs[j][i] = -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = -1\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "combs[i][j] = combs[j][i] = 0",
      "mutated_line": "combs[i][j] = combs[j][i] = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 1\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u + 1].append(v - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u + 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u * 1].append(v - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u * 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v + 1].append(u - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v + 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v * 1].append(u - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v * 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-2] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-0] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-0] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "combs = [[-1] * n for _ in range(n)]",
      "mutated_line": "",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[--1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [-2] * n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-2] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [-0] * n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-0] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [-0] * n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-0] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "D = [-1] * n",
      "mutated_line": "D = [--1] * n",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [--1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if D[neighbor] == -1:",
      "mutated_line": "if D[neighbor] == +1:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == +1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "D[neighbor] = D[node] + 1",
      "mutated_line": "D[neighbor] = D[node] - 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] - 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "D[neighbor] = D[node] + 1",
      "mutated_line": "D[neighbor] = D[node] * 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] * 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "next_node = -1",
      "mutated_line": "next_node = -2",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -2\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "next_node = -1",
      "mutated_line": "next_node = -0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -0\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "next_node = -1",
      "mutated_line": "next_node = -0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -0\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "next_node = -1",
      "mutated_line": "next_node = --1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = --1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dists[i][neighbor] < dists[i][node]:",
      "mutated_line": "if dists[i][neighbor] <= dists[i][node]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] <= dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dists[i][neighbor] < dists[i][node]:",
      "mutated_line": "if dists[i][neighbor] >= dists[i][node]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] >= dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if dists[i][neighbor] < dists[i][node]:",
      "mutated_line": "if dists[i][neighbor] != dists[i][node]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] != dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c -= 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if c == 1:",
      "mutated_line": "if c == 2:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 2:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if c == 1:",
      "mutated_line": "if c == 0:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 0:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if c == 1:",
      "mutated_line": "if c == 0:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 0:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if c == 1:",
      "mutated_line": "if c == -1:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == -1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "failed = True",
      "mutated_line": "failed = False",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = False\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if dists[i][k] + dists[j][k] > dists[i][j]:",
      "mutated_line": "if dists[i][k] + dists[j][k] >= dists[i][j]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] >= dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if dists[i][k] + dists[j][k] > dists[i][j]:",
      "mutated_line": "if dists[i][k] + dists[j][k] <= dists[i][j]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] <= dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if dists[i][k] + dists[j][k] > dists[i][j]:",
      "mutated_line": "if dists[i][k] + dists[j][k] != dists[i][j]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] != dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 2].append(v - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 2].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - -1].append(v - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - -1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 2].append(u - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 2].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - -1].append(u - 1)",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - -1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if D[neighbor] == -1:",
      "mutated_line": "if D[neighbor] == -2:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -2:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if D[neighbor] == -1:",
      "mutated_line": "if D[neighbor] == -0:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -0:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if D[neighbor] == -1:",
      "mutated_line": "if D[neighbor] == -0:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -0:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if D[neighbor] == -1:",
      "mutated_line": "if D[neighbor] == --1:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == --1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "D[neighbor] = D[node] + 1",
      "mutated_line": "D[neighbor] = D[node] + 2",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 2\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "D[neighbor] = D[node] + 1",
      "mutated_line": "D[neighbor] = D[node] + 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 0\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "D[neighbor] = D[node] + 1",
      "mutated_line": "D[neighbor] = D[node] + 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 0\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "D[neighbor] = D[node] + 1",
      "mutated_line": "D[neighbor] = D[node] + -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + -1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 2\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 0\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 0\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += -1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if dists[i][k] + dists[j][k] > dists[i][j]:",
      "mutated_line": "if dists[i][k] - dists[j][k] > dists[i][j]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] - dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "if dists[i][k] + dists[j][k] > dists[i][j]:",
      "mutated_line": "if dists[i][k] * dists[j][k] > dists[i][j]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] * dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 1\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = -1\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 1\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "call = call * c % MOD",
      "mutated_line": "call = call * c * MOD",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c * MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "call = call * c % MOD",
      "mutated_line": "call = call * c + MOD",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c + MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "LCR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] or dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] or dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c -= 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "call = call * c % MOD",
      "mutated_line": "call = call / c % MOD",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call / c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "call = call * c % MOD",
      "mutated_line": "call = (call + c) % MOD",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = (call + c) % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "call = call * c % MOD",
      "mutated_line": "call = call ** c % MOD",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call ** c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 != dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 != dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 != dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 != dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 2\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 0\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 0\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += -1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] - 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] - 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] * 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] * 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] - 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] - 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] * 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] * 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 2 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 2 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 0 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 0 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 0 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 0 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + -1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + -1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 2 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 2 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 0 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 0 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 0 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 0 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + 1 == dists[j][k]:",
      "mutated_line": "if dists[i][l] + 1 == dists[i][k] and dists[j][l] + -1 == dists[j][k]:",
      "code": "import sys\nfrom collections import defaultdict, deque\nMOD = 998244353\n\ndef calculate_bfs_spanning_trees(n, m, edges):\n    G = defaultdict(list)\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    combs = [[-1] * n for _ in range(n)]\n\n    def bfs(i):\n        Q = deque([i])\n        D = [-1] * n\n        D[i] = 0\n        while Q:\n            node = Q.pop()\n            for neighbor in G[node]:\n                if D[neighbor] == -1:\n                    Q.appendleft(neighbor)\n                    D[neighbor] = D[node] + 1\n        return D\n    dists = [bfs(i) for i in range(n)]\n    for i in range(n):\n        for j in range(i + 1):\n            node = j\n            failed = False\n            while node != i:\n                c = 0\n                next_node = -1\n                for neighbor in G[node]:\n                    if dists[i][neighbor] < dists[i][node]:\n                        c += 1\n                        next_node = neighbor\n                if c == 1:\n                    node = next_node\n                else:\n                    failed = True\n                    break\n            call = 1\n            if failed:\n                combs[i][j] = combs[j][i] = 0\n            else:\n                for k in range(n):\n                    if dists[i][k] + dists[j][k] > dists[i][j]:\n                        c = 0\n                        for l in G[k]:\n                            if dists[i][l] + 1 == dists[i][k] and dists[j][l] + -1 == dists[j][k]:\n                                c += 1\n                        call = call * c % MOD\n                combs[i][j] = combs[j][i] = call\n    return combs"
    }
  ]
}