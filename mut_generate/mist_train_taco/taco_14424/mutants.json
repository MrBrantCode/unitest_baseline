{
  "task_id": "taco_14424",
  "entry_point": "min_cost_flow",
  "mutant_count": 75,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(1, n - 1, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(1, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(-1, n - 1, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(-1, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(1, n - 1, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(1, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(0, n + 1, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n + 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(0, n * 1, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n * 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 * 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 * 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 + 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 + 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "min_cost = 0",
      "mutated_line": "min_cost = 1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 1\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "min_cost = 0",
      "mutated_line": "min_cost = -1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = -1\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "min_cost = 0",
      "mutated_line": "min_cost = 1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 1\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ASR",
      "lineno": 46,
      "original_line": "f -= min_cap",
      "mutated_line": "f += min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f += min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ASR",
      "lineno": 47,
      "original_line": "min_cost += min_cap * pot[t]",
      "mutated_line": "min_cost -= min_cap * pot[t]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost -= min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(0, n - 2, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 2, f)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(0, n - 0, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 0, f)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(0, n - 0, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 0, f)"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return mc.cal(0, n - 1, f)",
      "mutated_line": "return mc.cal(0, n - -1, f)",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - -1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 11 ** 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 11 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 9 ** 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 9 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 0 ** 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 0 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 1 ** 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 1 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = -10 ** 9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = -10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 ** 10",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 10\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 ** 8",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 8\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 ** 0",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 0\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 ** 1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 1\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "self.inf = 10 ** 9",
      "mutated_line": "self.inf = 10 ** -9",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** -9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.to[v][u] = [0, -cost]",
      "mutated_line": "self.to[v][u] = [1, -cost]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [1, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.to[v][u] = [0, -cost]",
      "mutated_line": "self.to[v][u] = [-1, -cost]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [-1, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "self.to[v][u] = [0, -cost]",
      "mutated_line": "self.to[v][u] = [1, -cost]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [1, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "self.to[v][u] = [0, -cost]",
      "mutated_line": "self.to[v][u] = [0, +cost]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, +cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = 1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 1\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = -1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = -1\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "dist[s] = 0",
      "mutated_line": "dist[s] = 1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 1\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if t not in dist:",
      "mutated_line": "if t in dist:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "pot[u] += d",
      "mutated_line": "pot[u] -= d",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] -= d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "while u != s:",
      "mutated_line": "while u == s:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u == s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "min_cost += min_cap * pot[t]",
      "mutated_line": "min_cost += min_cap / pot[t]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap / pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "min_cost += min_cap * pot[t]",
      "mutated_line": "min_cost += min_cap + pot[t]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap + pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "min_cost += min_cap * pot[t]",
      "mutated_line": "min_cost += min_cap ** pot[t]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap ** pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "while u != s:",
      "mutated_line": "while u == s:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u == s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "self.to[u][v][0] -= min_cap",
      "mutated_line": "self.to[u][v][0] += min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] += min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "self.to[v][u][0] += min_cap",
      "mutated_line": "self.to[v][u][0] -= min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] -= min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d > dist[u]:",
      "mutated_line": "if d >= dist[u]:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d >= dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d > dist[u]:",
      "mutated_line": "if d <= dist[u]:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d <= dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if d > dist[u]:",
      "mutated_line": "if d != dist[u]:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d != dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return +1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(hp, (0, s))",
      "mutated_line": "heappush(hp, (1, s))",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (1, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(hp, (0, s))",
      "mutated_line": "heappush(hp, (-1, s))",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (-1, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "heappush(hp, (0, s))",
      "mutated_line": "heappush(hp, (1, s))",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (1, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if cap == 0:",
      "mutated_line": "if cap != 0:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap != 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nd = dist[u] + cost + pot[u] - pot[v]",
      "mutated_line": "nd = dist[u] + cost + pot[u] + pot[v]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] + pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nd = dist[u] + cost + pot[u] - pot[v]",
      "mutated_line": "nd = (dist[u] + cost + pot[u]) * pot[v]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = (dist[u] + cost + pot[u]) * pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if nd >= dist[v]:",
      "mutated_line": "if nd > dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd > dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if nd >= dist[v]:",
      "mutated_line": "if nd < dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd < dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if nd >= dist[v]:",
      "mutated_line": "if nd == dist[v]:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd == dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -2\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -0\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -0\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return --1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "self.to[u][v][0] -= min_cap",
      "mutated_line": "self.to[u][v][1] -= min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][1] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "self.to[u][v][0] -= min_cap",
      "mutated_line": "self.to[u][v][-1] -= min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][-1] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "self.to[u][v][0] -= min_cap",
      "mutated_line": "self.to[u][v][1] -= min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][1] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "self.to[v][u][0] += min_cap",
      "mutated_line": "self.to[v][u][1] += min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][1] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "self.to[v][u][0] += min_cap",
      "mutated_line": "self.to[v][u][-1] += min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][-1] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "self.to[v][u][0] += min_cap",
      "mutated_line": "self.to[v][u][1] += min_cap",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][1] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cap == 0:",
      "mutated_line": "if cap == 1:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 1:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cap == 0:",
      "mutated_line": "if cap == -1:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == -1:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cap == 0:",
      "mutated_line": "if cap == 1:",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 1:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nd = dist[u] + cost + pot[u] - pot[v]",
      "mutated_line": "nd = dist[u] + cost - pot[u] - pot[v]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost - pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nd = dist[u] + cost + pot[u] - pot[v]",
      "mutated_line": "nd = (dist[u] + cost) * pot[u] - pot[v]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = (dist[u] + cost) * pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "min_cap = min(min_cap, self.to[u][v][0])",
      "mutated_line": "min_cap = min(min_cap, self.to[u][v][1])",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][1])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "min_cap = min(min_cap, self.to[u][v][0])",
      "mutated_line": "min_cap = min(min_cap, self.to[u][v][-1])",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][-1])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "min_cap = min(min_cap, self.to[u][v][0])",
      "mutated_line": "min_cap = min(min_cap, self.to[u][v][1])",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] + cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][1])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nd = dist[u] + cost + pot[u] - pot[v]",
      "mutated_line": "nd = dist[u] - cost + pot[u] - pot[v]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] - cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "nd = dist[u] + cost + pot[u] - pot[v]",
      "mutated_line": "nd = dist[u] * cost + pot[u] - pot[v]",
      "code": "from collections import defaultdict\nfrom heapq import *\n\ndef min_cost_flow(n, m, f, edges):\n\n    class MinCostFlow:\n\n        def __init__(self):\n            self.inf = 10 ** 9\n            self.to = defaultdict(dict)\n\n        def add_edge(self, u, v, cap, cost):\n            self.to[u][v] = [cap, cost]\n            self.to[v][u] = [0, -cost]\n\n        def cal(self, s, t, f):\n            min_cost = 0\n            pot = defaultdict(int)\n            while f:\n                dist = {}\n                pre_u = {}\n                hp = []\n                heappush(hp, (0, s))\n                dist[s] = 0\n                while hp:\n                    (d, u) = heappop(hp)\n                    if d > dist[u]:\n                        continue\n                    for (v, [cap, cost]) in self.to[u].items():\n                        if cap == 0:\n                            continue\n                        nd = dist[u] * cost + pot[u] - pot[v]\n                        dist.setdefault(v, self.inf)\n                        if nd >= dist[v]:\n                            continue\n                        dist[v] = nd\n                        pre_u[v] = u\n                        heappush(hp, (nd, v))\n                if t not in dist:\n                    return -1\n                for (u, d) in dist.items():\n                    pot[u] += d\n                u = t\n                min_cap = f\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    min_cap = min(min_cap, self.to[u][v][0])\n                f -= min_cap\n                min_cost += min_cap * pot[t]\n                u = t\n                while u != s:\n                    (u, v) = (pre_u[u], u)\n                    self.to[u][v][0] -= min_cap\n                    self.to[v][u][0] += min_cap\n            return min_cost\n    mc = MinCostFlow()\n    for (u, v, c, d) in edges:\n        mc.add_edge(u, v, c, d)\n    return mc.cal(0, n - 1, f)"
    }
  ]
}