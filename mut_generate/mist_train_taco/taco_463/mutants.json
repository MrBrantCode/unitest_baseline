{
  "task_id": "taco_463",
  "entry_point": "calculate_max_distance_and_cost",
  "mutant_count": 133,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] / (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] / (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] + (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] + (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] ** (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] ** (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] / (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] / (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] + (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] + (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] ** (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] ** (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 1\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = 0",
      "mutated_line": "l = -1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = -1\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "l = 0",
      "mutated_line": "l = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 1\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 1\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = -1\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 1\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo[x] = 0",
      "mutated_line": "memo[x] = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 1\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo[x] = 0",
      "mutated_line": "memo[x] = -1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = -1\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo[x] = 0",
      "mutated_line": "memo[x] = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 1\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "found = False",
      "mutated_line": "found = True",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = True\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto <= 100:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto <= 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto >= 100:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto >= 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto != 100:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto != 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] * (n - 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n - 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] * (n * 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n * 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] * (n - 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n - 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] * (n * 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n * 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b[top] = True",
      "mutated_line": "b[top] = False",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = False\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "upto, new = bfs(1, n, G)",
      "mutated_line": "(upto, new) = bfs(2, n, G)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(2, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "upto, new = bfs(1, n, G)",
      "mutated_line": "(upto, new) = bfs(0, n, G)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(0, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "upto, new = bfs(1, n, G)",
      "mutated_line": "(upto, new) = bfs(0, n, G)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(0, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "upto, new = bfs(1, n, G)",
      "mutated_line": "(upto, new) = bfs(-1, n, G)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(-1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if upto < j[0]:",
      "mutated_line": "if upto <= j[0]:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto <= j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if upto < j[0]:",
      "mutated_line": "if upto >= j[0]:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto >= j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if upto < j[0]:",
      "mutated_line": "if upto != j[0]:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto != j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto < 101:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 101:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto < 99:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 99:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto < 0:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 0:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto < 1:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 1:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if upto < 100:",
      "mutated_line": "if upto < -100:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < -100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 1\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost = 0",
      "mutated_line": "cost = -1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = -1\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "cost = 0",
      "mutated_line": "cost = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 1\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto <= 1000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto <= 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto >= 1000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto >= 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto != 1000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto != 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [True] * (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [True] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] * (n + 2)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 2)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] * (n + 0)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 0)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] * (n + 0)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 0)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = [False] * (n + 1)  # an array of false flags to keep track of vertices visited",
      "mutated_line": "b = [False] * (n + -1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + -1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = [''] * (n + 1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = [''] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] * (n + 2)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 2)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] * (n + 0)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 0)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] * (n + 0)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 0)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "memo = [\"p\"] * (n + 1)",
      "mutated_line": "memo = ['p'] * (n + -1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + -1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top = q.pop(0)",
      "mutated_line": "top = q.pop(1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(1)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top = q.pop(0)",
      "mutated_line": "top = q.pop(-1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(-1)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "top = q.pop(0)",
      "mutated_line": "top = q.pop(1)",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(1)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if memo[j[0]] == \"p\":",
      "mutated_line": "if memo[j[0]] != 'p':",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] != 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "found = True",
      "mutated_line": "found = False",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = False\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto < 1001:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1001:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto < 999:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 999:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto < 0:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 0:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto < 1:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "elif upto < 1000:",
      "mutated_line": "elif upto < -1000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < -1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cost = 100",
      "mutated_line": "cost = 101",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 101\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cost = 100",
      "mutated_line": "cost = 99",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 99\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cost = 100",
      "mutated_line": "cost = 0",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 0\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cost = 100",
      "mutated_line": "cost = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 1\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "cost = 100",
      "mutated_line": "cost = -100",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = -100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto <= 10000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto <= 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto >= 10000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto >= 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto != 10000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto != 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if memo[j[0]] == \"p\":",
      "mutated_line": "if memo[j[0]] == '':",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == '':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[0]] = memo[top] - j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] - j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[0]] = memo[top] * j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] * j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b[j[0]] = True",
      "mutated_line": "b[j[0]] = False",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = False\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if memo[j[0]] > l:",
      "mutated_line": "if memo[j[0]] >= l:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] >= l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if memo[j[0]] > l:",
      "mutated_line": "if memo[j[0]] <= l:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] <= l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if memo[j[0]] > l:",
      "mutated_line": "if memo[j[0]] != l:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] != l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n - 1)]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n - 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n * 1)]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n * 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if upto < j[0]:",
      "mutated_line": "if upto < j[1]:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[1]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if upto < j[0]:",
      "mutated_line": "if upto < j[-1]:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[-1]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if upto < j[0]:",
      "mutated_line": "if upto < j[1]:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[1]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "upto = j[0]",
      "mutated_line": "upto = j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[1]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "upto = j[0]",
      "mutated_line": "upto = j[-1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[-1]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "upto = j[0]",
      "mutated_line": "upto = j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[1]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new = j[1]",
      "mutated_line": "new = j[2]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[2]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new = j[1]",
      "mutated_line": "new = j[0]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[0]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new = j[1]",
      "mutated_line": "new = j[0]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[0]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "new = j[1]",
      "mutated_line": "new = j[-1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[-1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto < 10001:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10001:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto < 9999:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 9999:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto < 0:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 0:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto < 1:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 1:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "elif upto < 10000:",
      "mutated_line": "elif upto < -10000:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < -10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 1001",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1001\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 999",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 999\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 0",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 0\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cost = 1000",
      "mutated_line": "cost = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "cost = 1000",
      "mutated_line": "cost = -1000",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = -1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cost = 10000",
      "mutated_line": "cost = 10001",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10001\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cost = 10000",
      "mutated_line": "cost = 9999",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 9999\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cost = 10000",
      "mutated_line": "cost = 0",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 0\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cost = 10000",
      "mutated_line": "cost = 1",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 1\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "cost = 10000",
      "mutated_line": "cost = -10000",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = -10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + 2)]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 2)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + 0)]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 0)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + 0)]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 0)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "G = [[] for _ in range(n + 1)]",
      "mutated_line": "G = [[] for _ in range(n + -1)]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + -1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if memo[j[0]] == \"p\":",
      "mutated_line": "if memo[j[1]] == 'p':",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[1]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if memo[j[0]] == \"p\":",
      "mutated_line": "if memo[j[-1]] == 'p':",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[-1]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if memo[j[0]] == \"p\":",
      "mutated_line": "if memo[j[1]] == 'p':",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[1]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.append(j[0])",
      "mutated_line": "q.append(j[1])",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[1])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.append(j[0])",
      "mutated_line": "q.append(j[-1])",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[-1])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "q.append(j[0])",
      "mutated_line": "q.append(j[1])",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[1])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[1]] = memo[top] + j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[1]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[-1]] = memo[top] + j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[-1]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[1]] = memo[top] + j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[1]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[0]] = memo[top] + j[2]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[2]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[0]] = memo[top] + j[0]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[0]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[0]] = memo[top] + j[0]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[0]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "memo[j[0]] = memo[top] + j[1]  # time of discovery(level) of child is time of discovery(level) of parent + 1",
      "mutated_line": "memo[j[0]] = memo[top] + j[-1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[-1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b[j[0]] = True",
      "mutated_line": "b[j[1]] = True",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[1]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b[j[0]] = True",
      "mutated_line": "b[j[-1]] = True",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[-1]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b[j[0]] = True",
      "mutated_line": "b[j[1]] = True",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[1]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c = j[0]",
      "mutated_line": "c = j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[1]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c = j[0]",
      "mutated_line": "c = j[-1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[-1]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "c = j[0]",
      "mutated_line": "c = j[1]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[0]]\n                        c = j[1]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if memo[j[0]] > l:",
      "mutated_line": "if memo[j[1]] > l:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[1]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if memo[j[0]] > l:",
      "mutated_line": "if memo[j[-1]] > l:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[-1]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if memo[j[0]] > l:",
      "mutated_line": "if memo[j[1]] > l:",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[1]] > l:\n                        l = memo[j[0]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = memo[j[0]]",
      "mutated_line": "l = memo[j[1]]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[1]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = memo[j[0]]",
      "mutated_line": "l = memo[j[-1]]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[-1]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "l = memo[j[0]]",
      "mutated_line": "l = memo[j[1]]",
      "code": "def calculate_max_distance_and_cost(test_cases):\n\n    def bfs(x, n, G):\n        b = [False] * (n + 1)\n        memo = ['p'] * (n + 1)\n        l = 0\n        c = 0\n        q = []\n        q.append(x)\n        memo[x] = 0\n        while q:\n            top = q.pop(0)\n            b[top] = True\n            for j in G[top]:\n                if memo[j[0]] == 'p':\n                    q.append(j[0])\n                    memo[j[0]] = memo[top] + j[1]\n                    b[j[0]] = True\n                    if memo[j[0]] > l:\n                        l = memo[j[1]]\n                        c = j[0]\n        return (l, c)\n    results = []\n    for test_case in test_cases:\n        (n, edges) = test_case\n        G = [[] for _ in range(n + 1)]\n        for (x, y, z) in edges:\n            G[x].append((y, z))\n            G[y].append((x, z))\n        (upto, new) = bfs(1, n, G)\n        found = False\n        while not found:\n            j = bfs(new, n, G)\n            if upto < j[0]:\n                upto = j[0]\n                new = j[1]\n            else:\n                found = True\n        if upto < 100:\n            cost = 0\n        elif upto < 1000:\n            cost = 100\n        elif upto < 10000:\n            cost = 1000\n        else:\n            cost = 10000\n        results.append((cost, upto))\n    return results"
    }
  ]
}