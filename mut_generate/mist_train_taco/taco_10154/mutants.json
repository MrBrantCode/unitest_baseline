{
  "task_id": "taco_10154",
  "entry_point": "count_paving_groups",
  "mutant_count": 305,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] / 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] / 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] + 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] + 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] ** 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] ** 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "asz = d[A] - ab - ac + abc",
      "mutated_line": "asz = d[A] - ab - ac - abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac - abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "asz = d[A] - ab - ac + abc",
      "mutated_line": "asz = (d[A] - ab - ac) * abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = (d[A] - ab - ac) * abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "bsz = d[B] - bc - ab + abc",
      "mutated_line": "bsz = d[B] - bc - ab - abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab - abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "bsz = d[B] - bc - ab + abc",
      "mutated_line": "bsz = (d[B] - bc - ab) * abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = (d[B] - bc - ab) * abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "csz = d[C] - ac - bc + abc",
      "mutated_line": "csz = d[C] - ac - bc - abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc - abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "csz = d[C] - ac - bc + abc",
      "mutated_line": "csz = (d[C] - ac - bc) * abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = (d[C] - ac - bc) * abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "absz = ab - abc",
      "mutated_line": "absz = ab + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab + abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "absz = ab - abc",
      "mutated_line": "absz = ab * abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab * abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "bcsz = bc - abc",
      "mutated_line": "bcsz = bc + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc + abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "bcsz = bc - abc",
      "mutated_line": "bcsz = bc * abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc * abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "acsz = ac - abc",
      "mutated_line": "acsz = ac + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac + abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "acsz = ac - abc",
      "mutated_line": "acsz = ac * abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac * abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16668",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16668\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16666",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16666\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 0",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 0\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 1",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 1\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * -16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * -16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(5, 100001):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(5, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(3, 100001):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(3, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(0, 100001):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(0, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(1, 100001):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(1, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(-4, 100001):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(-4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(4, 100002):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100002):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(4, 100000):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100000):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(4, 0):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 0):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(4, 1):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 1):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for i in range(4, 100001):",
      "mutated_line": "for i in range(4, -100001):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, -100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "d[j] += 1.0",
      "mutated_line": "d[j] -= 1.0",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] -= 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "asz = d[A] - ab - ac + abc",
      "mutated_line": "asz = d[A] - ab + ac + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab + ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "asz = d[A] - ab - ac + abc",
      "mutated_line": "asz = (d[A] - ab) * ac + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = (d[A] - ab) * ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "bsz = d[B] - bc - ab + abc",
      "mutated_line": "bsz = d[B] - bc + ab + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc + ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "bsz = d[B] - bc - ab + abc",
      "mutated_line": "bsz = (d[B] - bc) * ab + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = (d[B] - bc) * ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "csz = d[C] - ac - bc + abc",
      "mutated_line": "csz = d[C] - ac + bc + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac + bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "csz = d[C] - ac - bc + abc",
      "mutated_line": "csz = (d[C] - ac) * bc + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = (d[C] - ac) * bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) - (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) - (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz)) * (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz)) * (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [4.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [4.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [2.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [2.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [1, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [1, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [-3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [-3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 2.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 2.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 0.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 0.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, -1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, -1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 3.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 3.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 1.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 1.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 1, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 1, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, -2.0, 2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, -2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 3.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 3.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 1.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 1.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 1, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 1, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, -2.0, 2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, -2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 3.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 3.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 1.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 1.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 1, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 1, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, -2.0, 1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, -2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 2.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 2.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 0.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 0.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667",
      "mutated_line": "d = [3.0, 1.0, 2.0, 2.0, 2.0, -1.0] * 16667",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, -1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, 100001, i):",
      "mutated_line": "for j in range(i, 100002, i):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100002, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, 100001, i):",
      "mutated_line": "for j in range(i, 100000, i):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100000, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, 100001, i):",
      "mutated_line": "for j in range(i, 0, i):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 0, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, 100001, i):",
      "mutated_line": "for j in range(i, 1, i):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 1, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for j in range(i, 100001, i):",
      "mutated_line": "for j in range(i, -100001, i):",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, -100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[j] += 1.0",
      "mutated_line": "d[j] += 2.0",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 2.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[j] += 1.0",
      "mutated_line": "d[j] += 0.0",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 0.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[j] += 1.0",
      "mutated_line": "d[j] += 0",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d[j] += 1.0",
      "mutated_line": "d[j] += -1.0",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += -1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "asz = d[A] - ab - ac + abc",
      "mutated_line": "asz = d[A] + ab - ac + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] + ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "asz = d[A] - ab - ac + abc",
      "mutated_line": "asz = d[A] * ab - ac + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] * ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "bsz = d[B] - bc - ab + abc",
      "mutated_line": "bsz = d[B] + bc - ab + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] + bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "bsz = d[B] - bc - ab + abc",
      "mutated_line": "bsz = d[B] * bc - ab + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] * bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "csz = d[C] - ac - bc + abc",
      "mutated_line": "csz = d[C] + ac - bc + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] + ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "csz = d[C] - ac - bc + abc",
      "mutated_line": "csz = d[C] * ac - bc + abc",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] * ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 - (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 - (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5) * ((asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5) * ((asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) - abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) - abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0)) * (abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0)) * (abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz - (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz - (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz) * ((absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5) + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz) * ((absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5) + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) / (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) / (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc + (absz * acsz + absz * bcsz + bcsz * acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc + (absz * acsz + absz * bcsz + bcsz * acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) ** (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) ** (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc - abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc - abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc * (abc * (abc - 1.0)) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc * (abc * (abc - 1.0)) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) * 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) * 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) // 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) // 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) - absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) - absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5)) * (absz * bcsz * acsz) + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5)) * (absz * bcsz * acsz) + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) / 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) / 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B] + 0.5) + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B] + 0.5) + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) ** 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) ** 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz - abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz - abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz) * abc * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz) * abc * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz - bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz - bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * ((absz * acsz + absz * bcsz) * (bcsz * acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * ((absz * acsz + absz * bcsz) * (bcsz * acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc / (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc / (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + (abc + (abc - 1.0)) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + (abc + (abc - 1.0)) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc ** (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc ** (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) / (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) / (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + (abc * (abc - 1.0) + (abc - 2.0)) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + (abc * (abc - 1.0) + (abc - 2.0)) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + (abc * (abc - 1.0)) ** (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + (abc * (abc - 1.0)) ** (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 7.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 7.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 5.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 5.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 1))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 1))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / -6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / -6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) - (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) - (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz)) * ((asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5)) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz)) * ((asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5)) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz / acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz / acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + (absz * bcsz + acsz) + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + (absz * bcsz + acsz) + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + (absz * bcsz) ** acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + (absz * bcsz) ** acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] - acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] - acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A]) * (acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A]) * (acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 1.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 1.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * -0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * -0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 1 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 1 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * -0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * -0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz - csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz - csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + ((asz + bsz) * csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + ((asz + bsz) * csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz - absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz - absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz * (absz * bcsz) + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz * (absz * bcsz) + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz / acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz / acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + (bcsz + acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + (bcsz + acsz)) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz ** acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz ** acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc + 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc + 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc * 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc * 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc / (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc / (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + (abc + (abc - 1.0)) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + (abc + (abc - 1.0)) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc ** (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc ** (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc + 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc + 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc * 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc * 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) - abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) - abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz)) * (abc * (absz + bcsz + acsz) * (asz + bsz + csz)) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz)) * (abc * (absz + bcsz + acsz) * (asz + bsz + csz)) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) / (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) / (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz + abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz + abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) ** (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) ** (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz / bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz / bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + (absz + bcsz) * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + (absz + bcsz) * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz ** bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz ** bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] - bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] - bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] * (bcsz * (bcsz + 1.0) * d[A]) + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] * (bcsz * (bcsz + 1.0) * d[A]) + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) / d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) / d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + (acsz * (acsz + 1.0) + d[B])) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + (acsz * (acsz + 1.0) + d[B])) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + (acsz * (acsz + 1.0)) ** d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + (acsz * (acsz + 1.0)) ** d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz - bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz - bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz * bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz * bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz / acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz / acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz + acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz + acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz ** acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz ** acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz / bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz / bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + (absz + bcsz) + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + (absz + bcsz) + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz ** bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz ** bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 2.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 2.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 0.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 0.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - -1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - -1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc + 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc + 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc * 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc * 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 3.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 3.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 1.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 1.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 1) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 1) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - -2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - -2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz - abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz - abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz) * (abc * (asz * bsz + asz * csz + bsz * csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz) * (abc * (asz * bsz + asz * csz + bsz * csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) / (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) / (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + (abc * (absz + bcsz + acsz) + (asz + bsz + csz)) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + (abc * (absz + bcsz + acsz) + (asz + bsz + csz)) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + (abc * (absz + bcsz + acsz)) ** (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + (abc * (absz + bcsz + acsz)) ** (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz - acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz - acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz) * acsz * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz) * acsz * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) / 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) / 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) + 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) + 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1)) ** 0.5 + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1)) ** 0.5 + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) / d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) / d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) + d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) + d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + ((absz * (absz + 1.0)) ** d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + ((absz * (absz + 1.0)) ** d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) / d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) / d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + (bcsz * (bcsz + 1.0) + d[A]) + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + (bcsz * (bcsz + 1.0) + d[A]) + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + (bcsz * (bcsz + 1.0)) ** d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + (bcsz * (bcsz + 1.0)) ** d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz / (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz / (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + (acsz + (acsz + 1.0)) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + (acsz + (acsz + 1.0)) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz ** (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz ** (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 2.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 2.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 0.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 0.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - -1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - -1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz - acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz - acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz) * (acsz * (asz + csz) * bsz) + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz) * (acsz * (asz + csz) * bsz) + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc / (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc / (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + (abc + (asz * bsz + asz * csz + bsz * csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + (abc + (asz * bsz + asz * csz + bsz * csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc ** (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc ** (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc / (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc / (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + (abc + (absz + bcsz + acsz)) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + (abc + (absz + bcsz + acsz)) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc ** (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc ** (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz - csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz - csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * ((asz + bsz) * csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * ((asz + bsz) * csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz - bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz - bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + ((asz + bsz + csz + absz) * bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + ((asz + bsz + csz + absz) * bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc / (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc / (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * ((abc + (abc + 1)) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * ((abc + (abc + 1)) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc ** (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc ** (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 1.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 1.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * -0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * -0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 1) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 1) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * -0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * -0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz / (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz / (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + ((absz + (absz + 1.0)) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + ((absz + (absz + 1.0)) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz ** (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz ** (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz / (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz / (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + (bcsz + (bcsz + 1.0)) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + (bcsz + (bcsz + 1.0)) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz ** (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz ** (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz - 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz - 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz * 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz * 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz - bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz - bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz * csz + absz * (asz + bsz) * csz) * (bcsz * (bsz + csz) * asz) + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz * csz + absz * (asz + bsz) * csz) * (bcsz * (bsz + csz) * asz) + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) / bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) / bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + (acsz * (asz + csz) + bsz) + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + (acsz * (asz + csz) + bsz) + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + (acsz * (asz + csz)) ** bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + (acsz * (asz + csz)) ** bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz - bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz - bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * ((asz * bsz + asz * csz) * (bsz * csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * ((asz * bsz + asz * csz) * (bsz * csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz - acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz - acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * ((absz + bcsz) * acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * ((absz + bcsz) * acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz - bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz - bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz * bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz * bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz - absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz - absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + ((asz + bsz + csz) * absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + ((asz + bsz + csz) * absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc - 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc - 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc * 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc * 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz - 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz - 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz * 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz * 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz - 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz - 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz * 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz * 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 2.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 2.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 0.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 0.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + -1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + -1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz - absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz - absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz * (absz * (asz + bsz) * csz) + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz * (absz * (asz + bsz) * csz) + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) / asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) / asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + (bcsz * (bsz + csz) + asz) + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + (bcsz * (bsz + csz) + asz) + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + (bcsz * (bsz + csz)) ** asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + (bcsz * (bsz + csz)) ** asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz / (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz / (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + (acsz + (asz + csz)) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + (acsz + (asz + csz)) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz ** (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz ** (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz - asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz - asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz * (asz * csz) + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz * (asz * csz) + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz / csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz / csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + (bsz + csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + (bsz + csz)) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz ** csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz ** csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz - bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz - bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz * bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz * bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz - csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz - csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + ((asz + bsz) * csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + ((asz + bsz) * csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 2) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 2) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 0) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 0) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 0) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 0) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + -1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + -1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 2.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 2.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 0.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 0.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + -1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + -1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 2.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 2.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 0.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 0.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + -1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + -1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz / csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz / csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz + csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz + csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz * bsz) ** csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz * bsz) ** csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) / csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) / csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + (absz * (asz + bsz) + csz) + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + (absz * (asz + bsz) + csz) + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + (absz * (asz + bsz)) ** csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + (absz * (asz + bsz)) ** csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz / (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz / (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + (bcsz + (bsz + csz)) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + (bcsz + (bsz + csz)) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz ** (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz ** (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz - csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz - csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz * csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz * csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz / bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz / bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz + bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz + bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz ** bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz ** bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz / csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz / csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + (asz + csz) + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + (asz + csz) + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz ** csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz ** csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz - bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz - bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz * bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz * bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz / bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz / bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int((asz + bsz) * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int((asz + bsz) * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz ** bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz ** bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz / (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz / (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + (absz + (asz + bsz)) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + (absz + (asz + bsz)) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz ** (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz ** (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz - csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz - csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz * csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz * csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz - bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz - bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "result = int(asz * bsz * csz + absz * (asz + bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "mutated_line": "result = int(asz * bsz * csz + absz * (asz * bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))",
      "code": "from math import gcd\n\ndef count_paving_groups(A, B, C):\n    d = [3.0, 1.0, 2.0, 2.0, 2.0, 1.0] * 16667\n    for i in range(4, 100001):\n        for j in range(i, 100001, i):\n            d[j] += 1.0\n    k = gcd(B, C)\n    ab = d[gcd(A, B)]\n    ac = d[gcd(A, C)]\n    bc = d[k]\n    abc = d[gcd(A, k)]\n    asz = d[A] - ab - ac + abc\n    bsz = d[B] - bc - ab + abc\n    csz = d[C] - ac - bc + abc\n    absz = ab - abc\n    bcsz = bc - abc\n    acsz = ac - abc\n    result = int(asz * bsz * csz + absz * (asz * bsz) * csz + bcsz * (bsz + csz) * asz + acsz * (asz + csz) * bsz + abc * (asz * bsz + asz * csz + bsz * csz) + abc * (absz + bcsz + acsz) * (asz + bsz + csz) + (asz + bsz + csz + absz + bcsz + acsz) * (abc * (abc + 1) * 0.5) + absz * bcsz * acsz + (absz * (absz + 1.0) * d[C] + bcsz * (bcsz + 1.0) * d[A] + acsz * (acsz + 1.0) * d[B]) * 0.5 + (asz + bsz + csz + abc) * (absz * acsz + absz * bcsz + bcsz * acsz) + (abc + abc * (abc - 1.0) + abc * (abc - 1.0) * (abc - 2.0) / 6.0))\n    return result"
    }
  ]
}