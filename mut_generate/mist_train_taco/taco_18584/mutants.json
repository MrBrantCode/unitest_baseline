{
  "task_id": "taco_18584",
  "entry_point": "find_min_subarray_elements",
  "mutant_count": 41,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que or elem <= que[-1][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que or elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que or que[0][0] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que or que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i > L - 1:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i > L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i < L - 1:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i < L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i == L - 1:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i == L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem < que[-1][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem < que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem > que[-1][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem > que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem == que[-1][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem == que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][0] < i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] < i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][0] > i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] > i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][0] == i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] == i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i >= L + 1:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L + 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i >= L * 1:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L * 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][0] <= i + L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i + L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][0] <= i * L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i * L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i >= L - 2:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 2:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i >= L - 0:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 0:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i >= L - 0:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 0:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if i >= L - 1:",
      "mutated_line": "if i >= L - -1:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - -1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-1][2]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][2]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-1][0]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][0]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-1][0]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][0]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-1][-1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][-1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][1] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][1] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][-1] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][-1] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[0][1] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][1] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[0][2])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][2])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[0][0])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[0][0])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[0][-1])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][-1])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[+1][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[+1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[1][0] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[1][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[-1][0] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[-1][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if que and que[0][0] <= i - L:",
      "mutated_line": "if que and que[1][0] <= i - L:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[1][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[1][1])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[1][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[-1][1])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[-1][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans.append(que[0][1])",
      "mutated_line": "ans.append(que[1][1])",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[1][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-2][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-2][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-0][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-0][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[-0][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[-0][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while que and elem <= que[-1][1]:",
      "mutated_line": "while que and elem <= que[--1][1]:",
      "code": "from collections import deque\n\ndef find_min_subarray_elements(a: list, L: int) -> list:\n    que: deque = deque()\n    ans = []\n    for (i, elem) in enumerate(a):\n        while que and elem <= que[--1][1]:\n            que.pop()\n        que.append((i, elem))\n        if que and que[0][0] <= i - L:\n            que.popleft()\n        if i >= L - 1:\n            ans.append(que[0][1])\n    return ans"
    }
  ]
}