{
  "task_id": "taco_709",
  "entry_point": "minimize_influence_rings",
  "mutant_count": 69,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) * 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) * 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return (x2 - x1) ** 2 + (y2 - y1) ** 2 + 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return (x2 - x1) ** 2 + (y2 - y1) ** 2 + 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 - (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 - (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 * (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 * (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 1.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 1.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** -0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** -0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 1",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 1\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** -0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** -0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n + 1):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n + 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n * 1):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n * 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) * 2 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) * 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return (x2 - x1 + 2 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return (x2 - x1 + 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) * 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) * 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1 + 2)) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1 + 2)) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 2):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 2):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 0):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 0):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - 0):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 0):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for j in range(n - 1):",
      "mutated_line": "for j in range(n - -1):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - -1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "min_dist = float('inf')",
      "mutated_line": "min_dist = float('')",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j - 1, n):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j - 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j * 1, n):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j * 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dist < min_dist:",
      "mutated_line": "if dist <= min_dist:",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist <= min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dist < min_dist:",
      "mutated_line": "if dist >= min_dist:",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist >= min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if dist < min_dist:",
      "mutated_line": "if dist != min_dist:",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist != min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 + x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 + x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 * x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 * x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 3 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 3 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 1 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 1 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 0 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 0 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 1 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 1 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** -2 + (y2 - y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** -2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 + y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 + y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 * y1) ** 2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 * y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 3) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 3) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 1) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 1) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 0) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 0) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 1) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 1) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5",
      "mutated_line": "return ((x2 - x1) ** 2 + (y2 - y1) ** -2) ** 0.5",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** -2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + 2, n):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 2, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + 0, n):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 0, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + 0, n):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 0, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for k in range(j + 1, n):",
      "mutated_line": "for k in range(j + -1, n):",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + -1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j - 1, closest_devta + 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j - 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j * 1, closest_devta + 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j * 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 1, closest_devta - 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta - 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 1, closest_devta * 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta * 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][1], points[j][1], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][1], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][-1], points[j][1], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][-1], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][1], points[j][1], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][1], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][2], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][2], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][0], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][0], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][0], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][0], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][-1], points[k][0], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][-1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][1], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][1], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][-1], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][-1], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][1], points[k][1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][1], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][2])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][2])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][0])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][0])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][0])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][0])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])",
      "mutated_line": "dist = distance(points[j][0], points[j][1], points[k][0], points[k][-1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][-1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 2, closest_devta + 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 2, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 0, closest_devta + 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 0, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 0, closest_devta + 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 0, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + -1, closest_devta + 1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + -1, closest_devta + 1])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 1, closest_devta + 2])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 2])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 1, closest_devta + 0])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 0])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 1, closest_devta + 0])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + 0])\n        results.append(connections)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "connections.append([j + 1, closest_devta + 1])",
      "mutated_line": "connections.append([j + 1, closest_devta + -1])",
      "code": "def minimize_influence_rings(test_cases):\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n    results = []\n    for points in test_cases:\n        n = len(points)\n        connections = []\n        for j in range(n - 1):\n            min_dist = float('inf')\n            closest_devta = None\n            for k in range(j + 1, n):\n                dist = distance(points[j][0], points[j][1], points[k][0], points[k][1])\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_devta = k\n            connections.append([j + 1, closest_devta + -1])\n        results.append(connections)\n    return results"
    }
  ]
}