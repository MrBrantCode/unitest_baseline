{
  "task_id": "taco_7645",
  "entry_point": "calculate_minimum_moves",
  "mutant_count": 236,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] / (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] / (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] + (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] + (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] ** (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] ** (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] / (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] / (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] + (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] + (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] ** (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] ** (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] / (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] / (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] + (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] + (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] ** (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] ** (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "invSum = 0",
      "mutated_line": "invSum = 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 1\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "invSum = 0",
      "mutated_line": "invSum = -1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = -1\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "invSum = 0",
      "mutated_line": "invSum = 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 1\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "totalSum = 0",
      "mutated_line": "totalSum = 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 1\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "totalSum = 0",
      "mutated_line": "totalSum = -1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = -1\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "totalSum = 0",
      "mutated_line": "totalSum = 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 1\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "totalSum += pos[i]",
      "mutated_line": "totalSum -= pos[i]",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum -= pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum -= i - sum(pb, pos[i]) - 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum -= i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n - 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n - 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n * 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n * 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] * (n - 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n - 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] * (n * 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n * 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] * (n - 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n - 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] * (n * 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n * 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i <= n:",
      "mutated_line": "while i < n:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i < n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i <= n:",
      "mutated_line": "while i > n:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i > n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i <= n:",
      "mutated_line": "while i == n:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i == n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "bit[i] += val",
      "mutated_line": "bit[i] -= val",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] -= val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i -= i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 1\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = -1\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 1\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i >= 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i <= 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i != 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "res += bit[i]",
      "mutated_line": "res -= bit[i]",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res -= bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i += i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if sum_val == 0:",
      "mutated_line": "if sum_val != 0:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val != 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "i += 1 << k",
      "mutated_line": "i -= 1 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i -= 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return i + 1",
      "mutated_line": "return i - 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i - 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "return i + 1",
      "mutated_line": "return i * 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i * 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(2, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(0, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(0, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(-1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n - 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n * 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(2, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(0, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(0, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(-1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n - 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n * 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i - sum(pb, pos[i]) + 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) + 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += (i - sum(pb, pos[i])) * 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += (i - sum(pb, pos[i])) * 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 2 != 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 != 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "rightSum = totalSum - sum(ps, mid2)",
      "mutated_line": "rightSum = totalSum + sum(ps, mid2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum + sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "rightSum = totalSum - sum(ps, mid2)",
      "mutated_line": "rightSum = totalSum * sum(ps, mid2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum * sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [1] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [-1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [-1] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [1] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 2)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 0)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 0)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "pos = [0] * (n + 1)",
      "mutated_line": "pos = [0] * (n + -1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + -1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [1] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [-1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [-1] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [1] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] * (n + 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 2)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] * (n + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 0)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] * (n + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 0)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "pb = [0] * (n + 1)",
      "mutated_line": "pb = [0] * (n + -1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + -1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [1] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [-1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [-1] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [1] * (n + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [1] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] * (n + 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 2)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] * (n + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 0)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] * (n + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 0)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ps = [0] * (n + 1)",
      "mutated_line": "ps = [0] * (n + -1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + -1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i | -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 1:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > -1:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 1:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i | -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i, t = 0, 0",
      "mutated_line": "(i, t) = (1, 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (1, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i, t = 0, 0",
      "mutated_line": "(i, t) = (-1, 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (-1, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i, t = 0, 0",
      "mutated_line": "(i, t) = (1, 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (1, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i, t = 0, 0",
      "mutated_line": "(i, t) = (0, 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 1)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i, t = 0, 0",
      "mutated_line": "(i, t) = (0, -1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, -1)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "i, t = 0, 0",
      "mutated_line": "(i, t) = (0, 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 1)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_val == 0:",
      "mutated_line": "if sum_val == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 1:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_val == 0:",
      "mutated_line": "if sum_val == -1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == -1:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if sum_val == 0:",
      "mutated_line": "if sum_val == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 1:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 1\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return -1\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 1\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(18, -1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(18, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(16, -1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(16, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(0, -1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(0, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(1, -1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(1, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(-17, -1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(-17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, +1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, +1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -1, +1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, +1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i <= n or t + bit[i] < sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n or t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "t += bit[i]",
      "mutated_line": "t -= bit[i]",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t -= bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "i -= 1 << k",
      "mutated_line": "i += 1 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i += 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return i + 1",
      "mutated_line": "return i + 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 2\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 0\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return i + 1",
      "mutated_line": "return i + 0",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 0\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "return i + 1",
      "mutated_line": "return i + -1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + -1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 2):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 0):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 0):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + -1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 2):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 0):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 0):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + -1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i + sum(pb, pos[i]) - 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i + sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i * sum(pb, pos[i]) - 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i * sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i - sum(pb, pos[i]) - 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 2\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i - sum(pb, pos[i]) - 0",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 0\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i - sum(pb, pos[i]) - 0",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 0\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "invSum += i - sum(pb, pos[i]) - 1",
      "mutated_line": "invSum += i - sum(pb, pos[i]) - -1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - -1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "add(pb, pos[i], 1)",
      "mutated_line": "add(pb, pos[i], 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 2)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "add(pb, pos[i], 1)",
      "mutated_line": "add(pb, pos[i], 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 0)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "add(pb, pos[i], 1)",
      "mutated_line": "add(pb, pos[i], 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 0)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "add(pb, pos[i], 1)",
      "mutated_line": "add(pb, pos[i], -1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], -1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i / 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i / 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i * 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i * 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i * 2 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i * 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i + 2 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i + 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 2 == 2:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 2:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 2 == 0:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 0:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 2 == 0:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 0:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 2 == -1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == -1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) / 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) / 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) * 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) * 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) / 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) / 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) * 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) * 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "result.append(rightSum - leftSum - seqSum + invSum)",
      "mutated_line": "result.append(rightSum - leftSum - seqSum - invSum)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum - invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "result.append(rightSum - leftSum - seqSum + invSum)",
      "mutated_line": "result.append((rightSum - leftSum - seqSum) * invSum)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append((rightSum - leftSum - seqSum) * invSum)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & +i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & +i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -2, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -2, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -0, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -0, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -0, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -0, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, --1, -1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, --1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -1, -2):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -2):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -1, -0):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -0):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -1, -0):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -0):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for k in range(17, -1, -1):",
      "mutated_line": "for k in range(17, -1, --1):",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, --1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i += 1 << k",
      "mutated_line": "i += 2 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 2 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i += 1 << k",
      "mutated_line": "i += 0 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 0 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i += 1 << k",
      "mutated_line": "i += 0 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 0 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "i += 1 << k",
      "mutated_line": "i += -1 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += -1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i < n and t + bit[i] < sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i < n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i > n and t + bit[i] < sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i > n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i == n and t + bit[i] < sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i == n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i <= n and t + bit[i] <= sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] <= sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i <= n and t + bit[i] >= sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] >= sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i <= n and t + bit[i] != sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] != sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pos[permutation[i - 1]] = i",
      "mutated_line": "pos[permutation[i + 1]] = i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i + 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pos[permutation[i - 1]] = i",
      "mutated_line": "pos[permutation[i * 1]] = i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i * 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i // 3)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 3)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i // 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 1)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i // 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 0)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i // 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 1)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "mid = find(pb, i // 2)",
      "mutated_line": "mid = find(pb, i // -2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // -2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 3 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 3 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 1 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 1 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 0 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 0 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % 1 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 1 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if i % 2 == 1:",
      "mutated_line": "if i % -2 == 1:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % -2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 2 - 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 - 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 2 * 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 * 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) / (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) / (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1 + i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1 + i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) ** (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) ** (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) // 3",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 3\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) // 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 1\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) // 0",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 0\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) // 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 1\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 2) // -2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // -2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i / (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i / (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = (i + i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = (i + i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i ** (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i ** (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) // 3",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 3\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) // 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 1\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) // 0",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 0\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) // 1",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 1\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 2) // -2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // -2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "result.append(rightSum - leftSum - seqSum + invSum)",
      "mutated_line": "result.append(rightSum - leftSum + seqSum + invSum)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum + seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "result.append(rightSum - leftSum - seqSum + invSum)",
      "mutated_line": "result.append((rightSum - leftSum) * seqSum + invSum)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append((rightSum - leftSum) * seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i <= n and t - bit[i] < sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t - bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if i <= n and t + bit[i] < sum_val:",
      "mutated_line": "if i <= n and t * bit[i] < sum_val:",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t * bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i -= 1 << k",
      "mutated_line": "i -= 2 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 2 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i -= 1 << k",
      "mutated_line": "i -= 0 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 0 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i -= 1 << k",
      "mutated_line": "i -= 0 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 0 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "i -= 1 << k",
      "mutated_line": "i -= -1 << k",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= -1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos[permutation[i - 1]] = i",
      "mutated_line": "pos[permutation[i - 2]] = i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 2]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos[permutation[i - 1]] = i",
      "mutated_line": "pos[permutation[i - 0]] = i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 0]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos[permutation[i - 1]] = i",
      "mutated_line": "pos[permutation[i - 0]] = i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 0]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pos[permutation[i - 1]] = i",
      "mutated_line": "pos[permutation[i - -1]] = i",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - -1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i / 2 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i / 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i * 2 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i * 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 2 + 2)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 2)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 2 + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 0)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 2 + 0)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 0)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 2 + -1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + -1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i - 1) * (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i - 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = i * 1 * (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = i * 1 * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i / 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i / 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i * 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i * 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i / 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i / 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i * 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i * 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "result.append(rightSum - leftSum - seqSum + invSum)",
      "mutated_line": "result.append(rightSum + leftSum - seqSum + invSum)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum + leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "result.append(rightSum - leftSum - seqSum + invSum)",
      "mutated_line": "result.append(rightSum * leftSum - seqSum + invSum)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum * leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 3 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 3 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 1 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 1 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 0 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 0 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // 1 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 1 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "mid2 = find(pb, i // 2 + 1)",
      "mutated_line": "mid2 = find(pb, i // -2 + 1)",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // -2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 2) * (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 2) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 0) * (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 0) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 0) * (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 0) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + -1) * (i // 2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + -1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 3) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 3) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 1) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 1) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 0) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 0) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // 1) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 1) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "seqSum = (i + 1) * (i // 2) // 2",
      "mutated_line": "seqSum = (i + 1) * (i // -2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // -2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 3) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 3) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 1) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 1) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 0) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 0) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // 1) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // 1) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "seqSum = i * (i // 2) // 2",
      "mutated_line": "seqSum = i * (i // -2) // 2",
      "code": "def calculate_minimum_moves(n, permutation):\n    pos = [0] * (n + 1)\n    pb = [0] * (n + 1)\n    ps = [0] * (n + 1)\n\n    def add(bit, i, val):\n        while i <= n:\n            bit[i] += val\n            i += i & -i\n\n    def sum(bit, i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    def find(bit, sum_val):\n        (i, t) = (0, 0)\n        if sum_val == 0:\n            return 0\n        for k in range(17, -1, -1):\n            i += 1 << k\n            if i <= n and t + bit[i] < sum_val:\n                t += bit[i]\n            else:\n                i -= 1 << k\n        return i + 1\n    for i in range(1, n + 1):\n        pos[permutation[i - 1]] = i\n    invSum = 0\n    totalSum = 0\n    result = []\n    for i in range(1, n + 1):\n        totalSum += pos[i]\n        invSum += i - sum(pb, pos[i]) - 1\n        add(pb, pos[i], 1)\n        add(ps, pos[i], pos[i])\n        mid = find(pb, i // 2)\n        if i % 2 == 1:\n            mid2 = find(pb, i // 2 + 1)\n            seqSum = (i + 1) * (i // 2) // 2\n        else:\n            mid2 = mid\n            seqSum = i * (i // -2) // 2\n        leftSum = sum(ps, mid)\n        rightSum = totalSum - sum(ps, mid2)\n        result.append(rightSum - leftSum - seqSum + invSum)\n    return result"
    }
  ]
}