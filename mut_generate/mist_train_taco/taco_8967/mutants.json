{
  "task_id": "taco_8967",
  "entry_point": "is_solvable",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Q = 4294967291",
      "mutated_line": "Q = 4294967292",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967292\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Q = 4294967291",
      "mutated_line": "Q = 4294967290",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967290\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Q = 4294967291",
      "mutated_line": "Q = 0",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 0\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Q = 4294967291",
      "mutated_line": "Q = 1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 1\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "Q = 4294967291",
      "mutated_line": "Q = -4294967291",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = -4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h1 = 0",
      "mutated_line": "h1 = 1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 1\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h1 = 0",
      "mutated_line": "h1 = -1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = -1\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "h1 = 0",
      "mutated_line": "h1 = 1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 1\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "h2 = 0",
      "mutated_line": "h2 = 1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 1\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "h2 = 0",
      "mutated_line": "h2 = -1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = -1\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "h2 = 0",
      "mutated_line": "h2 = 1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 1\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = 1",
      "mutated_line": "s = 2",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 2\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = 1",
      "mutated_line": "s = 0",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 0\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = 1",
      "mutated_line": "s = 0",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 0\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = 1",
      "mutated_line": "s = -1",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = -1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return \"YES\"",
      "mutated_line": "return ''",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': 'S', '': 'N', 'E': 'W', 'W': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', '': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': 'S', 'S': 'N', '': 'W', 'W': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', '': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', '': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', '': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': '', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': '', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': 'S', 'S': '', 'E': 'W', 'W': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': '', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': 'S', 'S': 'N', 'E': '', 'W': 'E'}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': '', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}",
      "mutated_line": "opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': ''}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': ''}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'': 0, 'S': 1, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, '': 1, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, '': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, '': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, '': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 2, '': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, '': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 1, 'S': 1, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 1, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': -1, 'S': 1, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': -1, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 1, 'S': 1, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 1, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 2, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 2, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 0, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 0, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 0, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 0, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': -1, 'E': 2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': -1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 3, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 3, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 1, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 1, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 0, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 0, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 1, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 1, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': -2, 'W': 3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': -2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 4}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 4}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 2}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 2}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 0}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 0}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 1}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 1}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}",
      "mutated_line": "bits = {'N': 0, 'S': 1, 'E': 2, 'W': -3}",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': -3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 2 | v) * q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) * q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 2 | v) + q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) + q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return (v * s + h) * q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) * q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return v * s + h + q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return v * s + h + q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if h1 == h2 and path1[i:] == flip(path2[i:]):",
      "mutated_line": "if h1 == h2 or path1[i:] == flip(path2[i:]):",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 or path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << 2) * Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) * Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << 2) + Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) + Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 2 & v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 & v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 2 ^ v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 ^ v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return (v * s - h) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s - h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return v * s * h % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return v * s * h % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if h1 == h2 and path1[i:] == flip(path2[i:]):",
      "mutated_line": "if h1 != h2 and path1[i:] == flip(path2[i:]):",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 != h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if h1 == h2 and path1[i:] == flip(path2[i:]):",
      "mutated_line": "if h1 == h2 and path1[i:] != flip(path2[i:]):",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] != flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return \"NO\"",
      "mutated_line": "return ''",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return ''\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return (v / s + h) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v / s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return (v + s + h) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v + s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "return (v * s + h) % q",
      "mutated_line": "return (v ** s + h) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v ** s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return ''.join(reversed(s.translate(otr)))",
      "mutated_line": "return 'MUTATED'.join(reversed(s.translate(otr)))",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return 'MUTATED'.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << 3) % Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 3) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << 1) % Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 1) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << 0) % Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 0) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << 1) % Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 1) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s = (s << 2) % Q",
      "mutated_line": "s = (s << -2) % Q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << -2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 3 | v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 3 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 1 | v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 1 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 0 | v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 0 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << 1 | v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << 1 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return (h << 2 | v) % q",
      "mutated_line": "return (h << -2 | v) % q",
      "code": "def is_solvable(n, path1, path2):\n    opposite = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}\n    otr = str.maketrans(opposite)\n    bits = {'N': 0, 'S': 1, 'E': 2, 'W': 3}\n    Q = 4294967291\n\n    def combine(h, v, q):\n        return (h << -2 | v) % q\n\n    def combinel(h, v, q, s):\n        return (v * s + h) % q\n\n    def flip(s):\n        return ''.join(reversed(s.translate(otr)))\n    h1 = 0\n    h2 = 0\n    s = 1\n    for i in reversed(range(len(path1))):\n        n1 = bits[path1[i]]\n        n2 = bits[opposite[path2[i]]]\n        h1 = combine(h1, n1, Q)\n        h2 = combinel(h2, n2, Q, s)\n        if h1 == h2 and path1[i:] == flip(path2[i:]):\n            return 'NO'\n        s = (s << 2) % Q\n    return 'YES'"
    }
  ]
}