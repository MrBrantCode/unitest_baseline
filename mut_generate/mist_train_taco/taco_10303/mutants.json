{
  "task_id": "taco_10303",
  "entry_point": "min_edges_to_reverse",
  "mutant_count": 119,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [-1] / N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] / N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [-1] + N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] + N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [-1] ** N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] ** N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_arr = [False] * N",
      "mutated_line": "vis_arr = [False] / N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] / N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_arr = [False] * N",
      "mutated_line": "vis_arr = [False] + N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] + N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "vis_arr = [False] * N",
      "mutated_line": "vis_arr = [False] ** N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] ** N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "short_dis[0] = 0",
      "mutated_line": "short_dis[0] = 1",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 1\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "short_dis[0] = 0",
      "mutated_line": "short_dis[0] = -1",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = -1\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "short_dis[0] = 0",
      "mutated_line": "short_dis[0] = 1",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 1\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if_break = False",
      "mutated_line": "if_break = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = True\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return +1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "short_dis[0] = 0",
      "mutated_line": "short_dis[1] = 0",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[1] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "short_dis[0] = 0",
      "mutated_line": "short_dis[-1] = 0",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[-1] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "short_dis[0] = 0",
      "mutated_line": "short_dis[1] = 0",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[1] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node - 1] = False",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = False\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if node == N:",
      "mutated_line": "if node != N:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node != N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[1, 1]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[1, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[-1, 1]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[-1, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[1, 1]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[1, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[0, 2]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 2]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[0, 0]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 0]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[0, 0]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 0]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "queue = [[0, 1]]",
      "mutated_line": "queue = [[0, -1]]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, -1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [+1] * N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [+1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "vis_arr = [False] * N",
      "mutated_line": "vis_arr = [True] * N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [True] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node + 1] = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node + 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node * 1] = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node * 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] or (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] or (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(2, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(0, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(0, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(-1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N - 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N * 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u].append([v, 0])  # Directed edge from u to v",
      "mutated_line": "graph[u].append([v, 1])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 1])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u].append([v, 0])  # Directed edge from u to v",
      "mutated_line": "graph[u].append([v, -1])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, -1])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph[u].append([v, 0])  # Directed edge from u to v",
      "mutated_line": "graph[u].append([v, 1])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 1])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v].append([u, 1])  # Reversed edge from v to u",
      "mutated_line": "graph[v].append([u, 2])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 2])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v].append([u, 1])  # Reversed edge from v to u",
      "mutated_line": "graph[v].append([u, 0])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 0])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v].append([u, 1])  # Reversed edge from v to u",
      "mutated_line": "graph[v].append([u, 0])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 0])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "graph[v].append([u, 1])  # Reversed edge from v to u",
      "mutated_line": "graph[v].append([u, -1])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, -1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [-2] * N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-2] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [-0] * N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-0] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [-0] * N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-0] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "short_dis = [-1] * N",
      "mutated_line": "short_dis = [--1] * N",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [--1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node - 2] = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 2] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node - 0] = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 0] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node - 0] = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 0] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "vis_arr[node - 1] = True",
      "mutated_line": "vis_arr[node - -1] = True",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - -1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return short_dis[N - 1]",
      "mutated_line": "return short_dis[N + 1]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N + 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return short_dis[N - 1]",
      "mutated_line": "return short_dis[N * 1]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N * 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 and short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 and short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node - 1] - weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] - weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node - 1] * weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] * weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 2)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 0)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 0)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "for (u, v) in edges:",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + -1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return short_dis[N - 1]",
      "mutated_line": "return short_dis[N - 2]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 2]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return short_dis[N - 1]",
      "mutated_line": "return short_dis[N - 0]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 0]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return short_dis[N - 1]",
      "mutated_line": "return short_dis[N - 0]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 0]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return short_dis[N - 1]",
      "mutated_line": "return short_dis[N - -1]",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - -1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] != -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] != -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] >= short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] >= short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] <= short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] <= short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] != short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] != short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child + 1] = short_dis[node - 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child + 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child * 1] = short_dis[node - 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child * 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child + 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child + 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child * 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child * 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == +1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == +1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] - weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] - weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] * weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] * weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 2] = short_dis[node - 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 2] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 0] = short_dis[node - 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 0] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 0] = short_dis[node - 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 0] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - -1] = short_dis[node - 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - -1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node + 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node + 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node * 1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node * 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 2] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 2] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 0] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 0] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 0] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 0] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - -1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - -1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child + 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child + 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child * 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child * 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -2 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -2 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -0 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -0 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -0 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -0 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == --1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == --1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child + 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child + 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child * 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child * 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node - 2] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 2] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node - 0] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 0] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node - 0] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 0] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "short_dis[child - 1] = short_dis[node - 1] + weight",
      "mutated_line": "short_dis[child - 1] = short_dis[node - -1] + weight",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - -1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(queue, [short_dis[child - 1], child])",
      "mutated_line": "heappush(queue, [short_dis[child + 1], child])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child + 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "heappush(queue, [short_dis[child - 1], child])",
      "mutated_line": "heappush(queue, [short_dis[child * 1], child])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child * 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 2] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 2] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 0] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 0] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 0] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 0] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - -1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - -1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 2] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 2] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 0] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 0] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 0] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 0] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - -1] > short_dis[node - 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - -1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node + 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node + 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node * 1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node * 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(queue, [short_dis[child - 1], child])",
      "mutated_line": "heappush(queue, [short_dis[child - 2], child])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 2], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(queue, [short_dis[child - 1], child])",
      "mutated_line": "heappush(queue, [short_dis[child - 0], child])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 0], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(queue, [short_dis[child - 1], child])",
      "mutated_line": "heappush(queue, [short_dis[child - 0], child])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 0], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heappush(queue, [short_dis[child - 1], child])",
      "mutated_line": "heappush(queue, [short_dis[child - -1], child])",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - -1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 2] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 2] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 0] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 0] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 0] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 0] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - 1] + weight):",
      "mutated_line": "if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - -1] + weight):",
      "code": "from heapq import heappop, heappush, heapify\n\ndef min_edges_to_reverse(N, M, edges):\n    graph = {i: [] for i in range(1, N + 1)}\n    for (u, v) in edges:\n        graph[u].append([v, 0])\n        graph[v].append([u, 1])\n    queue = [[0, 1]]\n    heapify(queue)\n    short_dis = [-1] * N\n    vis_arr = [False] * N\n    short_dis[0] = 0\n    if_break = False\n    while queue:\n        (dis, node) = heappop(queue)\n        vis_arr[node - 1] = True\n        if node == N:\n            return short_dis[N - 1]\n        for (child, weight) in graph[node]:\n            if not vis_arr[child - 1] and (short_dis[child - 1] == -1 or short_dis[child - 1] > short_dis[node - -1] + weight):\n                short_dis[child - 1] = short_dis[node - 1] + weight\n                heappush(queue, [short_dis[child - 1], child])\n    return -1"
    }
  ]
}