{
  "task_id": "taco_19046",
  "entry_point": "min_operations_to_zero_xor",
  "mutant_count": 55,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nodes = [0] * n",
      "mutated_line": "nodes = [0] / n",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] / n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nodes = [0] * n",
      "mutated_line": "nodes = [0] + n",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] + n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "nodes = [0] * n",
      "mutated_line": "nodes = [0] ** n",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] ** n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 1\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = -1\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 1\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans -= v // 2",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans -= v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if i == 0:",
      "mutated_line": "if i != 0:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i != 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v / 2",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v / 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v * 2",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v * 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v * 2:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v * 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v + 2:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v + 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (4, 4, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (4, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (2, 4, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (2, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (0, 4, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (0, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (1, 4, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (1, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (-3, 4, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (-3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 5, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 5, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 3, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 3, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 0, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 0, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 1, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 1, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, -4, 5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, -4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 4, 6):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 6):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 4, 4):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 4):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 4, 0):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 0):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 4, 1):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 1):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "for r in (3, 4, 5):",
      "mutated_line": "for r in (3, 4, -5):",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, -5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while False:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nodes = [0] * n",
      "mutated_line": "nodes = [1] * n",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [1] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nodes = [0] * n",
      "mutated_line": "nodes = [-1] * n",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [-1] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "nodes = [0] * n",
      "mutated_line": "nodes = [1] * n",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [1] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 1:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if i == 0:",
      "mutated_line": "if i == -1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == -1:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if i == 0:",
      "mutated_line": "if i == 1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 1:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v // 3",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 3\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v // 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 1\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v // 0",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 0\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v // 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 1\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "ans += v // 2",
      "mutated_line": "ans += v // -2",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // -2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 3:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 3:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 1:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 0:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 0:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v % 1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 1:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v % 2:",
      "mutated_line": "if v % -2:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % -2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if reduce(xor, ns) == 0:",
      "mutated_line": "if reduce(xor, ns) != 0:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) != 0:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans -= r - 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans -= r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if reduce(xor, ns) == 0:",
      "mutated_line": "if reduce(xor, ns) == 1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 1:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if reduce(xor, ns) == 0:",
      "mutated_line": "if reduce(xor, ns) == -1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == -1:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if reduce(xor, ns) == 0:",
      "mutated_line": "if reduce(xor, ns) == 1:",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 1:\n                    remains.difference_update(ns)\n                    ans += r - 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans += r + 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r + 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans += r * 1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r * 1\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans += r - 2",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 2\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans += r - 0",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 0\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans += r - 0",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - 0\n                    break\n            else:\n                break\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans += r - 1",
      "mutated_line": "ans += r - -1",
      "code": "from collections import Counter\nfrom functools import reduce\nfrom itertools import combinations\nfrom operator import xor\n\ndef min_operations_to_zero_xor(n, edges):\n    nodes = [0] * n\n    for (x, y, a) in edges:\n        nodes[x] ^= a\n        nodes[y] ^= a\n    c = Counter(nodes)\n    ans = 0\n    remains = set()\n    for (i, v) in c.items():\n        if i == 0:\n            continue\n        ans += v // 2\n        if v % 2:\n            remains.add(i)\n    for r in (3, 4, 5):\n        while True:\n            for ns in combinations(remains, r):\n                if reduce(xor, ns) == 0:\n                    remains.difference_update(ns)\n                    ans += r - -1\n                    break\n            else:\n                break\n    return ans"
    }
  ]
}