{
  "task_id": "taco_9414",
  "entry_point": "calculate_minimum_sum",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 - 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 * 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(110000)",
      "mutated_line": "sys.setrecursionlimit(110001)",
      "code": "import sys\nsys.setrecursionlimit(110001)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(110000)",
      "mutated_line": "sys.setrecursionlimit(109999)",
      "code": "import sys\nsys.setrecursionlimit(109999)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(110000)",
      "mutated_line": "sys.setrecursionlimit(0)",
      "code": "import sys\nsys.setrecursionlimit(0)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(110000)",
      "mutated_line": "sys.setrecursionlimit(1)",
      "code": "import sys\nsys.setrecursionlimit(1)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "sys.setrecursionlimit(110000)",
      "mutated_line": "sys.setrecursionlimit(-110000)",
      "code": "import sys\nsys.setrecursionlimit(-110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 * 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 + 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 8\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 6\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 0\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 1\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + -7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 1, 0) * mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) * mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 1, 0) + mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) + mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 11 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 9 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 0 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 1 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = -10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 10 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 8 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 0 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 1 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** -9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "_sum = 1",
      "mutated_line": "_sum = 2",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 2\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "_sum = 1",
      "mutated_line": "_sum = 0",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 0\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "_sum = 1",
      "mutated_line": "_sum = 0",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 0\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "_sum = 1",
      "mutated_line": "_sum = -1",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = -1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum -= (idx + 1) * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum -= (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x / solve(tree, 1, 0) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x / solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = (x + solve(tree, 1, 0)) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = (x + solve(tree, 1, 0)) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x ** solve(tree, 1, 0) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x ** solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if child != parent:",
      "mutated_line": "if child == parent:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child == parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx + 1) / val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) / val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += idx + 1 + val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += idx + 1 + val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx + 1) ** val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) ** val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "arr.sort(reverse=True)",
      "mutated_line": "arr.sort(reverse=False)",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=False)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx - 1) * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx - 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += idx * 1 * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += idx * 1 * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 2, 0) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 2, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 0, 0) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 0, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 0, 0) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 0, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, -1, 0) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, -1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 1, 1) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 1) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 1, -1) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, -1) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "result = x * solve(tree, 1, 0) % mod",
      "mutated_line": "result = x * solve(tree, 1, 1) % mod",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 1) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "tree = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx + 2) * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 2) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx + 0) * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 0) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx + 0) * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + 0) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "_sum += (idx + 1) * val",
      "mutated_line": "_sum += (idx + -1) * val",
      "code": "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef calculate_minimum_sum(n, x, edges):\n    tree = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def solve(t, i, parent):\n        arr = []\n        for child in t[i]:\n            if child != parent:\n                arr.append(solve(t, child, i))\n        arr.sort(reverse=True)\n        _sum = 1\n        for (idx, val) in enumerate(arr):\n            _sum += (idx + -1) * val\n        return _sum\n    result = x * solve(tree, 1, 0) % mod\n    return result"
    }
  ]
}