{
  "task_id": "taco_17248",
  "entry_point": "find_shortest_closed_cycle",
  "mutant_count": 108,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 18] / num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] / num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 18] + num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] + num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 18] ** num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] ** num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] / num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] + num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] ** num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dp[s][n] >= 0:",
      "mutated_line": "if dp[s][n] > 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] > 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dp[s][n] >= 0:",
      "mutated_line": "if dp[s][n] < 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] < 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dp[s][n] >= 0:",
      "mutated_line": "if dp[s][n] == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] == 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 1 or n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 or n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 * 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 * 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 + 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 + 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = f(0, 0, dp)",
      "mutated_line": "return ans if ans != 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(1, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = f(0, 0, dp)",
      "mutated_line": "return ans if ans != 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(-1, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = f(0, 0, dp)",
      "mutated_line": "return ans if ans != 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(1, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = f(0, 0, dp)",
      "mutated_line": "return ans if ans != 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 1, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = f(0, 0, dp)",
      "mutated_line": "return ans if ans != 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, -1, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = f(0, 0, dp)",
      "mutated_line": "return ans if ans != 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 1, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans == 10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans == 10 ** 18 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 18 else +1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else +1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp[s][n] >= 0:",
      "mutated_line": "if dp[s][n] >= 1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 1:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp[s][n] >= 0:",
      "mutated_line": "if dp[s][n] >= -1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= -1:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp[s][n] >= 0:",
      "mutated_line": "if dp[s][n] >= 1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 1:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s != (1 << num_vertices) - 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s != (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 1 and n != 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n != 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[s][n] = 0",
      "mutated_line": "dp[s][n] = 1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 1\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[s][n] = 0",
      "mutated_line": "dp[s][n] = -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = -1\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dp[s][n] = 0",
      "mutated_line": "dp[s][n] = 1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 1\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 1\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return -1\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 1\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 11 ** 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 11 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 9 ** 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 9 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 0 ** 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 0 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 1 ** 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 1 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = -10 ** 18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = -10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 ** 19",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 19\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 ** 17",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 17\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 ** 0",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 0\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 ** 1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 1\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "tmp = 10**18",
      "mutated_line": "tmp = 10 ** -18",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** -18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 1 != 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 != 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 * 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 * 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 + 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 + 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 18 else -2",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -2"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 18 else -0",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 18 else -0",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -0"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 18 else --1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else --1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 * 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 * 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 + 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 + 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[+1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) + 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) + 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) * 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) * 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 1 and n == 1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 1:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 1 and n == -1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == -1:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 1 and n == 1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 1:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u | 1 == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u | 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 1 == 1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 1:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 1 == -1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == -1:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 1 == 1:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 1:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 11 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 11 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 9 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 9 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 0 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 0 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 1 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 1 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != -10 ** 18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != -10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 19 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 19 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 17 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 17 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 0 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 0 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** 1 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 1 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return ans if ans != 10**18 else -1",
      "mutated_line": "return ans if ans != 10 ** -18 else -1",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** -18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[11 ** 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[11 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[9 ** 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[9 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[0 ** 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[0 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[1 ** 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[1 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[-10 ** 18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[-10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 19] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 19] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 17] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 17] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 0] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 0] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** 1] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 1] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "d = [[10**18] * num_vertices for _ in range(num_vertices)]",
      "mutated_line": "d = [[10 ** -18] * num_vertices for _ in range(num_vertices)]",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** -18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-2] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-0] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-0] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[--1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(2 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(0 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(0 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]",
      "mutated_line": "for (s, t, w) in edges:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(-1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 2 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 2 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 0 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 0 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - 0 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 0 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (1 << num_vertices) - -1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - -1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 2 == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 2 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 0 == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 0 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & 0 == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 0 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if s >> u & 1 == 0:",
      "mutated_line": "if s >> u & -1 == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & -1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s | 1 << u, u, dp) - d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) - d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s | 1 << u, u, dp) * d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) * d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (2 << num_vertices) - 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (2 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (0 << num_vertices) - 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (0 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (0 << num_vertices) - 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (0 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if s == (1 << num_vertices) - 1 and n == 0:",
      "mutated_line": "if s == (-1 << num_vertices) - 1 and n == 0:",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (-1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s & 1 << u, u, dp) + d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s & 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s ^ 1 << u, u, dp) + d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s ^ 1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s | 2 << u, u, dp) + d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 2 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s | 0 << u, u, dp) + d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 0 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s | 0 << u, u, dp) + d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | 0 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "tmp = min(tmp, f(s | 1 << u, u, dp) + d[n][u])",
      "mutated_line": "tmp = min(tmp, f(s | -1 << u, u, dp) + d[n][u])",
      "code": "def find_shortest_closed_cycle(num_vertices, num_edges, edges):\n    d = [[10 ** 18] * num_vertices for _ in range(num_vertices)]\n    dp = [[-1] * num_vertices for _ in range(1 << num_vertices)]\n    for (s, t, w) in edges:\n        d[s][t] = w\n\n    def f(s, n, dp):\n        if dp[s][n] >= 0:\n            return dp[s][n]\n        if s == (1 << num_vertices) - 1 and n == 0:\n            dp[s][n] = 0\n            return 0\n        tmp = 10 ** 18\n        for u in range(num_vertices):\n            if s >> u & 1 == 0:\n                tmp = min(tmp, f(s | -1 << u, u, dp) + d[n][u])\n        dp[s][n] = tmp\n        return tmp\n    ans = f(0, 0, dp)\n    return ans if ans != 10 ** 18 else -1"
    }
  ]
}