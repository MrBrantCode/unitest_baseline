{
  "task_id": "taco_15292",
  "entry_point": "getsqrt",
  "mutant_count": 131,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + 1) < x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) < x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + 1) > x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) > x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + 1) == x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) == x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "s += 1",
      "mutated_line": "s -= 1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s -= 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while s * s > x:",
      "mutated_line": "while s * s >= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s >= x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while s * s > x:",
      "mutated_line": "while s * s <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s <= x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while s * s > x:",
      "mutated_line": "while s * s != x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s != x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "s -= 1",
      "mutated_line": "s += 1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s += 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) / (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) / (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while s + 1 + (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while s + 1 + (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) ** (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) ** (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s += 1",
      "mutated_line": "s += 2",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 2\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 0\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s += 1",
      "mutated_line": "s += 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 0\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "s += 1",
      "mutated_line": "s += -1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += -1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while s * s > x:",
      "mutated_line": "while s / s > x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s / s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while s * s > x:",
      "mutated_line": "while s + s > x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s + s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while s * s > x:",
      "mutated_line": "while s ** s > x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s ** s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s -= 1",
      "mutated_line": "s -= 2",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 2\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 0\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 0\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s -= 1",
      "mutated_line": "s -= -1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= -1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 9 or u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 or u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if y not in reached:",
      "mutated_line": "if y in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 * 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 * 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 + 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 + 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s - 1) * (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s - 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while s * 1 * (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while s * 1 * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s - 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s - 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s * 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s * 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [[x, 0]]",
      "mutated_line": "queue = [[x, 1]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 1]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [[x, 0]]",
      "mutated_line": "queue = [[x, -1]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, -1]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue = [[x, 0]]",
      "mutated_line": "queue = [[x, 1]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 1]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u < 10 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u < 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u > 10 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u > 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u == 10 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u == 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 9 and u * u in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 11 ** 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 11 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 9 ** 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 9 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 0 ** 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 0 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 1 ** 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 1 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = -10 ** 18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = -10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 19",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 19\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 17",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 17\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 0\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** 1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 1\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "ans = 10 ** 18",
      "mutated_line": "ans = 10 ** -18",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** -18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 2) * (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 2) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 0) * (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 0) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 0) * (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 0) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + -1) * (s + 1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + -1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + 2) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 2) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + 0) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 0) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + 0) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 0) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "while (s + 1) * (s + 1) <= x:",
      "mutated_line": "while (s + 1) * (s + -1) <= x:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + -1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 * 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 * 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 + 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 + 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 9 and u / u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u / u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 9 and u + u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u + u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 9 and u ** u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u ** u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "reached.add(u * u)",
      "mutated_line": "reached.add(u / u)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u / u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "reached.add(u * u)",
      "mutated_line": "reached.add(u + u)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u + u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "reached.add(u * u)",
      "mutated_line": "reached.add(u ** u)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u ** u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[2, 0]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[2, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[0, 0]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[0, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[0, 0]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[0, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[-1, 0]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[-1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[1, 1]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 1]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[1, -1]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, -1]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "prv = [[1, 0]]",
      "mutated_line": "prv = [[1, 1]]",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 1]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (1, 10 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (1, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (-1, 10 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (-1, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (1, 10 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (1, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 * 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 * 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 + 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 + 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) or prv[ptr][0] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) or prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "ptr += 1",
      "mutated_line": "ptr -= 1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr -= 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 11 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 11 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 9 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 9 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 0 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 0 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 1 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 1 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= -10 ** 9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= -10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 10 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 10 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 8 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 8 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 0 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 0 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** 1 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 1 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if u <= 10 ** 9 and u * u not in reached:",
      "mutated_line": "if u <= 10 ** -9 and u * u not in reached:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** -9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u / u, d + 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u / u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u + u, d + 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u + u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u ** u, d + 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u ** u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u * u, d - 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d - 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u * u, d * 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d * 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "queue.append([y, d + 1])",
      "mutated_line": "queue.append([y, d - 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d - 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "queue.append([y, d + 1])",
      "mutated_line": "queue.append([y, d * 1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d * 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 11 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 11 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 9 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 9 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 0 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 0 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 1 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 1 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, -10 ** 18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, -10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 ** 19)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 19)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 ** 17)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 17)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 ** 0)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 0)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 ** 1)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 1)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(ptr, mn) = (0, 10 ** 18)",
      "mutated_line": "(ptr, mn) = (0, 10 ** -18)",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** -18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr <= len(prv) and prv[ptr][0] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr <= len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr >= len(prv) and prv[ptr][0] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr >= len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr != len(prv) and prv[ptr][0] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr != len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) and prv[ptr][0] < y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] < y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) and prv[ptr][0] > y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] > y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) and prv[ptr][0] == y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] == y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += 2",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 2\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 0\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += 0",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 0\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ptr += 1",
      "mutated_line": "ptr += -1",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += -1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u * u, d + 2])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 2])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u * u, d + 0])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 0])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u * u, d + 0])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 0])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "queue.append([u * u, d + 1])",
      "mutated_line": "queue.append([u * u, d + -1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + -1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append([y, d + 1])",
      "mutated_line": "queue.append([y, d + 2])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 2])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append([y, d + 1])",
      "mutated_line": "queue.append([y, d + 0])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 0])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append([y, d + 1])",
      "mutated_line": "queue.append([y, d + 0])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 0])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "queue.append([y, d + 1])",
      "mutated_line": "queue.append([y, d + -1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + -1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp.append([y, d + mn])",
      "mutated_line": "dp.append([y, d - mn])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d - mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "dp.append([y, d + mn])",
      "mutated_line": "dp.append([y, d * mn])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d * mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) and prv[ptr][1] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][1] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) and prv[ptr][-1] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][-1] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while ptr < len(prv) and prv[ptr][0] <= y:",
      "mutated_line": "while ptr < len(prv) and prv[ptr][1] <= y:",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][1] <= y:\n                    mn = min(mn, prv[ptr][1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mn = min(mn, prv[ptr][1])",
      "mutated_line": "mn = min(mn, prv[ptr][2])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][2])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mn = min(mn, prv[ptr][1])",
      "mutated_line": "mn = min(mn, prv[ptr][0])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][0])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mn = min(mn, prv[ptr][1])",
      "mutated_line": "mn = min(mn, prv[ptr][0])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][0])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "mn = min(mn, prv[ptr][1])",
      "mutated_line": "mn = min(mn, prv[ptr][-1])",
      "code": "from collections import deque\nimport math\n\ndef getsqrt(x):\n    s = int(math.sqrt(x))\n    while (s + 1) * (s + 1) <= x:\n        s += 1\n    while s * s > x:\n        s -= 1\n    return s\n\ndef bfs(x):\n    queue = [[x, 0]]\n    reached = set([x])\n    for (u, d) in queue:\n        if u <= 10 ** 9 and u * u not in reached:\n            reached.add(u * u)\n            queue.append([u * u, d + 1])\n        y = getsqrt(u)\n        if y not in reached:\n            reached.add(y)\n            queue.append([y, d + 1])\n    return sorted(queue)\n\ndef min_operations_to_sort_array(test_cases):\n    results = []\n    for (n, a) in test_cases:\n        prv = [[1, 0]]\n        for x in a:\n            costs = bfs(x)\n            dp = []\n            (ptr, mn) = (0, 10 ** 18)\n            for (y, d) in costs:\n                while ptr < len(prv) and prv[ptr][0] <= y:\n                    mn = min(mn, prv[ptr][-1])\n                    ptr += 1\n                dp.append([y, d + mn])\n            prv = dp\n        ans = 10 ** 18\n        for (x, d) in prv:\n            ans = min(ans, d)\n        results.append(ans)\n    return results"
    }
  ]
}