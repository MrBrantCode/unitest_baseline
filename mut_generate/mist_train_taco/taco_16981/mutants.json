{
  "task_id": "taco_16981",
  "entry_point": "calculate_max_verse_beauty",
  "mutant_count": 328,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 1\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = -1\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 1\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new = ''",
      "mutated_line": "new = 'MUTATED'",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = 'MUTATED'\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "new += u[i] + v[i]",
      "mutated_line": "new -= u[i] + v[i]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new -= u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mini = 1000000000000",
      "mutated_line": "mini = 1000000000001",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000001\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mini = 1000000000000",
      "mutated_line": "mini = 999999999999",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 999999999999\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mini = 1000000000000",
      "mutated_line": "mini = 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 0\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mini = 1000000000000",
      "mutated_line": "mini = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mini = 1000000000000",
      "mutated_line": "mini = -1000000000000",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = -1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 1\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "index = 0",
      "mutated_line": "index = -1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = -1\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "index = 0",
      "mutated_line": "index = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 1\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[0] != k[-1]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] != k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if len(k) == 1:",
      "mutated_line": "if len(k) != 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) != 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if len(k) == 2:",
      "mutated_line": "if len(k) != 2:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) != 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 or a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 or a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new += u[i] + v[i]",
      "mutated_line": "new += u[i] - v[i]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] - v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "new += u[i] + v[i]",
      "mutated_line": "new += u[i] * v[i]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] * v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(1, len(k) - 1):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(1, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(-1, len(k) - 1):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(-1, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(1, len(k) - 1):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(1, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(0, len(k) + 1):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) + 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(0, len(k) * 1):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) * 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "u = 0",
      "mutated_line": "u = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 1\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "u = 0",
      "mutated_line": "u = -1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = -1\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "u = 0",
      "mutated_line": "u = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 1\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if mini > u:",
      "mutated_line": "if mini >= u:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini >= u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if mini > u:",
      "mutated_line": "if mini <= u:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini <= u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if mini > u:",
      "mutated_line": "if mini != u:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini != u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) / 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) / 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) * 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) * 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 2 != 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 != 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(k) == 1:",
      "mutated_line": "if len(k) == 2:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 2:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(k) == 1:",
      "mutated_line": "if len(k) == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 0:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(k) == 1:",
      "mutated_line": "if len(k) == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 0:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if len(k) == 1:",
      "mutated_line": "if len(k) == -1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == -1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(k) == 2:",
      "mutated_line": "if len(k) == 3:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 3:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(k) == 2:",
      "mutated_line": "if len(k) == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 1:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(k) == 2:",
      "mutated_line": "if len(k) == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 0:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(k) == 2:",
      "mutated_line": "if len(k) == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 1:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if len(k) == 2:",
      "mutated_line": "if len(k) == -2:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == -2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini / 2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini / 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini * 2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini * 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] != 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] != 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[0] != 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] != 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "u = 0",
      "mutated_line": "u = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 1\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "u = 0",
      "mutated_line": "u = -1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = -1\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "u = 0",
      "mutated_line": "u = 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 1\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u / 2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u / 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u * 2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u * 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 or a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 or a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "v = u[::-1]",
      "mutated_line": "v = u[::+1]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::+1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(0, len(k) - 2):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 2):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(0, len(k) - 0):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 0):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(0, len(k) - 0):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 0):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(0, len(k) - 1):",
      "mutated_line": "for i in range(0, len(k) - -1):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - -1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] != k[i + 1][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] != k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "u += 1",
      "mutated_line": "u -= 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u -= 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[1] == k[-1]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[1] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[-1] == k[-1]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[-1] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[1] == k[-1]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[1] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[0] == k[+1]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[+1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) / len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) / len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = (len(k) // 2 * len(k[0]) + len(k[0])) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = (len(k) // 2 * len(k[0]) + len(k[0])) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = (len(k) // 2 * len(k[0])) ** len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = (len(k) // 2 * len(k[0])) ** len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 5",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 5\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 3",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 3\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 0\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 1\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // -4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // -4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) * 2 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) * 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) + 2 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) + 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 2 == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 1:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 2 == -1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == -1:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 2 == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 1:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (2, mmm.index(k[0]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (2, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (0, mmm.index(k[0]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (0, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (0, mmm.index(k[0]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (0, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (-1, mmm.index(k[0]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (-1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (1, mmm.index(k[0]), 1)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 1)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (1, mmm.index(k[0]), -1)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), -1)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (1, mmm.index(k[0]), 1)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 1)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini // 3",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 3\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini // 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 1\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini // 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 0\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini // 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 1\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "mini = mini // 2",
      "mutated_line": "mini = mini // -2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // -2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (1, 0, mini * mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (1, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (-1, 0, mini * mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (-1, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (1, 0, mini * mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (1, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (0, 1, mini * mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 1, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (0, -1, mini * mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, -1, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (0, 1, mini * mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 1, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (0, 0, mini / mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini / mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (0, 0, mini + mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini + mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "return (0, 0, mini * mini)",
      "mutated_line": "return (0, 0, mini ** mini)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini ** mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 2 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 2 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 0 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 0 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 0 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 0 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == -1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == -1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[0] == 2:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 2:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 0:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 0:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[0] == -1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == -1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[1]][j] != mmm[a2[1]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] != mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "u += 1",
      "mutated_line": "u -= 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u -= 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u // 3",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 3\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u // 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 1\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u // 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 0\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u // 1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 1\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "u = u // 2",
      "mutated_line": "u = u // -2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // -2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (1, 0, a1[2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (1, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (-1, 0, a1[2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (-1, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (1, 0, a1[2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (1, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 1, a1[2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 1, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, -1, a1[2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, -1, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 1, a1[2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 1, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[2] - u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] - u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, (a1[2] + a2[2]) * (u * u))",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, (a1[2] + a2[2]) * (u * u))\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] != 1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] != 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[0] != 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] != 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 or a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 or a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "results.append(a[2])",
      "mutated_line": "results.append(a[3])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[3])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "results.append(a[2])",
      "mutated_line": "results.append(a[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "results.append(a[2])",
      "mutated_line": "results.append(a[0])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[0])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "results.append(a[2])",
      "mutated_line": "results.append(a[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[1])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "results.append(a[2])",
      "mutated_line": "results.append(a[-2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[-2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "v = u[::-1]",
      "mutated_line": "v = u[::-2]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-2]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "v = u[::-1]",
      "mutated_line": "v = u[::-0]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-0]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "v = u[::-1]",
      "mutated_line": "v = u[::-0]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-0]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "v = u[::-1]",
      "mutated_line": "v = u[::--1]",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::--1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "u += 1",
      "mutated_line": "u += 2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 2\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "u += 1",
      "mutated_line": "u += 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 0\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "u += 1",
      "mutated_line": "u += 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 0\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "u += 1",
      "mutated_line": "u += -1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += -1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[0] == k[-2]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-2]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[0] == k[-0]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-0]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[0] == k[-0]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-0]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if k[0] == k[-1]:",
      "mutated_line": "if k[0] == k[--1]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[--1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 / len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 / len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = (len(k) // 2 + len(k[0])) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = (len(k) // 2 + len(k[0])) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = (len(k) // 2) ** len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = (len(k) // 2) ** len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 3 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 3 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 1 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 1 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 0 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 0 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % 1 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 1 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if len(k) % 2 == 0:",
      "mutated_line": "if len(k) % -2 == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % -2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (0, 0, c)",
      "mutated_line": "return (1, 0, c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (1, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (0, 0, c)",
      "mutated_line": "return (-1, 0, c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (-1, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (0, 0, c)",
      "mutated_line": "return (1, 0, c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (1, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (0, 0, c)",
      "mutated_line": "return (0, 1, c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 1, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (0, 0, c)",
      "mutated_line": "return (0, -1, c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, -1, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (0, 0, c)",
      "mutated_line": "return (0, 1, c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 1, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (2, mmm.index(k[0]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (2, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (0, mmm.index(k[0]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (0, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (0, mmm.index(k[0]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (0, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (-1, mmm.index(k[0]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (-1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "a1 = my(k[:index + 1], mmm)",
      "mutated_line": "a1 = my(k[:index - 1], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index - 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "a1 = my(k[:index + 1], mmm)",
      "mutated_line": "a1 = my(k[:index * 1], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index * 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a2 = my(k[index + 1:], mmm)",
      "mutated_line": "a2 = my(k[index - 1:], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index - 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a2 = my(k[index + 1:], mmm)",
      "mutated_line": "a2 = my(k[index * 1:], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index * 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[1] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[1] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[-1] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[-1] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[1] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[1] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[1] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[1] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[-1] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[-1] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if a1[0] == 1 and a2[0] == 1:",
      "mutated_line": "if a1[0] == 1 and a2[1] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[1] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "u += 1",
      "mutated_line": "u += 2",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 2\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "u += 1",
      "mutated_line": "u += 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 0\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "u += 1",
      "mutated_line": "u += 0",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 0\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "u += 1",
      "mutated_line": "u += -1",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += -1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] - a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] - a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] * a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] * a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[2] + u / u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u / u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[2] + (u + u))",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + (u + u))\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[2] + u ** u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u ** u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 2 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 2 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 0 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 0 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 0 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 0 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == -1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == -1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 1:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[0] == -1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == -1:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 1:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (2, a1[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (2, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (0, a1[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (0, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (0, a1[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (0, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (-1, a1[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (-1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] - a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] - a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] * a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] * a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] != 0 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] != 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[0] != 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] != 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) / 2 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) / 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) * 2 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) * 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (1, mmm.index(k[1]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[1]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (1, mmm.index(k[-1]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[-1]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (1, mmm.index(k[0]), 0)",
      "mutated_line": "return (1, mmm.index(k[1]), 0)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[1]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "a1 = my(k[:index + 1], mmm)",
      "mutated_line": "a1 = my(k[:index + 2], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 2], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "a1 = my(k[:index + 1], mmm)",
      "mutated_line": "a1 = my(k[:index + 0], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 0], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "a1 = my(k[:index + 1], mmm)",
      "mutated_line": "a1 = my(k[:index + 0], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 0], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "a1 = my(k[:index + 1], mmm)",
      "mutated_line": "a1 = my(k[:index + -1], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + -1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a2 = my(k[index + 1:], mmm)",
      "mutated_line": "a2 = my(k[index + 2:], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 2:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a2 = my(k[index + 1:], mmm)",
      "mutated_line": "a2 = my(k[index + 0:], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 0:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a2 = my(k[index + 1:], mmm)",
      "mutated_line": "a2 = my(k[index + 0:], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 0:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a2 = my(k[index + 1:], mmm)",
      "mutated_line": "a2 = my(k[index + -1:], mmm)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + -1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[1] == 1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[1] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[-1] == 1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[-1] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[1] == 1 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[1] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[1] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[1] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[-1] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[-1] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "elif a1[0] == 1 and a2[0] == 0:",
      "mutated_line": "elif a1[0] == 1 and a2[1] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[1] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[2], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[2], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[0], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[0], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[0], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[0], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[-1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[-1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 1 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == -1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == -1 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 1 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 1 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[0] == 2:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 2:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 0:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[0] == 0:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 0:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[0] == -1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == -1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (2, a2[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (2, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (0, a2[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (0, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (0, a2[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (0, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (-1, a2[1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (-1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] - a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] - a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] * a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] * a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (1, 0, a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (1, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (-1, 0, a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (-1, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (1, 0, a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (1, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 1, a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 1, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, -1, a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, -1, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 1, a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 1, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] - a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] - a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] * a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] * a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(min(len(k[i]), len(k[i + 1]))):",
      "mutated_line": "for j in range(min(len(k[i]), len(k[i - 1]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i - 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(min(len(k[i]), len(k[i + 1]))):",
      "mutated_line": "for j in range(min(len(k[i]), len(k[i * 1]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i * 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] == k[i - 1][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i - 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] == k[i * 1][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i * 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 3 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 3 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 1 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 1 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 0 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 0 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 1 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 1 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // -2 * len(k[0]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // -2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[1]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[1]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[-1]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[-1]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[0]) * len(k[1]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[1]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (1, mmm.index(k[1]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[1]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (1, mmm.index(k[-1]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[-1]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (1, mmm.index(k[0]), c)",
      "mutated_line": "return (1, mmm.index(k[1]), c)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[1]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[3] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[3] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[1] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[1] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[0] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[0] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[1] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[1] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[-2] + a2[2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[-2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[3] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[3] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[1] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[1] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[0] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[0] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[1] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[1] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return (0, 0, a1[2] + a2[2] + u * u)",
      "mutated_line": "return (0, 0, a1[2] + a2[-2] + u * u)",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[-2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[3] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[3] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[1] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[1] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[0] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[0] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[1] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[1] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[-2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[-2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] + a2[3])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[3])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] + a2[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[1])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] + a2[0])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[0])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] + a2[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[1])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "return (1, a1[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a1[1], a1[2] + a2[-2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[-2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[1] == 0 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[1] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[-1] == 0 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[-1] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[1] == 0 and a2[0] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[1] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[1] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[1] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[-1] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[-1] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "elif a1[0] == 0 and a2[0] == 1:",
      "mutated_line": "elif a1[0] == 0 and a2[1] == 1:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[1] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[2], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[2], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[0], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[0], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[0], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[0], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[-1], a1[2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[-1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(min(len(k[i]), len(k[i + 1]))):",
      "mutated_line": "for j in range(min(len(k[i]), len(k[i + 2]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 2]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(min(len(k[i]), len(k[i + 1]))):",
      "mutated_line": "for j in range(min(len(k[i]), len(k[i + 0]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 0]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(min(len(k[i]), len(k[i + 1]))):",
      "mutated_line": "for j in range(min(len(k[i]), len(k[i + 0]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 0]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(min(len(k[i]), len(k[i + 1]))):",
      "mutated_line": "for j in range(min(len(k[i]), len(k[i + -1]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + -1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] == k[i + 2][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 2][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] == k[i + 0][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 0][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] == k[i + 0][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 0][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if k[i][j] == k[i + 1][j]:",
      "mutated_line": "if k[i][j] == k[i + -1][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + -1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[1]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[1]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[-1]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[-1]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "c = len(k) // 2 * len(k[0]) * len(k[0]) // 4",
      "mutated_line": "c = len(k) // 2 * len(k[1]) * len(k[0]) // 4",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[1]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[2]]), len(mmm[a2[1]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[2]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[0]]), len(mmm[a2[1]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[0]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[0]]), len(mmm[a2[1]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[0]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[-1]]), len(mmm[a2[1]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[-1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[2]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[2]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[0]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[0]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[0]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[0]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):",
      "mutated_line": "for j in range(min(len(mmm[a1[1]]), len(mmm[a2[-1]]))):",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[-1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[2]][j] == mmm[a2[1]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[2]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[0]][j] == mmm[a2[1]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[0]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[0]][j] == mmm[a2[1]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[0]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[-1]][j] == mmm[a2[1]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[-1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[1]][j] == mmm[a2[2]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[2]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[1]][j] == mmm[a2[0]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[0]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[1]][j] == mmm[a2[0]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[0]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if mmm[a1[1]][j] == mmm[a2[1]][j]:",
      "mutated_line": "if mmm[a1[1]][j] == mmm[a2[-1]][j]:",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[-1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[3] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[3] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[1] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[1] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[0] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[0] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[1] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[1] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[-2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[-2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] + a2[3])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[3])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] + a2[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[1])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] + a2[0])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[0])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] + a2[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[1])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return (1, a2[1], a1[2] + a2[2])",
      "mutated_line": "return (1, a2[1], a1[2] + a2[-2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[-2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[3] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[3] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[1] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[1] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[0] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[0] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[1] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[1] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[-2] + a2[2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[-2] + a2[2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] + a2[3])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[3])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] + a2[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[1])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] + a2[0])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[0])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] + a2[1])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[1])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return (0, 0, a1[2] + a2[2])",
      "mutated_line": "return (0, 0, a1[2] + a2[-2])",
      "code": "def calculate_max_verse_beauty(test_cases):\n\n    def change(u):\n        i = 0\n        N = len(u)\n        v = u[::-1]\n        new = ''\n        for i in range(N):\n            new += u[i] + v[i]\n        return new\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[-2])\n    results = []\n    for words in test_cases:\n        k = [change(word) for word in words]\n        k.sort()\n        mmm = k[:]\n        a = my(k, mmm)\n        results.append(a[2])\n    return results"
    }
  ]
}