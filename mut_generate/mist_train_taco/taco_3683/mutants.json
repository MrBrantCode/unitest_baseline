{
  "task_id": "taco_3683",
  "entry_point": "max_probability_path",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0.0",
      "mutated_line": "return 1.0",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 1.0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0.0",
      "mutated_line": "return -1.0",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return -1.0"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0.0",
      "mutated_line": "return 1",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if u == end:",
      "mutated_line": "if u != end:",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u != end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "frontier = [(-1, start)]",
      "mutated_line": "frontier = [(+1, start)]",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(+1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "return -neg_path_prob",
      "mutated_line": "return +neg_path_prob",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return +neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if v not in seen:",
      "mutated_line": "if v in seen:",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "frontier = [(-1, start)]",
      "mutated_line": "frontier = [(-2, start)]",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-2, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "frontier = [(-1, start)]",
      "mutated_line": "frontier = [(-0, start)]",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-0, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "frontier = [(-1, start)]",
      "mutated_line": "frontier = [(-0, start)]",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-0, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "frontier = [(-1, start)]",
      "mutated_line": "frontier = [(--1, start)]",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(--1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob * edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(frontier, (neg_path_prob * edge_prob, v))",
      "mutated_line": "heapq.heappush(frontier, (neg_path_prob / edge_prob, v))",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob / edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(frontier, (neg_path_prob * edge_prob, v))",
      "mutated_line": "heapq.heappush(frontier, (neg_path_prob + edge_prob, v))",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob + edge_prob, v))\n    return 0.0"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "heapq.heappush(frontier, (neg_path_prob * edge_prob, v))",
      "mutated_line": "heapq.heappush(frontier, (neg_path_prob ** edge_prob, v))",
      "code": "import heapq\nfrom typing import List\n\ndef max_probability_path(n: int, edges: List[List[int]], succProb: List[float], start: int, end: int) -> float:\n    graph = {u: {} for u in range(n)}\n    for ((u, v), prob) in zip(edges, succProb):\n        graph[u][v] = prob\n        graph[v][u] = prob\n    frontier = [(-1, start)]\n    seen = set()\n    while frontier:\n        (neg_path_prob, u) = heapq.heappop(frontier)\n        if u == end:\n            return -neg_path_prob\n        seen.add(u)\n        for (v, edge_prob) in graph[u].items():\n            if v not in seen:\n                heapq.heappush(frontier, (neg_path_prob ** edge_prob, v))\n    return 0.0"
    }
  ]
}