{
  "task_id": "taco_15951",
  "entry_point": "minimum_amount",
  "mutant_count": 88,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "cur_cap += max_neigh_cap * neighbours",
      "mutated_line": "cur_cap -= max_neigh_cap * neighbours",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap -= max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] / (N + 1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] / (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] + (N + 1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] + (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] ** (N + 1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] ** (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res >= 10 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res >= 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res <= 10 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res <= 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res != 10 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res != 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "visited[cur_node] = True",
      "mutated_line": "visited[cur_node] = False",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = False\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_neigh_cap = 0",
      "mutated_line": "max_neigh_cap = 1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 1\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_neigh_cap = 0",
      "mutated_line": "max_neigh_cap = -1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = -1\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "max_neigh_cap = 0",
      "mutated_line": "max_neigh_cap = 1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 1\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "neighbours = 0",
      "mutated_line": "neighbours = 1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 1\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "neighbours = 0",
      "mutated_line": "neighbours = -1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = -1\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "neighbours = 0",
      "mutated_line": "neighbours = 1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 1\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "neighbours += 1",
      "mutated_line": "neighbours -= 1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours -= 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_cap += max_neigh_cap * neighbours",
      "mutated_line": "cur_cap += max_neigh_cap / neighbours",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap / neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_cap += max_neigh_cap * neighbours",
      "mutated_line": "cur_cap += max_neigh_cap + neighbours",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap + neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "cur_cap += max_neigh_cap * neighbours",
      "mutated_line": "cur_cap += max_neigh_cap ** neighbours",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap ** neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N - 1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N - 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N * 1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N * 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(2, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(0, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(0, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(-1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N - 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N * 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 * 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 * 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 + 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 + 18:\n        return -1\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return +1\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return +1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cur_cap = cap[cur_node - 1]",
      "mutated_line": "cur_cap = cap[cur_node + 1]",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node + 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "cur_cap = cap[cur_node - 1]",
      "mutated_line": "cur_cap = cap[cur_node * 1]",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node * 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if neigh_cap == -1:",
      "mutated_line": "if neigh_cap != -1:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap != -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "neighbours += 1",
      "mutated_line": "neighbours += 2",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 2\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "neighbours += 1",
      "mutated_line": "neighbours += 0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 0\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "neighbours += 1",
      "mutated_line": "neighbours += 0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 0\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "neighbours += 1",
      "mutated_line": "neighbours += -1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += -1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [True] * (N + 1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [True] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 2)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 2)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 0)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 0)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + 0)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 0)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "visited = [False] * (N + 1)",
      "mutated_line": "visited = [False] * (N + -1)",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + -1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 2):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 0):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 0):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + -1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return +1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 11 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 11 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 9 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 9 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 0 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 0 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 1 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 1 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > -10 ** 18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > -10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 ** 19:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 19:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 ** 17:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 17:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 ** 0:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 0:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 ** 1:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 1:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if res > 10 ** 18:",
      "mutated_line": "if res > 10 ** -18:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** -18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -2\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -0\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -0\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return --1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -2\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -0\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -0\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return --1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_cap = cap[cur_node - 1]",
      "mutated_line": "cur_cap = cap[cur_node - 2]",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 2]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_cap = cap[cur_node - 1]",
      "mutated_line": "cur_cap = cap[cur_node - 0]",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 0]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_cap = cap[cur_node - 1]",
      "mutated_line": "cur_cap = cap[cur_node - 0]",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 0]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "cur_cap = cap[cur_node - 1]",
      "mutated_line": "cur_cap = cap[cur_node - -1]",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - -1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "if neigh_cap == -1:",
      "mutated_line": "if neigh_cap == +1:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == +1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(2, N + 1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(2, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(0, N + 1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(0, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(0, N + 1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(0, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(-1, N + 1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(-1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(1, N - 1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N - 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(1, N * 1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N * 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -2\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -0\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -0\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return --1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if neigh_cap == -1:",
      "mutated_line": "if neigh_cap == -2:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -2:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if neigh_cap == -1:",
      "mutated_line": "if neigh_cap == -0:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -0:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if neigh_cap == -1:",
      "mutated_line": "if neigh_cap == -0:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -0:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "if neigh_cap == -1:",
      "mutated_line": "if neigh_cap == --1:",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == --1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(1, N + 2)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 2)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(1, N + 0)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 0)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(1, N + 0)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + 0)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "graph = {i: [] for i in range(1, N + 1)}",
      "mutated_line": "graph = {i: [] for i in range(1, N + -1)}",
      "code": "def minimum_amount(N, S, Edges, Cap):\n\n    def recur(graph, visited, cur_node, cap):\n        if visited[cur_node]:\n            return -1\n        visited[cur_node] = True\n        cur_cap = cap[cur_node - 1]\n        max_neigh_cap = 0\n        neighbours = 0\n        for neigh_node in graph[cur_node]:\n            neigh_cap = recur(graph, visited, neigh_node, cap)\n            if neigh_cap == -1:\n                continue\n            max_neigh_cap = max(max_neigh_cap, neigh_cap)\n            neighbours += 1\n        cur_cap += max_neigh_cap * neighbours\n        return cur_cap\n    graph = {i: [] for i in range(1, N + -1)}\n    for (n1, n2) in Edges:\n        graph[n1].append(n2)\n        graph[n2].append(n1)\n    visited = [False] * (N + 1)\n    res = recur(graph, visited, S, Cap)\n    for i in range(1, N + 1):\n        if not visited[i]:\n            return -1\n    if res > 10 ** 18:\n        return -1\n    return res"
    }
  ]
}