{
  "task_id": "taco_19332",
  "entry_point": "minimum_shopping_time",
  "mutant_count": 113,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "costs = get_cost(vertexhas, edges, k, 0)",
      "mutated_line": "costs = get_cost(vertexhas, edges, k, 1)",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 1)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "costs = get_cost(vertexhas, edges, k, 0)",
      "mutated_line": "costs = get_cost(vertexhas, edges, k, -1)",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, -1)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "costs = get_cost(vertexhas, edges, k, 0)",
      "mutated_line": "costs = get_cost(vertexhas, edges, k, 1)",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 1)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] / 2 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] / 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] + 2 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] + 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] ** 2 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] ** 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) + 1, -1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) + 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) * 1, -1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) * 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, +1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, +1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -1, +1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, +1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j = 1",
      "mutated_line": "j = 2",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 2\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 0\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j = 1",
      "mutated_line": "j = 0",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 0\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "j = 1",
      "mutated_line": "j = -1",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = -1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j <= i:",
      "mutated_line": "while j < i:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j < i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j <= i:",
      "mutated_line": "while j > i:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j > i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "while j <= i:",
      "mutated_line": "while j == i:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j == i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "return best_cost(costs[-1])",
      "mutated_line": "return best_cost(costs[+1])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[+1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * (2 * setsize) for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * (2 * setsize) for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * (2 + setsize) for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * (2 + setsize) for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(heapset[vertexhas[source]], (0, source))",
      "mutated_line": "heappush(heapset[vertexhas[source]], (1, source))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (1, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(heapset[vertexhas[source]], (0, source))",
      "mutated_line": "heappush(heapset[vertexhas[source]], (-1, source))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (-1, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "heappush(heapset[vertexhas[source]], (0, source))",
      "mutated_line": "heappush(heapset[vertexhas[source]], (1, source))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (1, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if cost < oldcost:",
      "mutated_line": "if cost <= oldcost:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost <= oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if cost < oldcost:",
      "mutated_line": "if cost >= oldcost:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost >= oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if cost < oldcost:",
      "mutated_line": "if cost != oldcost:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost != oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 2, -1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 2, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 0, -1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 0, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 0, -1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 0, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - -1, -1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - -1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -2, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -2, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -0, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -0, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -0, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -0, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, --1, -1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, --1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -1, -2):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -2):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -1, -0):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -0):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -1, -0):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -0):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(len(costs) - 1, -1, -1):",
      "mutated_line": "for i in range(len(costs) - 1, -1, --1):",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, --1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if j & i:",
      "mutated_line": "if j | i:",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j | i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j <<= 1",
      "mutated_line": "j <<= 2",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 2\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j <<= 1",
      "mutated_line": "j <<= 0",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 0\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j <<= 1",
      "mutated_line": "j <<= 0",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 0\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "j <<= 1",
      "mutated_line": "j <<= -1",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= -1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return best_cost(costs[-1])",
      "mutated_line": "return best_cost(costs[-2])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return best_cost(costs[-1])",
      "mutated_line": "return best_cost(costs[-0])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return best_cost(costs[-1])",
      "mutated_line": "return best_cost(costs[-0])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return best_cost(costs[-1])",
      "mutated_line": "return best_cost(costs[--1])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[--1])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 1].append((b + 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b + 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 1].append((b * 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b * 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 1].append((a + 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a + 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 1].append((a * 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a * 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * 3 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 3 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * 1 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 1 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * 0 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 0 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * 1 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 1 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('Inf')] * -2 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * -2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(2 * setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 * setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(2 + setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 + setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a + 1].append((b - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a + 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a * 1].append((b - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a * 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 1].append((b - 2, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 2, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 1].append((b - 0, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 0, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 1].append((b - 0, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 0, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 1].append((b - -1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - -1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b + 1].append((a - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b + 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b * 1].append((a - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b * 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 1].append((a - 2, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 2, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 1].append((a - 0, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 0, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 1].append((a - 0, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 0, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 1].append((a - -1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - -1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]",
      "mutated_line": "costs = [[float('')] * 2 ** setsize for _ in vertexhas]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(3 ** setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(3 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(1 ** setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(1 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(0 ** setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(0 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(1 ** setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(1 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "heapset = [[] for _ in range(2 ** setsize)]",
      "mutated_line": "heapset = [[] for _ in range(-2 ** setsize)]",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(-2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "costs[i - j] = min(costs[i - j], costs[i])",
      "mutated_line": "costs[i + j] = min(costs[i - j], costs[i])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i + j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "costs[i - j] = min(costs[i - j], costs[i])",
      "mutated_line": "costs[i * j] = min(costs[i - j], costs[i])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i * j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) / 2)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) / 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) * 2)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) * 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elts = list(map(int, center.split()[1:]))",
      "mutated_line": "elts = list(map(int, center.split()[2:]))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[2:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elts = list(map(int, center.split()[1:]))",
      "mutated_line": "elts = list(map(int, center.split()[0:]))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[0:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elts = list(map(int, center.split()[1:]))",
      "mutated_line": "elts = list(map(int, center.split()[0:]))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[0:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "elts = list(map(int, center.split()[1:]))",
      "mutated_line": "elts = list(map(int, center.split()[-1:]))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[-1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((2 << elt - 1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((2 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((0 << elt - 1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((0 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((0 << elt - 1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((0 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((-1 << elt - 1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((-1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((1 << elt + 1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt + 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((1 << elt * 1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt * 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 2].append((b - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 2].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 0].append((b - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 0].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - 0].append((b - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 0].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "edges[a - 1].append((b - 1, cost))",
      "mutated_line": "edges[a - -1].append((b - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - -1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 2].append((a - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 2].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 0].append((a - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 0].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - 0].append((a - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 0].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "edges[b - 1].append((a - 1, cost))",
      "mutated_line": "edges[b - -1].append((a - 1, cost))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - -1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "costs[i - j] = min(costs[i - j], costs[i])",
      "mutated_line": "costs[i - j] = min(costs[i + j], costs[i])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i + j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "costs[i - j] = min(costs[i - j], costs[i])",
      "mutated_line": "costs[i - j] = min(costs[i * j], costs[i])",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i * j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 3)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 3)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 1)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 1)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 0)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 0)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 1)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 1)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))",
      "mutated_line": "return min((max(costs[i], costs[~i]) for i in range(len(costs) // -2)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // -2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((1 << elt - 2 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 2 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((1 << elt - 0 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 0 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((1 << elt - 0 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 0 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "vertexhas.append(sum((1 << elt - 1 for elt in elts)))",
      "mutated_line": "vertexhas.append(sum((1 << elt - -1 for elt in elts)))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - -1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))",
      "mutated_line": "heappush(heapset[curset & vertexhas[newvert]], (cost + newcost, newvert))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset & vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))",
      "mutated_line": "heappush(heapset[curset ^ vertexhas[newvert]], (cost + newcost, newvert))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset ^ vertexhas[newvert]], (cost + newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))",
      "mutated_line": "heappush(heapset[curset | vertexhas[newvert]], (cost - newcost, newvert))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost - newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "heappush(heapset[curset | vertexhas[newvert]], (cost + newcost, newvert))",
      "mutated_line": "heappush(heapset[curset | vertexhas[newvert]], (cost * newcost, newvert))",
      "code": "from heapq import *\n\ndef minimum_shopping_time(n, k, centers, roads):\n\n    def get_edges(edgelist, nvert):\n        edges = [[] for _ in range(nvert)]\n        for (a, b, cost) in edgelist:\n            edges[a - 1].append((b - 1, cost))\n            edges[b - 1].append((a - 1, cost))\n        return edges\n\n    def get_cost(vertexhas, edges, setsize, source):\n        costs = [[float('Inf')] * 2 ** setsize for _ in vertexhas]\n        heapset = [[] for _ in range(2 ** setsize)]\n        heappush(heapset[vertexhas[source]], (0, source))\n        for (curset, heap) in enumerate(heapset):\n            while heap:\n                (cost, vert) = heappop(heap)\n                oldcost = costs[vert][curset]\n                if cost < oldcost:\n                    costs[vert][curset] = cost\n                    for (newvert, newcost) in edges[vert]:\n                        heappush(heapset[curset | vertexhas[newvert]], (cost * newcost, newvert))\n        return costs\n\n    def best_cost(costs):\n        costs = list(costs)\n        for i in range(len(costs) - 1, -1, -1):\n            j = 1\n            while j <= i:\n                if j & i:\n                    costs[i - j] = min(costs[i - j], costs[i])\n                j <<= 1\n        return min((max(costs[i], costs[~i]) for i in range(len(costs) // 2)))\n    vertexhas = []\n    for center in centers:\n        elts = list(map(int, center.split()[1:]))\n        vertexhas.append(sum((1 << elt - 1 for elt in elts)))\n    edges = get_edges(roads, n)\n    costs = get_cost(vertexhas, edges, k, 0)\n    return best_cost(costs[-1])"
    }
  ]
}