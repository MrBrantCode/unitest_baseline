{
  "task_id": "taco_14339",
  "entry_point": "get_all",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "all += all_1",
      "mutated_line": "all -= all_1",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall -= all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 -= [int(f'{x}' * length) for x in range(1, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 -= [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "def get_all(length, digits, so_far=0):",
      "mutated_line": "def get_all(length, digits, so_far=1):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=1):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "def get_all(length, digits, so_far=0):",
      "mutated_line": "def get_all(length, digits, so_far=-1):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=-1):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "def get_all(length, digits, so_far=0):",
      "mutated_line": "def get_all(length, digits, so_far=1):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=1):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if length == 0:",
      "mutated_line": "if length != 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length != 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret -= get_all(length - 1, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret -= get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(2, 11):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(2, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(0, 11):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(0, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(0, 11):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(0, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(-1, 11):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(-1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(1, 12):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 12):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(1, 10):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 10):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(1, 0):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 0):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(1, 1):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 1):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for length in range(1, 11):",
      "mutated_line": "for length in range(1, -11):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, -11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "all += get_all(length, p)",
      "mutated_line": "all -= get_all(length, p)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all -= get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if k == 1:",
      "mutated_line": "if k != 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k != 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length == 0:",
      "mutated_line": "if length == 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 1:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length == 0:",
      "mutated_line": "if length == -1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == -1:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if length == 0:",
      "mutated_line": "if length == 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 1:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 0 or d == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 or d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in combinations(digits, 2):",
      "mutated_line": "for p in combinations(digits, 3):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 3):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in combinations(digits, 2):",
      "mutated_line": "for p in combinations(digits, 1):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 1):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in combinations(digits, 2):",
      "mutated_line": "for p in combinations(digits, 0):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 0):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in combinations(digits, 2):",
      "mutated_line": "for p in combinations(digits, 1):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 1):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for p in combinations(digits, 2):",
      "mutated_line": "for p in combinations(digits, -2):",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, -2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 2:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 2:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 0:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k == 1:",
      "mutated_line": "if k == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 0:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if k == 1:",
      "mutated_line": "if k == -1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == -1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif k == 2:",
      "mutated_line": "elif k != 2:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k != 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "digits = [i for i in range(10)]",
      "mutated_line": "digits = [i for i in range(11)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(11)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "digits = [i for i in range(10)]",
      "mutated_line": "digits = [i for i in range(9)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(9)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "digits = [i for i in range(10)]",
      "mutated_line": "digits = [i for i in range(0)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(0)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "digits = [i for i in range(10)]",
      "mutated_line": "digits = [i for i in range(1)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(1)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "digits = [i for i in range(10)]",
      "mutated_line": "digits = [i for i in range(-10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(-10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far != 0 and d == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far != 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 0 and d != 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d != 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length + 1, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length + 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length * 1, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length * 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * 10 - d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 - d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * 10 * d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 * d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' / length) for x in range(1, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' / length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' + length) for x in range(1, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' + length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' ** length) for x in range(1, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' ** length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif k == 2:",
      "mutated_line": "elif k == 3:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 3:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif k == 2:",
      "mutated_line": "elif k == 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 1:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif k == 2:",
      "mutated_line": "elif k == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 0:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif k == 2:",
      "mutated_line": "elif k == 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 1:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif k == 2:",
      "mutated_line": "elif k == -2:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == -2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 1 and d == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 1 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == -1 and d == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == -1 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 1 and d == 0:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 1 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 0 and d == 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 1:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 0 and d == -1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == -1:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if so_far == 0 and d == 0:",
      "mutated_line": "if so_far == 0 and d == 1:",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 1:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 2, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 2, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 0, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 0, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 0, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 0, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - -1, digits, so_far * 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - -1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far / 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far / 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far + 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far + 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far ** 10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far ** 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(2, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(2, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(0, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(0, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(0, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(0, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(-1, 10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(-1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(1, 11)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 11)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(1, 9)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 9)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(1, 0)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 0)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(1, 1)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 1)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "all_1 += [int(f'{x}' * length) for x in range(1, 10)]",
      "mutated_line": "all_1 += [int(f'{x}' * length) for x in range(1, -10)]",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, -10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "raise ValueError(\"k must be 1 or 2\")",
      "mutated_line": "raise ValueError('')",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * 11 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 11 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * 9 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 9 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * 0 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 0 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * 1 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * 1 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ret += get_all(length - 1, digits, so_far * 10 + d)",
      "mutated_line": "ret += get_all(length - 1, digits, so_far * -10 + d)",
      "code": "from itertools import combinations\nfrom bisect import bisect_left\ndigits = [i for i in range(10)]\n\ndef get_all(length, digits, so_far=0):\n    if length == 0:\n        return [so_far]\n    ret = []\n    for d in digits:\n        if so_far == 0 and d == 0:\n            continue\n        ret += get_all(length - 1, digits, so_far * -10 + d)\n    return ret\nall = []\nall_1 = []\nfor length in range(1, 11):\n    all_1 += [int(f'{x}' * length) for x in range(1, 10)]\n    for p in combinations(digits, 2):\n        p = list(p)\n        all += get_all(length, p)\nall_1.sort()\nall += all_1\nall.sort()\n\ndef find_min_k_beautiful_number(n, k):\n    if k == 1:\n        return all_1[bisect_left(all_1, n)]\n    elif k == 2:\n        return all[bisect_left(all, n)]\n    else:\n        raise ValueError('k must be 1 or 2')"
    }
  ]
}