{
  "task_id": "taco_10498",
  "entry_point": "calculate_connected_graph_probability",
  "mutant_count": 177,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bc = [0] * N1",
      "mutated_line": "bc = [0] / N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] / N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bc = [0] * N1",
      "mutated_line": "bc = [0] + N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] + N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "bc = [0] * N1",
      "mutated_line": "bc = [0] ** N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] ** N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ec = [0] * N1",
      "mutated_line": "ec = [0] / N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] / N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ec = [0] * N1",
      "mutated_line": "ec = [0] + N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] + N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ec = [0] * N1",
      "mutated_line": "ec = [0] ** N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] ** N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [0] * N1",
      "mutated_line": "dp = [0] / N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] / N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [0] * N1",
      "mutated_line": "dp = [0] + N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] + N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dp = [0] * N1",
      "mutated_line": "dp = [0] ** N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] ** N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = 2",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 2\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 0\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 0\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[1] = -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = -1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "N1 = 1 << N",
      "mutated_line": "N1 = 2 << N",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 2 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "N1 = 1 << N",
      "mutated_line": "N1 = 0 << N",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 0 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "N1 = 1 << N",
      "mutated_line": "N1 = 0 << N",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 0 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "N1 = 1 << N",
      "mutated_line": "N1 = -1 << N",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = -1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N1):",
      "mutated_line": "for i in range(2, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(2, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N1):",
      "mutated_line": "for i in range(0, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(0, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N1):",
      "mutated_line": "for i in range(0, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(0, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(1, N1):",
      "mutated_line": "for i in range(-1, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(-1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & -i] - 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] - 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & -i] * 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] * 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for state in range(1, N1):",
      "mutated_line": "for state in range(2, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(2, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for state in range(1, N1):",
      "mutated_line": "for state in range(0, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(0, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for state in range(1, N1):",
      "mutated_line": "for state in range(0, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(0, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for state in range(1, N1):",
      "mutated_line": "for state in range(-1, N1):",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(-1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 1\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = -1\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 1\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 2 << N - 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 2 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 0 << N - 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 0 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 0 << N - 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 0 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = -1 << N - 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = -1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 1 << N + 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N + 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 1 << N * 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N * 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[2] = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[2] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[0] = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[0] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[0] = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[0] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dp[1] = 1",
      "mutated_line": "dp[-1] = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[-1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for s0 in range(1, N0):",
      "mutated_line": "state0 = s0 << 1 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(2, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for s0 in range(1, N0):",
      "mutated_line": "state0 = s0 << 1 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(0, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for s0 in range(1, N0):",
      "mutated_line": "state0 = s0 << 1 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(0, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for s0 in range(1, N0):",
      "mutated_line": "state0 = s0 << 1 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(-1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 1 & 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 & 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 1 ^ 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 ^ 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 - 1 | state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 | state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 1\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v = 0",
      "mutated_line": "v = -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = -1\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 1\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[state0] = 1 - v",
      "mutated_line": "dp[state0] = 1 + v",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 + v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "dp[state0] = 1 - v",
      "mutated_line": "dp[state0] = 1 * v",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 * v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return dp[N1 - 1]",
      "mutated_line": "return dp[N1 + 1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 + 1]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "return dp[N1 - 1]",
      "mutated_line": "return dp[N1 * 1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 * 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v + 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v + 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v * 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v * 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u + 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u + 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u * 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u * 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bc = [0] * N1",
      "mutated_line": "bc = [1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [1] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bc = [0] * N1",
      "mutated_line": "bc = [-1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [-1] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "bc = [0] * N1",
      "mutated_line": "bc = [1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [1] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & -i] + 2",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 2\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & -i] + 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 0\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & -i] + 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 0\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & -i] + -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + -1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ec = [0] * N1",
      "mutated_line": "ec = [1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [1] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ec = [0] * N1",
      "mutated_line": "ec = [-1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [-1] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ec = [0] * N1",
      "mutated_line": "ec = [1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [1] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 1 << v != 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v != 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "c += 1",
      "mutated_line": "c -= 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c -= 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ec[state] = c >> 1",
      "mutated_line": "ec[state] = c >> 2",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 2\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ec[state] = c >> 1",
      "mutated_line": "ec[state] = c >> 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 0\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ec[state] = c >> 1",
      "mutated_line": "ec[state] = c >> 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 0\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ec[state] = c >> 1",
      "mutated_line": "ec[state] = c >> -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> -1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 1 << N - 2",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 2\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 1 << N - 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 0\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 1 << N - 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 0\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "N0 = 1 << (N - 1)",
      "mutated_line": "N0 = 1 << N - -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - -1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [0] * N1",
      "mutated_line": "dp = [1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [1] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [0] * N1",
      "mutated_line": "dp = [-1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [-1] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dp = [0] * N1",
      "mutated_line": "dp = [1] * N1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [1] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 1 | 2",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 2\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 1 | 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 0\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 1 | 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 0\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 1 | -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | -1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 + 1 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 + 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 * 1 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 * 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "if state1 & 1:",
      "mutated_line": "if state1 | 1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 | 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v -= dp[state1] * (P / 100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v -= dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 - 1 | state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 | state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[state0] = 1 - v",
      "mutated_line": "dp[state0] = 2 - v",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 2 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[state0] = 1 - v",
      "mutated_line": "dp[state0] = 0 - v",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 0 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[state0] = 1 - v",
      "mutated_line": "dp[state0] = 0 - v",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 0 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[state0] = 1 - v",
      "mutated_line": "dp[state0] = -1 - v",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = -1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[N1 - 1]",
      "mutated_line": "return dp[N1 - 2]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 2]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[N1 - 1]",
      "mutated_line": "return dp[N1 - 0]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[N1 - 1]",
      "mutated_line": "return dp[N1 - 0]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[N1 - 1]",
      "mutated_line": "return dp[N1 - -1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - -1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 2)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 2)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 0)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 1].append(v - -1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - -1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 2)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 2)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 0)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 1].append(u - -1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - -1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i | i & -i] + 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i | i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state | 1 << v == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state | 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 1 << v == 1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 1:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 1 << v == -1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == -1:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 1 << v == 1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 1:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 1 << w != 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w != 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c += 1",
      "mutated_line": "c += 2",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 2\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 0\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c += 1",
      "mutated_line": "c += 0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 0\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "c += 1",
      "mutated_line": "c += -1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += -1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 2 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 2 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 0 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 0 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << 0 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 0 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "state0 = (s0 << 1) | 1",
      "mutated_line": "state0 = s0 << -1 | 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << -1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 - 2 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 2 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 - 0 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 0 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 - 0 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 0 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "state1 = state0 - 1 & state0",
      "mutated_line": "state1 = state0 - -1 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - -1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if state1 & 1:",
      "mutated_line": "if state1 & 2:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 2:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if state1 & 1:",
      "mutated_line": "if state1 & 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 0:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if state1 & 1:",
      "mutated_line": "if state1 & 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 0:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if state1 & 1:",
      "mutated_line": "if state1 & -1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & -1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = ec[state0] - ec[state1] - ec[state0 ^ state1]",
      "mutated_line": "k = ec[state0] - ec[state1] + ec[state0 ^ state1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] + ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = ec[state0] - ec[state1] - ec[state0 ^ state1]",
      "mutated_line": "k = (ec[state0] - ec[state1]) * ec[state0 ^ state1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = (ec[state0] - ec[state1]) * ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] / (P / 100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] / (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] + (P / 100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] + (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] ** (P / 100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] ** (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 + 1 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 + 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 * 1 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 * 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u + 1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u + 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u * 1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u * 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v + 1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v + 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v * 1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v * 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ (i | -i)] + 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ (i | -i)] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state | 1 << w == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state | 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 1 << w == 1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 1:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 1 << w == -1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == -1:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 1 << w == 1:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 1:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = ec[state0] - ec[state1] - ec[state0 ^ state1]",
      "mutated_line": "k = ec[state0] + ec[state1] - ec[state0 ^ state1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] + ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = ec[state0] - ec[state1] - ec[state0 ^ state1]",
      "mutated_line": "k = ec[state0] * ec[state1] - ec[state0 ^ state1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] * ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / 100 * k)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100 * k)\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / 100 + k)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100 + k)\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 - 2 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 2 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 - 0 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 0 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 - 0 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 0 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "state1 = state1 - 1 & state0",
      "mutated_line": "state1 = state1 - -1 & state0",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - -1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 2].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 2].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 0].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[u - 1].append(v - 1)",
      "mutated_line": "G[u - -1].append(v - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - -1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 2].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 2].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 0].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[v - 1].append(u - 1)",
      "mutated_line": "G[v - -1].append(u - 1)",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - -1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "bc[i] = bc[i ^ (i & -i)] + 1",
      "mutated_line": "bc[i] = bc[i ^ i & +i] + 1",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & +i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 2 << v == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 2 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 0 << v == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 0 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & 0 << v == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 0 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if state & (1 << v) == 0:",
      "mutated_line": "if state & -1 << v == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & -1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "k = ec[state0] - ec[state1] - ec[state0 ^ state1]",
      "mutated_line": "k = ec[state0] - ec[state1] - ec[state0 | state1]",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 | state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P * 100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P * 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P // 100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P // 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 2 << w == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 2 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 0 << w == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 0 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & 0 << w == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 0 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if state & (1 << w) == 0:",
      "mutated_line": "if state & -1 << w == 0:",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & -1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / 101) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 101) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / 99) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 99) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / 0) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 0) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / 1) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / 1) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v += dp[state1] * ((P / 100) ** k)",
      "mutated_line": "v += dp[state1] * (P / -100) ** k",
      "code": "from collections import deque\n\ndef calculate_connected_graph_probability(N, M, P, edges):\n    G = [[] for _ in range(N)]\n    for (u, v) in edges:\n        G[u - 1].append(v - 1)\n        G[v - 1].append(u - 1)\n    N1 = 1 << N\n    bc = [0] * N1\n    for i in range(1, N1):\n        bc[i] = bc[i ^ i & -i] + 1\n    ec = [0] * N1\n    for state in range(1, N1):\n        c = 0\n        for v in range(N):\n            if state & 1 << v == 0:\n                continue\n            for w in G[v]:\n                if state & 1 << w == 0:\n                    continue\n                c += 1\n        ec[state] = c >> 1\n    N0 = 1 << N - 1\n    dp = [0] * N1\n    dp[1] = 1\n    for s0 in range(1, N0):\n        state0 = s0 << 1 | 1\n        state1 = state0 - 1 & state0\n        v = 0\n        while state1:\n            if state1 & 1:\n                k = ec[state0] - ec[state1] - ec[state0 ^ state1]\n                v += dp[state1] * (P / -100) ** k\n            state1 = state1 - 1 & state0\n        dp[state0] = 1 - v\n    return dp[N1 - 1]"
    }
  ]
}