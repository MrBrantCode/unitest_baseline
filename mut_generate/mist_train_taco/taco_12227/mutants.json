{
  "task_id": "taco_12227",
  "entry_point": "is_palindrome_possible",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return s == s[::-1]",
      "mutated_line": "return s != s[::-1]",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s != s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if index == len(s):",
      "mutated_line": "if index != len(s):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index != len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return False",
      "mutated_line": "return backtrack(st, 0, '')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return True\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(st, 0, \"\")",
      "mutated_line": "return backtrack(st, 1, '')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 1, '')"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(st, 0, \"\")",
      "mutated_line": "return backtrack(st, -1, '')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, -1, '')"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(st, 0, \"\")",
      "mutated_line": "return backtrack(st, 1, '')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 1, '')"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return backtrack(st, 0, \"\")",
      "mutated_line": "return backtrack(st, 0, 'MUTATED')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, 'MUTATED')"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if char == 'a':",
      "mutated_line": "if char != 'a':",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char != 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if char == 'a':",
      "mutated_line": "if char == '':",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == '':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif char == 'z':",
      "mutated_line": "elif char != 'z':",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char != 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index - 1, current + trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index - 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index * 1, current + trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index * 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index + 1, current - trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current - trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index + 1, current * trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current * trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return False\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "return s == s[::-1]",
      "mutated_line": "return s == s[::+1]",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::+1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "transformations.append('b')",
      "mutated_line": "transformations.append('')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif char == 'z':",
      "mutated_line": "elif char == '':",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == '':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index + 2, current + trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 2, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index + 0, current + trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 0, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index + 0, current + trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 0, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if backtrack(s, index + 1, current + trans):",
      "mutated_line": "if backtrack(s, index + -1, current + trans):",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + -1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return s == s[::-1]",
      "mutated_line": "return s == s[::-2]",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-2]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return s == s[::-1]",
      "mutated_line": "return s == s[::-0]",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-0]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return s == s[::-1]",
      "mutated_line": "return s == s[::-0]",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-0]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return s == s[::-1]",
      "mutated_line": "return s == s[::--1]",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::--1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "transformations.append('y')",
      "mutated_line": "transformations.append('')",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "transformations.append(chr(ord(char) - 1))",
      "mutated_line": "transformations.append(chr(ord(char) + 1))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) + 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "transformations.append(chr(ord(char) - 1))",
      "mutated_line": "transformations.append(chr(ord(char) * 1))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) * 1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "transformations.append(chr(ord(char) + 1))",
      "mutated_line": "transformations.append(chr(ord(char) - 1))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) - 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "transformations.append(chr(ord(char) + 1))",
      "mutated_line": "transformations.append(chr(ord(char) * 1))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) * 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "transformations.append(chr(ord(char) - 1))",
      "mutated_line": "transformations.append(chr(ord(char) - 2))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 2))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "transformations.append(chr(ord(char) - 1))",
      "mutated_line": "transformations.append(chr(ord(char) - 0))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 0))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "transformations.append(chr(ord(char) - 1))",
      "mutated_line": "transformations.append(chr(ord(char) - 0))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 0))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "transformations.append(chr(ord(char) - 1))",
      "mutated_line": "transformations.append(chr(ord(char) - -1))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - -1))\n                transformations.append(chr(ord(char) + 1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "transformations.append(chr(ord(char) + 1))",
      "mutated_line": "transformations.append(chr(ord(char) + 2))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 2))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "transformations.append(chr(ord(char) + 1))",
      "mutated_line": "transformations.append(chr(ord(char) + 0))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 0))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "transformations.append(chr(ord(char) + 1))",
      "mutated_line": "transformations.append(chr(ord(char) + 0))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + 0))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "transformations.append(chr(ord(char) + 1))",
      "mutated_line": "transformations.append(chr(ord(char) + -1))",
      "code": "def is_palindrome_possible(st: str) -> bool:\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def generate_transformations(s: str) -> list:\n        transformations = []\n        for i in range(len(s)):\n            char = s[i]\n            if char == 'a':\n                transformations.append('b')\n            elif char == 'z':\n                transformations.append('y')\n            else:\n                transformations.append(chr(ord(char) - 1))\n                transformations.append(chr(ord(char) + -1))\n        return transformations\n\n    def backtrack(s: str, index: int, current: str) -> bool:\n        if index == len(s):\n            return is_palindrome(current)\n        original_char = s[index]\n        transformations = generate_transformations(original_char)\n        for trans in transformations:\n            if backtrack(s, index + 1, current + trans):\n                return True\n        return False\n    return backtrack(st, 0, '')"
    }
  ]
}