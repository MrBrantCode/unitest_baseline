{
  "task_id": "taco_1643",
  "entry_point": "count_primes_less_than",
  "mutant_count": 246,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if type(n) is not int:",
      "mutated_line": "if type(n) is int:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n <= 6:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n <= 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n >= 6:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n >= 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n != 6:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n != 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n // root3 - 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 - 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n // root3 * 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 * 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] - [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] - [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] * ([1] * (top - 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] * ([1] * (top - 2))\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 1\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = -1\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 1\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] / ((a + 1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] / ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] + (a + 1) * 800",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] + (a + 1) * 800\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] ** ((a + 1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] ** ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 + sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 + sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return (Phi(n, a) + a - 1) * sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return (Phi(n, a) + a - 1) * sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(1, n - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(1, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(-1, n - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(-1, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(1, n - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(1, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(0, n + 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n + 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(0, n * 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n * 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n < 7:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 7:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n < 5:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 5:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n < 0:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 0:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n < 1:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 1:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if n < 6:",
      "mutated_line": "if n < -6:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < -6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m > 800:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m > 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m < 800:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m < 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m == 800:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m == 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * 800 - m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 - m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * 800 * m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 * m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n * (1.0 / 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n * (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n + 1.0 / 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n + 1.0 / 2)\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n * (1.0 / 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n * (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n + 1.0 / 3)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n + 1.0 / 3)\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n / root3 + 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n / root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n * root3 + 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n * root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n // root3 + 2",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 2\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n // root3 + 0",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 0\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n // root3 + 0",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 0\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "top = n // root3 + 1",
      "mutated_line": "top = n // root3 + -1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + -1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] / (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] / (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + ([1] + (top - 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + ([1] + (top - 2))\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] ** (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] ** (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi = [0, 0]",
      "mutated_line": "pi = [1, 0]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [1, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi = [0, 0]",
      "mutated_line": "pi = [-1, 0]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [-1, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi = [0, 0]",
      "mutated_line": "pi = [1, 0]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [1, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi = [0, 0]",
      "mutated_line": "pi = [0, 1]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 1]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi = [0, 0]",
      "mutated_line": "pi = [0, -1]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, -1]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pi = [0, 0]",
      "mutated_line": "pi = [0, 1]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 1]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(2, top):",
      "mutated_line": "for i in range(3, top):",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(3, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(2, top):",
      "mutated_line": "for i in range(1, top):",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(1, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(2, top):",
      "mutated_line": "for i in range(0, top):",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(0, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(2, top):",
      "mutated_line": "for i in range(1, top):",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(1, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for i in range(2, top):",
      "mutated_line": "for i in range(-2, top):",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(-2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if sieve[i] == 1:",
      "mutated_line": "if sieve[i] != 1:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] != 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "t += 1",
      "mutated_line": "t -= 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t -= 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 1) / 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) / 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * (a + 1 + 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * (a + 1 + 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * (a + 1) ** 800",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * (a + 1) ** 800\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a + 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a + 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return (Phi(n, a) + a) * 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return (Phi(n, a) + a) * 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(0, n - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 2)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(0, n - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 0)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(0, n - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 0)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n = max(0, n - 1)",
      "mutated_line": "n = max(0, n - -1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - -1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 1\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return -1\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 1\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m >= 801:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 801:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m >= 799:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 799:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m >= 0:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 0:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m >= 1:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 1:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if m >= 800:",
      "mutated_line": "if m >= -800:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= -800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) + Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) + Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) * Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) * Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b / 800 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b / 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b + 800 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b + 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b ** 800 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b ** 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) + Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) + Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) * Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) * Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 * 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 * 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 // 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 // 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 * 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 * 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 // 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 // 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [1, 0] + [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [1, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [-1, 0] + [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [-1, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [1, 0] + [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [1, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 1] + [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 1] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, -1] + [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, -1] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 1] + [1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 1] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top + 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top + 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top * 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top * 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if sieve[i] == 1:",
      "mutated_line": "if sieve[i] == 2:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 2:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if sieve[i] == 1:",
      "mutated_line": "if sieve[i] == 0:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 0:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if sieve[i] == 1:",
      "mutated_line": "if sieve[i] == 0:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 0:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if sieve[i] == 1:",
      "mutated_line": "if sieve[i] == -1:",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == -1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "t += 1",
      "mutated_line": "t += 2",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 2\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 0\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 0\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "t += 1",
      "mutated_line": "t += -1",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += -1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sieve[i::i] = [0] * len(sieve[i::i])",
      "mutated_line": "sieve[i::i] = [0] / len(sieve[i::i])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] / len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sieve[i::i] = [0] * len(sieve[i::i])",
      "mutated_line": "sieve[i::i] = [0] + len(sieve[i::i])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] + len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "sieve[i::i] = [0] * len(sieve[i::i])",
      "mutated_line": "sieve[i::i] = [0] ** len(sieve[i::i])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] ** len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 - 1], pi[root2 + 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 - 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 * 1], pi[root2 + 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 * 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 1], pi[root2 - 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 - 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 1], pi[root2 * 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 * 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [1] * ((a + 1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [1] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [-1] * ((a + 1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [-1] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [1] * ((a + 1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [1] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a - 1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a - 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * (a * 1 * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * (a * 1 * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 1) * 801)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 801)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 1) * 799)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 799)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 1) * 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 0)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 1) * 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 1)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 1) * -800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * -800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) - a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) - a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) * a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) * a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 2 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 2 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 0 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 0 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 0 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 0 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - -1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - -1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [1, 0, 1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [1, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [-1, 0, 1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [-1, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [1, 0, 1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [1, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 1, 1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 1, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, -1, 1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, -1, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 1, 1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 1, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 2, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 2, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 0, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 0, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 0, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 0, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, -1, 2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, -1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 3, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 3, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 1, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 1, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 0, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 0, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 1, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 1, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, -2, 2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, -2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 3, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 3, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 1, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 1, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 0, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 0, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 1, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 1, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, -2, 3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, -2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 2, 4][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 4][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 2, 2][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 2][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 2, 0][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 0][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 2, 1][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 1][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return [0, 0, 1, 2, 2, 3][n]",
      "mutated_line": "return [0, 0, 1, 2, 2, -3][n]",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, -3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * 801 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 801 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * 799 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 799 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * 0 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 0 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * 1 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 1 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "t = b * 800 + m",
      "mutated_line": "t = b * -800 + m",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * -800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (2.0 / 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (2.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (0.0 / 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (0.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (0 / 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (-1.0 / 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (-1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 / 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 3))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 / 1))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 1))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 / 0))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 0))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 / 1))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 1))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "root2 = int(n ** (1.0 / 2))",
      "mutated_line": "root2 = int(n ** (1.0 / -2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / -2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (2.0 / 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (2.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (0.0 / 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (0.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (0 / 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (-1.0 / 3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (-1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 / 4))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 4))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 / 2))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 2))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 / 0))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 0))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 / 1))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 1))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "root3 = int(n ** (1.0 / 3))",
      "mutated_line": "root3 = int(n ** (1.0 / -3))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / -3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [2] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [2] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [0] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [0] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [0] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [0] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [-1] * (top - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [-1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top - 3)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 3)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 1)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 0)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 1)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "sieve = [0, 0] + [1] * (top - 2)",
      "mutated_line": "sieve = [0, 0] + [1] * (top - -2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - -2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 2], pi[root2 + 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 2], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 0], pi[root2 + 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 0], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 0], pi[root2 + 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 0], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + -1], pi[root2 + 1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + -1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 1], pi[root2 + 2])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 2])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 1], pi[root2 + 0])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 0])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 1], pi[root2 + 0])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 0])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(a, b) = (pi[root3 + 1], pi[root2 + 1])",
      "mutated_line": "(a, b) = (pi[root3 + 1], pi[root2 + -1])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + -1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 2) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 2) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 0) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 0) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + 0) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 0) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "Phi_memo = [0] * ((a + 1) * 800)",
      "mutated_line": "Phi_memo = [0] * ((a + -1) * 800)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + -1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] - 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] - 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum(((pi[n // p] - pi[p]) * 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum(((pi[n // p] - pi[p]) * 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b + 1) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b + 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b * 1) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b * 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m / primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m / primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m * primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m * primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b + 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b + 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b * 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b * 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b + 1) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b + 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b * 1) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b * 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m / primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m / primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m * primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m * primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b + 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b + 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b * 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b * 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sieve[i::i] = [0] * len(sieve[i::i])",
      "mutated_line": "sieve[i::i] = [1] * len(sieve[i::i])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [1] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sieve[i::i] = [0] * len(sieve[i::i])",
      "mutated_line": "sieve[i::i] = [-1] * len(sieve[i::i])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [-1] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sieve[i::i] = [0] * len(sieve[i::i])",
      "mutated_line": "sieve[i::i] = [1] * len(sieve[i::i])",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [1] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] + pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] + pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] * pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] * pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 2 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 2 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 0 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 0 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 0 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 0 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + -1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + -1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 2) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 2) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - -1) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - -1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 2)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - -1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - -1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 2) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 2) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 0) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - -1) - Phi(m // primes[b - 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - -1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 2)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 2)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 0)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - -1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - -1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b + 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b + 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b * 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b * 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b + 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b + 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b * 1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b * 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n / p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n / p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))",
      "mutated_line": "return Phi(n, a) + a - 1 - sum((pi[n * p] - pi[p] + 1 for p in primes[a:b]))",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n * p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 2], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 2], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "return Phi(m, b - 1) - Phi(m // primes[b - -1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - -1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 2], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 2], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 0], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)",
      "mutated_line": "Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - -1], b - 1)",
      "code": "def count_primes_less_than(n: int) -> int:\n    n = max(0, n - 1)\n    if type(n) is not int:\n        n = int(n)\n    if n < 6:\n        return [0, 0, 1, 2, 2, 3][n]\n\n    def Phi(m, b):\n        if not b:\n            return m\n        if not m:\n            return 0\n        if m >= 800:\n            return Phi(m, b - 1) - Phi(m // primes[b - 1], b - 1)\n        t = b * 800 + m\n        if not Phi_memo[t]:\n            Phi_memo[t] = Phi(m, b - 1) - Phi(m // primes[b - -1], b - 1)\n        return Phi_memo[t]\n    root2 = int(n ** (1.0 / 2))\n    root3 = int(n ** (1.0 / 3))\n    top = n // root3 + 1\n    sieve = [0, 0] + [1] * (top - 2)\n    pi = [0, 0]\n    primes = []\n    t = 0\n    for i in range(2, top):\n        if sieve[i] == 1:\n            t += 1\n            primes.append(i)\n            sieve[i::i] = [0] * len(sieve[i::i])\n        pi.append(t)\n    (a, b) = (pi[root3 + 1], pi[root2 + 1])\n    Phi_memo = [0] * ((a + 1) * 800)\n    return Phi(n, a) + a - 1 - sum((pi[n // p] - pi[p] + 1 for p in primes[a:b]))"
    }
  ]
}