{
  "task_id": "taco_3726",
  "entry_point": "count_ways_to_connect_vertices",
  "mutant_count": 132,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 - 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 * 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 * 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 + 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 8\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 6\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 0\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 1\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + -7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[-1] / n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] / n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[-1] + n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] + n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[-1] ** n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] ** n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[-1] / n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] / n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[-1] + n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] + n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[-1] ** n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] ** n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_f[i][i] = dp_g[i][i] = 1",
      "mutated_line": "dp_f[i][i] = dp_g[i][i] = 2",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 2\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_f[i][i] = dp_g[i][i] = 1",
      "mutated_line": "dp_f[i][i] = dp_g[i][i] = 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 0\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_f[i][i] = dp_g[i][i] = 1",
      "mutated_line": "dp_f[i][i] = dp_g[i][i] = 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 0\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "dp_f[i][i] = dp_g[i][i] = 1",
      "mutated_line": "dp_f[i][i] = dp_g[i][i] = -1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = -1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n + 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n * 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if dp_f[l][r] != -1:",
      "mutated_line": "if dp_f[l][r] == -1:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] == -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if dp_g[l][r] != -1:",
      "mutated_line": "if dp_g[l][r] == -1:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] == -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(1, n - 1)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(1, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(-1, n - 1)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(-1, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(1, n - 1)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(1, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(0, n + 1)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(0, n * 1)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n * 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 11 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 9 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 0 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 1 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = -10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 10 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 8 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 0 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 1 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** -9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 2):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 0):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 0):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - -1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i - 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i - 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i * 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i * 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i - 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i - 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i * 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i * 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 2 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 2 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 0 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 0 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 0 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 0 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = -1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = -1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 1\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else -1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else -1\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 1\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "if dp_f[l][r] != -1:",
      "mutated_line": "if dp_f[l][r] != +1:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != +1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp_f[l][r] = g(l, r) if edge[l][r] else 0",
      "mutated_line": "dp_f[l][r] = g(l, r) if edge[l][r] else 1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 1\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp_f[l][r] = g(l, r) if edge[l][r] else 0",
      "mutated_line": "dp_f[l][r] = g(l, r) if edge[l][r] else -1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else -1\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "dp_f[l][r] = g(l, r) if edge[l][r] else 0",
      "mutated_line": "dp_f[l][r] = g(l, r) if edge[l][r] else 1",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 1\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l - 1, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l - 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l * 1, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l * 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "if dp_g[l][r] != -1:",
      "mutated_line": "if dp_g[l][r] != +1:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != +1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp_g[l][r] = f(l + 1, r)",
      "mutated_line": "dp_g[l][r] = f(l - 1, r)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l - 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp_g[l][r] = f(l + 1, r)",
      "mutated_line": "dp_g[l][r] = f(l * 1, r)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l * 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l - 1, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l - 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l * 1, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l * 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) * mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) * mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = dp_g[l][r] + f(l, m) * f(m + 1, r) + mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = dp_g[l][r] + f(l, m) * f(m + 1, r) + mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(0, n - 2)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(0, n - 0)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(0, n - 0)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return f(0, n - 1)",
      "mutated_line": "return f(0, n - -1)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - -1)"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[+1] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[+1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[+1] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[+1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 2] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 2] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 0] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 0] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 0] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 0] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + -1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + -1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 2] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 2] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 0] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 0] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 0] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 0] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + -1] = 1 if edge[i][i + 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + -1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i - 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i - 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i * 1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i * 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp_f[l][r] != -1:",
      "mutated_line": "if dp_f[l][r] != -2:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -2:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp_f[l][r] != -1:",
      "mutated_line": "if dp_f[l][r] != -0:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -0:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp_f[l][r] != -1:",
      "mutated_line": "if dp_f[l][r] != -0:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -0:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if dp_f[l][r] != -1:",
      "mutated_line": "if dp_f[l][r] != --1:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != --1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + 2, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 2, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + 0, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 0, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + 0, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 0, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + -1, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + -1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) * mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) * mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = dp_f[l][r] + g(l, m) * f(m, r) + mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = dp_f[l][r] + g(l, m) * f(m, r) + mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dp_g[l][r] != -1:",
      "mutated_line": "if dp_g[l][r] != -2:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -2:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dp_g[l][r] != -1:",
      "mutated_line": "if dp_g[l][r] != -0:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -0:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dp_g[l][r] != -1:",
      "mutated_line": "if dp_g[l][r] != -0:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -0:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if dp_g[l][r] != -1:",
      "mutated_line": "if dp_g[l][r] != --1:",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != --1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp_g[l][r] = f(l + 1, r)",
      "mutated_line": "dp_g[l][r] = f(l + 2, r)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 2, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp_g[l][r] = f(l + 1, r)",
      "mutated_line": "dp_g[l][r] = f(l + 0, r)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 0, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp_g[l][r] = f(l + 1, r)",
      "mutated_line": "dp_g[l][r] = f(l + 0, r)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 0, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp_g[l][r] = f(l + 1, r)",
      "mutated_line": "dp_g[l][r] = f(l + -1, r)",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + -1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + 2, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 2, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + 0, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 0, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + 0, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 0, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for m in range(l + 1, r):",
      "mutated_line": "for m in range(l + -1, r):",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + -1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] - f(l, m) * f(m + 1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] - f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = dp_g[l][r] * (f(l, m) * f(m + 1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = dp_g[l][r] * (f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[-2] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-2] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[-0] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-0] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[-0] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-0] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "dp_f = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_f = [[--1] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[--1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[-2] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-2] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[-0] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-0] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[-0] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-0] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "dp_g = [[-1] * n for _ in range(n)]",
      "mutated_line": "dp_g = [[--1] * n for _ in range(n)]",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[--1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 2] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 2] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 0] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 0] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 0] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 0] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0",
      "mutated_line": "dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + -1] else 0",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + -1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = (dp_f[l][r] - g(l, m) * f(m, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] - g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = dp_f[l][r] * (g(l, m) * f(m, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = dp_f[l][r] * (g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) / f(m + 1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) / f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + (f(l, m) + f(m + 1, r))) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + (f(l, m) + f(m + 1, r))) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) ** f(m + 1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) ** f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) / f(m, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) / f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = (dp_f[l][r] + (g(l, m) + f(m, r))) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + (g(l, m) + f(m, r))) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod",
      "mutated_line": "dp_f[l][r] = (dp_f[l][r] + g(l, m) ** f(m, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) ** f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m - 1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m - 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m * 1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m * 1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 2, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 2, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 0, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 0, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 0, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 0, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + 1, r)) % mod",
      "mutated_line": "dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + -1, r)) % mod",
      "code": "def count_ways_to_connect_vertices(n, edge):\n    mod = 10 ** 9 + 7\n    dp_f = [[-1] * n for _ in range(n)]\n    dp_g = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        dp_f[i][i] = dp_g[i][i] = 1\n    for i in range(n - 1):\n        dp_f[i][i + 1] = dp_g[i][i + 1] = 1 if edge[i][i + 1] else 0\n\n    def f(l, r):\n        if dp_f[l][r] != -1:\n            return dp_f[l][r]\n        dp_f[l][r] = g(l, r) if edge[l][r] else 0\n        for m in range(l + 1, r):\n            if edge[l][m]:\n                dp_f[l][r] = (dp_f[l][r] + g(l, m) * f(m, r)) % mod\n        return dp_f[l][r]\n\n    def g(l, r):\n        if dp_g[l][r] != -1:\n            return dp_g[l][r]\n        dp_g[l][r] = f(l + 1, r)\n        for m in range(l + 1, r):\n            dp_g[l][r] = (dp_g[l][r] + f(l, m) * f(m + -1, r)) % mod\n        return dp_g[l][r]\n    return f(0, n - 1)"
    }
  ]
}