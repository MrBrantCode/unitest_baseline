{
  "task_id": "taco_8394",
  "entry_point": "dist",
  "mutant_count": 149,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] - c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] - c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] * c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] * c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if distc > radsum:",
      "mutated_line": "if distc >= radsum:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc >= radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if distc > radsum:",
      "mutated_line": "if distc <= radsum:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc <= radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "if distc > radsum:",
      "mutated_line": "if distc != radsum:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc != radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] / 1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] / 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] + 1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] + 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] ** 1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] ** 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 - (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 - (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 * (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 * (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mindist = distc - radsum",
      "mutated_line": "mindist = distc + radsum",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc + radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "mindist = distc - radsum",
      "mutated_line": "mindist = distc * radsum",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc * radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdist = distc + radsum",
      "mutated_line": "maxdist = distc - radsum",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc - radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "maxdist = distc + radsum",
      "mutated_line": "maxdist = distc * radsum",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc * radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif distc < maxrad - minrad:",
      "mutated_line": "elif distc <= maxrad - minrad:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc <= maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif distc < maxrad - minrad:",
      "mutated_line": "elif distc >= maxrad - minrad:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc >= maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "elif distc < maxrad - minrad:",
      "mutated_line": "elif distc != maxrad - minrad:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc != maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] * 1000002",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000002\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] * 1000000",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000000\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] * 0",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 0\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] * 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [0] * -1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * -1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[0])] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] -= 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 1] += 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] += 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(2, len(l)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(2, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(0, len(l)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(0, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(0, len(l)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(0, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "for i in range(1, len(l)):",
      "mutated_line": "for i in range(-1, len(l)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(-1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] - l[i - 1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] - l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] * l[i - 1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] * l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) * 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) * 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt(x1 - x2 + 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt(x1 - x2 + 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) * 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) * 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2 + 2))",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2 + 2))\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[3] + c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[3] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[1] + c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[1] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[0] + c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[0] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[1] + c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[1] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[-2] + c2[2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[-2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] + c2[3]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[3]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] + c2[1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[1]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] + c2[0]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[0]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] + c2[1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[1]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "radsum = c1[2] + c2[2]",
      "mutated_line": "radsum = c1[2] + c2[-2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[-2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[1], c2[0], c1[1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[1], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[-1], c2[0], c1[1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[-1], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[1], c2[0], c1[1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[1], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[1], c1[1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[1], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[-1], c1[1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[-1], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[1], c1[1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[1], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[2], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[2], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[0], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[0], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[0], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[0], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[-1], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[-1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[1], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[2])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[1], c2[0])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[0])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[1], c2[0])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[0])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "distc = dist(c1[0], c2[0], c1[1], c2[1])",
      "mutated_line": "distc = dist(c1[0], c2[0], c1[1], c2[-1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[-1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[3], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[3], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[1], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[1], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[0], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[0], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[1], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[1], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[-2], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[-2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[2], c2[3])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[3])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[2], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[1])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[2], c2[0])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[0])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[2], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[1])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "maxrad = max(c1[2], c2[2])",
      "mutated_line": "maxrad = max(c1[2], c2[-2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[-2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[3], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[3], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[1], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[1], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[0], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[0], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[1], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[1], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[-2], c2[2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[-2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[2], c2[3])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[3])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[2], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[1])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[2], c2[0])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[0])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[2], c2[1])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[1])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "minrad = min(c1[2], c2[2])",
      "mutated_line": "minrad = min(c1[2], c2[-2])",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[-2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif distc < maxrad - minrad:",
      "mutated_line": "elif distc < maxrad + minrad:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad + minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "elif distc < maxrad - minrad:",
      "mutated_line": "elif distc < maxrad * minrad:",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad * minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mindist = maxrad - minrad - distc",
      "mutated_line": "mindist = maxrad - minrad + distc",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad + distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mindist = maxrad - minrad - distc",
      "mutated_line": "mindist = (maxrad - minrad) * distc",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = (maxrad - minrad) * distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 2 * maxrad + mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad + mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 2 * maxrad * mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad * mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mindist = 0",
      "mutated_line": "mindist = 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 1\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mindist = 0",
      "mutated_line": "mindist = -1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = -1\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "mindist = 0",
      "mutated_line": "mindist = 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 1\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "maxdist = radsum + distc",
      "mutated_line": "maxdist = radsum - distc",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum - distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "maxdist = radsum + distc",
      "mutated_line": "maxdist = radsum * distc",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum * distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [1] * 1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [1] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [-1] * 1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [-1] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "l = [0] * 1000001",
      "mutated_line": "l = [1] * 1000001",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [1] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(circles)):",
      "mutated_line": "for j in range(i - 1, len(circles)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i - 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(circles)):",
      "mutated_line": "for j in range(i * 1, len(circles)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i * 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[0])] += 2",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 2\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[0])] += 0",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 0\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[0])] += 0",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 0\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[0])] += -1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += -1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 1] -= 2",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 2\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 1] -= 0",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 0\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 1] -= 0",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 0\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 1] -= -1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= -1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 + x2) ** 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 + x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 * x2) ** 2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 * x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 3 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 3 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 0 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 0 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 1 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** -2 + (y1 - y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** -2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 + y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 + y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 * y2) ** 2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 * y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 3)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 3)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 0)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 0)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 1)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)",
      "mutated_line": "return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** -2)",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** -2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mindist = maxrad - minrad - distc",
      "mutated_line": "mindist = maxrad + minrad - distc",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad + minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mindist = maxrad - minrad - distc",
      "mutated_line": "mindist = maxrad * minrad - distc",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad * minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 2 / maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 / maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 2 + maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 + maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 2 ** maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 ** maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(circles)):",
      "mutated_line": "for j in range(i + 2, len(circles)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 2, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(circles)):",
      "mutated_line": "for j in range(i + 0, len(circles)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 0, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(circles)):",
      "mutated_line": "for j in range(i + 0, len(circles)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 0, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for j in range(i + 1, len(circles)):",
      "mutated_line": "for j in range(i + -1, len(circles)):",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + -1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) - 1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) - 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) * 1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) * 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] + l[i + 1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i + 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] + l[i * 1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i * 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 3 * maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 3 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 1 * maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 1 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 0 * maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 0 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = 1 * maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 1 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "maxdist = 2 * maxrad - mindist",
      "mutated_line": "maxdist = -2 * maxrad - mindist",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = -2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 2] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 2] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 0] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 0] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + 0] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 0] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[1]) + -1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + -1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] + l[i - 2]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 2]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] + l[i - 0]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 0]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] + l[i - 0]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 0]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "l[i] = l[i] + l[i - 1]",
      "mutated_line": "l[i] = l[i] + l[i - -1]",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - -1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[1])] += 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[1])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[-1])] += 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[-1])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "l[math.ceil(x[0])] += 1",
      "mutated_line": "l[math.ceil(x[1])] += 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[1])] += 1\n            l[math.floor(x[1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[2]) + 1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[2]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[0]) + 1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[0]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[0]) + 1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[0]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "l[math.floor(x[1]) + 1] -= 1",
      "mutated_line": "l[math.floor(x[-1]) + 1] -= 1",
      "code": "import math\n\ndef dist(x1, x2, y1, y2):\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\ndef calculate(c1, c2):\n    radsum = c1[2] + c2[2]\n    distc = dist(c1[0], c2[0], c1[1], c2[1])\n    maxrad = max(c1[2], c2[2])\n    minrad = min(c1[2], c2[2])\n    if distc > radsum:\n        mindist = distc - radsum\n        maxdist = distc + radsum\n    elif distc < maxrad - minrad:\n        mindist = maxrad - minrad - distc\n        maxdist = 2 * maxrad - mindist\n    else:\n        mindist = 0\n        maxdist = radsum + distc\n    return [mindist, maxdist]\n\ndef count_good_pairs(circles, queries):\n    l = [0] * 1000001\n    for i in range(len(circles)):\n        for j in range(i + 1, len(circles)):\n            x = calculate(circles[i], circles[j])\n            l[math.ceil(x[0])] += 1\n            l[math.floor(x[-1]) + 1] -= 1\n    for i in range(1, len(l)):\n        l[i] = l[i] + l[i - 1]\n    results = [l[k] for k in queries]\n    return results"
    }
  ]
}