{
  "task_id": "taco_16811",
  "entry_point": "itable_to_multiset",
  "mutant_count": 164,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "assert len(start) == len(finish)",
      "mutated_line": "assert len(start) != len(finish)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) != len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rv = 0",
      "mutated_line": "rv = 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 1\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rv = 0",
      "mutated_line": "rv = -1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = -1\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "rv = 0",
      "mutated_line": "rv = 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 1\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "rv *= b",
      "mutated_line": "rv /= b",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv /= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "rv += f - s",
      "mutated_line": "rv -= f - s",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv -= f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return rv % m",
      "mutated_line": "return rv * m",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv * m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "return rv % m",
      "mutated_line": "return rv + m",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv + m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 - 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 - 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 * 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 * 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "missing = all_digs - set(dig_freqs.keys())",
      "mutated_line": "missing = all_digs + set(dig_freqs.keys())",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs + set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "missing = all_digs - set(dig_freqs.keys())",
      "mutated_line": "missing = all_digs * set(dig_freqs.keys())",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs * set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if len(missing) == 0:",
      "mutated_line": "if len(missing) != 0:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) != 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "done = False",
      "mutated_line": "done = True",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = True\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "dig_freqs[dig] -= 1",
      "mutated_line": "dig_freqs[dig] += 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] += 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 0) - 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) - 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 0) * 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) * 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "rv += f - s",
      "mutated_line": "rv += f + s",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f + s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "rv += f - s",
      "mutated_line": "rv += f * s",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f * s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 * 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 * 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 + 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 + 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 + 8):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 8):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 + 6):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 6):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 + 0):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 0):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 + 1):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 1):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 9 + -7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + -7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(missing) == 0:",
      "mutated_line": "if len(missing) == 1:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 1:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(missing) == 0:",
      "mutated_line": "if len(missing) == -1:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == -1:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if len(missing) == 0:",
      "mutated_line": "if len(missing) == 1:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 1:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 1\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return -1\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 1\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dig_freqs[dig] -= 1",
      "mutated_line": "dig_freqs[dig] -= 2",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 2\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dig_freqs[dig] -= 1",
      "mutated_line": "dig_freqs[dig] -= 0",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 0\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dig_freqs[dig] -= 1",
      "mutated_line": "dig_freqs[dig] -= 0",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 0\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dig_freqs[dig] -= 1",
      "mutated_line": "dig_freqs[dig] -= -1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= -1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if dig_freqs[dig] == 0:",
      "mutated_line": "if dig_freqs[dig] != 0:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] != 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx and dig == b - 1 and (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx and dig == b - 1 and (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(missing) < idx:",
      "mutated_line": "if len(missing) <= idx:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) <= idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(missing) < idx:",
      "mutated_line": "if len(missing) >= idx:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) >= idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if len(missing) < idx:",
      "mutated_line": "if len(missing) != idx:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) != idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if new_dig in missing:",
      "mutated_line": "if new_dig not in missing:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig not in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans_len = max(n + 1, b)",
      "mutated_line": "ans_len = max(n - 1, b)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n - 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "ans_len = max(n + 1, b)",
      "mutated_line": "ans_len = max(n * 1, b)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n * 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) - list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) - list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, ([1] + [0] * (ans_len + 1 - b)) * list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, ([1] + [0] * (ans_len + 1 - b)) * list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) - A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) - A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) * A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) * A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 0) + 2",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 2\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 0) + 0",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 0\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 0) + 0",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 0\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 0) + -1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + -1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=11 ** 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=11 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=9 ** 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=9 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=0 ** 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=0 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=1 ** 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=1 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=-10 ** 9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=-10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 10 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 10 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 8 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 8 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 0 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 0 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** 1 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 1 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "def find_smallest_x(n, b, A, modulus=10**9 + 7):",
      "mutated_line": "def find_smallest_x(n, b, A, modulus=10 ** -9 + 7):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** -9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(2, n + 1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(2, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(0, n + 1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(0, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(0, n + 1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(0, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(-1, n + 1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(-1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(1, n - 1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n - 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(1, n * 1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n * 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if dig_freqs[dig] == 0:",
      "mutated_line": "if dig_freqs[dig] == 1:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 1:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if dig_freqs[dig] == 0:",
      "mutated_line": "if dig_freqs[dig] == -1:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == -1:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if dig_freqs[dig] == 0:",
      "mutated_line": "if dig_freqs[dig] == 1:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 1:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dig > max_missing:",
      "mutated_line": "if dig >= max_missing:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig >= max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dig > max_missing:",
      "mutated_line": "if dig <= max_missing:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig <= max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if dig > max_missing:",
      "mutated_line": "if dig != max_missing:",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig != max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) >= idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) >= idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) <= idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) <= idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) != idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) != idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig != b - 1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig != b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx or dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx or dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "new_dig = dig + 1",
      "mutated_line": "new_dig = dig - 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig - 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "new_dig = dig + 1",
      "mutated_line": "new_dig = dig * 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig * 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) - missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) - missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, ([new_dig] + [0] * (idx - 1 - len(missing))) * missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, ([new_dig] + [0] * (idx - 1 - len(missing))) * missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans_len = max(n + 1, b)",
      "mutated_line": "ans_len = max(n + 2, b)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 2, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans_len = max(n + 1, b)",
      "mutated_line": "ans_len = max(n + 0, b)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 0, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans_len = max(n + 1, b)",
      "mutated_line": "ans_len = max(n + 0, b)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 0, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "ans_len = max(n + 1, b)",
      "mutated_line": "ans_len = max(n + -1, b)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + -1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] - [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] - [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] * ([0] * (ans_len + 1 - b)) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] * ([0] * (ans_len + 1 - b)) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] / (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] / (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] + (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] + (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] ** (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] ** (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 1) + 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 1) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, -1) + 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, -1) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "rv[x] = rv.get(x, 0) + 1",
      "mutated_line": "rv[x] = rv.get(x, 1) + 1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 1) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(1, n + 2)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 2)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(1, n + 0)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 0)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(1, n + 0)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 0)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for (dig, idx) in zip(reversed(A), range(1, n + 1)):",
      "mutated_line": "for (dig, idx) in zip(reversed(A), range(1, n + -1)):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + -1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b + 1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b + 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b * 1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b * 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 1 or (len(missing) != idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) != idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig > max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig > max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig < max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig < max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig == max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig == max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "new_dig = dig + 1",
      "mutated_line": "new_dig = dig + 2",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 2\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "new_dig = dig + 1",
      "mutated_line": "new_dig = dig + 0",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 0\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "new_dig = dig + 1",
      "mutated_line": "new_dig = dig + 0",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 0\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "new_dig = dig + 1",
      "mutated_line": "new_dig = dig + -1",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + -1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] - [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] - [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] * ([0] * (idx - 1 - len(missing))) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] * ([0] * (idx - 1 - len(missing))) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] / (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] / (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + ([0] + (ans_len + 1 - b)) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + ([0] + (ans_len + 1 - b)) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] ** (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] ** (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len + n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len + n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len * n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len * n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 2 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 2 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 0 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 0 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - 0 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 0 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):",
      "mutated_line": "if len(missing) > idx or dig == b - -1 or (len(missing) == idx and dig >= max_missing):",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - -1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] / (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] / (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + ([0] + (idx - 1 - len(missing))) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + ([0] + (idx - 1 - len(missing))) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] ** (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] ** (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "UOI",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[+idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[+idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [2] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [2] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [0] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [0] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [0] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [0] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [-1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [-1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 + b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 + b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * ((ans_len + 1) * b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * ((ans_len + 1) * b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(3, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(3, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(1, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(1, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(0, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(0, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(1, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(1, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(-2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(-2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [1] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [1] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [-1] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [-1] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [1] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [1] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_dig = min(missing.intersection(range(dig + 1, b)))",
      "mutated_line": "new_dig = min(missing.intersection(range(dig - 1, b)))",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig - 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "new_dig = min(missing.intersection(range(dig + 1, b)))",
      "mutated_line": "new_dig = min(missing.intersection(range(dig * 1, b)))",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig * 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - 1 + len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 + len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * ((idx - 1) * len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * ((idx - 1) * len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [1] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [1] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [-1] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [-1] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [1] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [1] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len - 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len - 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len * 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len * 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_dig = min(missing.intersection(range(dig + 1, b)))",
      "mutated_line": "new_dig = min(missing.intersection(range(dig + 2, b)))",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 2, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_dig = min(missing.intersection(range(dig + 1, b)))",
      "mutated_line": "new_dig = min(missing.intersection(range(dig + 0, b)))",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 0, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_dig = min(missing.intersection(range(dig + 1, b)))",
      "mutated_line": "new_dig = min(missing.intersection(range(dig + 0, b)))",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 0, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "new_dig = min(missing.intersection(range(dig + 1, b)))",
      "mutated_line": "new_dig = min(missing.intersection(range(dig + -1, b)))",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + -1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [1] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [1] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [-1] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [-1] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [1] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [1] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx + 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx + 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx * 1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx * 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 2 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 2 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 0 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 0 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + 0 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 0 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "mutated_line": "return answer(b, [1] + [0] * (ans_len + -1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + -1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - 2 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 2 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - 0 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 0 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - 0 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - 0 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return answer(b, [new_dig] + [0] * (idx - 1 - len(missing)) + missing, A[-idx:], modulus)",
      "mutated_line": "return answer(b, [new_dig] + [0] * (idx - -1 - len(missing)) + missing, A[-idx:], modulus)",
      "code": "def itable_to_multiset(s):\n    rv = {}\n    for x in s:\n        rv[x] = rv.get(x, 0) + 1\n    return rv\n\ndef answer(b, finish, start, m):\n    assert len(start) == len(finish)\n    rv = 0\n    for (s, f) in zip(start, finish):\n        rv *= b\n        rv %= m\n        rv += f - s\n    return rv % m\n\ndef find_smallest_x(n, b, A, modulus=10 ** 9 + 7):\n    dig_freqs = itable_to_multiset(A)\n    all_digs = set(range(b))\n    missing = all_digs - set(dig_freqs.keys())\n    if len(missing) == 0:\n        return 0\n    done = False\n    max_missing = max(missing)\n    for (dig, idx) in zip(reversed(A), range(1, n + 1)):\n        dig_freqs[dig] -= 1\n        if dig_freqs[dig] == 0:\n            missing.add(dig)\n            if dig > max_missing:\n                max_missing = dig\n        if len(missing) > idx or dig == b - 1 or (len(missing) == idx and dig >= max_missing):\n            continue\n        if len(missing) < idx:\n            new_dig = dig + 1\n        else:\n            new_dig = min(missing.intersection(range(dig + 1, b)))\n        if new_dig in missing:\n            missing.remove(new_dig)\n        missing = list(missing)\n        missing.sort()\n        return answer(b, [new_dig] + [0] * (idx - -1 - len(missing)) + missing, A[-idx:], modulus)\n    ans_len = max(n + 1, b)\n    return answer(b, [1] + [0] * (ans_len + 1 - b) + list(range(2, b)), [0] * (ans_len - n) + A, modulus)"
    }
  ]
}