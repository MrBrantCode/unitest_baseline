{
  "task_id": "taco_618",
  "entry_point": "find_unfair_subset",
  "mutant_count": 51,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 1",
      "mutated_line": "i = 2",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 2\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 0\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 1",
      "mutated_line": "i = 0",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 0\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "i = 1",
      "mutated_line": "i = -1",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = -1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n:",
      "mutated_line": "while i <= n:",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i <= n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n:",
      "mutated_line": "while i >= n:",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i >= n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "while i < n:",
      "mutated_line": "while i != n:",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i != n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "i += 2",
      "mutated_line": "i -= 2",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i -= 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][0] - 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] - 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][0] * 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] * 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 2",
      "mutated_line": "i += 3",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 3\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 2",
      "mutated_line": "i += 1",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 1\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 2",
      "mutated_line": "i += 0",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 0\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 2",
      "mutated_line": "i += 1",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 1\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "i += 2",
      "mutated_line": "i += -2",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += -2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "idAB = sorted(idAB, key=lambda x: x[1], reverse=True)",
      "mutated_line": "idAB = sorted(idAB, key=lambda x: x[1], reverse=False)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=False)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][0] + 2]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 2]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][0] + 0]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 0]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][0] + 0]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 0]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][0] + -1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + -1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[0] - 1)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] - 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[0] * 1)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] * 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][1] + 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][1] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][-1] + 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][-1] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[0][1] + 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][1] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[0] + 2)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 2)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[0] + 0)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 0)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[0] + 0)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 0)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[0] + -1)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + -1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "idAB = sorted(idAB, key=lambda x: x[1], reverse=True)",
      "mutated_line": "idAB = sorted(idAB, key=lambda x: x[2], reverse=True)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[2], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "idAB = sorted(idAB, key=lambda x: x[1], reverse=True)",
      "mutated_line": "idAB = sorted(idAB, key=lambda x: x[0], reverse=True)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[0], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "idAB = sorted(idAB, key=lambda x: x[1], reverse=True)",
      "mutated_line": "idAB = sorted(idAB, key=lambda x: x[0], reverse=True)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[0], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "idAB = sorted(idAB, key=lambda x: x[1], reverse=True)",
      "mutated_line": "idAB = sorted(idAB, key=lambda x: x[-1], reverse=True)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[-1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[1][0] + 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[1][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[-1][0] + 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[-1][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "ans = [idAB[0][0] + 1]",
      "mutated_line": "ans = [idAB[1][0] + 1]",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[1][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i - 2], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i - 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i * 2], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i * 2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[1] + 1)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[1] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[-1] + 1)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[-1] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ans.append(choice[0] + 1)",
      "mutated_line": "ans.append(choice[1] + 1)",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[2])\n        ans.append(choice[1] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 3], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 3], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 1], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 1], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 0], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 0], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 1], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 1], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + -2], key=lambda x: x[2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + -2], key=lambda x: x[2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 2], key=lambda x: x[3])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[3])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 2], key=lambda x: x[1])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[1])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 2], key=lambda x: x[0])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[0])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 2], key=lambda x: x[1])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[1])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "choice = max(idAB[i:i + 2], key=lambda x: x[2])",
      "mutated_line": "choice = max(idAB[i:i + 2], key=lambda x: x[-2])",
      "code": "def find_unfair_subset(n, A, B):\n    idAB = list(zip(range(n), A, B))\n    idAB = sorted(idAB, key=lambda x: x[1], reverse=True)\n    ans = [idAB[0][0] + 1]\n    i = 1\n    while i < n:\n        choice = max(idAB[i:i + 2], key=lambda x: x[-2])\n        ans.append(choice[0] + 1)\n        i += 2\n    ans = sorted(ans)\n    return (len(ans), ans)"
    }
  ]
}