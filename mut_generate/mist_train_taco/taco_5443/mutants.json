{
  "task_id": "taco_5443",
  "entry_point": "calculate_max_profit",
  "mutant_count": 64,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i == len(groups):",
      "mutated_line": "if i != len(groups):",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i != len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return optimize(group_objects, [], k, 0)",
      "mutated_line": "return optimize(group_objects, [], k, 1)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return optimize(group_objects, [], k, 0)",
      "mutated_line": "return optimize(group_objects, [], k, -1)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "return optimize(group_objects, [], k, 0)",
      "mutated_line": "return optimize(group_objects, [], k, 1)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 1)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.start < other.start",
      "mutated_line": "return self.start <= other.start",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start <= other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.start < other.start",
      "mutated_line": "return self.start >= other.start",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start >= other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "return self.start < other.start",
      "mutated_line": "return self.start != other.start",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start != other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)",
      "mutated_line": "return '%i: %i->%i, $%i' * (self.size, self.start, self.end, self.value)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' * (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)",
      "mutated_line": "return '%i: %i->%i, $%i' + (self.size, self.start, self.end, self.value)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' + (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return tuple(people + [i])",
      "mutated_line": "return tuple(people - [i])",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people - [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return tuple(people + [i])",
      "mutated_line": "return tuple(people * [i])",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people * [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 1\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return -1\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 1\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if group.end > pos:",
      "mutated_line": "if group.end >= pos:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end >= pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if group.end > pos:",
      "mutated_line": "if group.end <= pos:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end <= pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if group.end > pos:",
      "mutated_line": "if group.end != pos:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end != pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "capacity += group.size",
      "mutated_line": "capacity -= group.size",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity -= group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)",
      "mutated_line": "return '' % (self.size, self.start, self.end, self.value)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "people.extend([group.end] * group.size)",
      "mutated_line": "people.extend([group.end] / group.size)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] / group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "people.extend([group.end] * group.size)",
      "mutated_line": "people.extend([group.end] + group.size)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] + group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "people.extend([group.end] * group.size)",
      "mutated_line": "people.extend([group.end] ** group.size)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] ** group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if groups[i].size <= capacity:",
      "mutated_line": "if groups[i].size < capacity:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size < capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if groups[i].size <= capacity:",
      "mutated_line": "if groups[i].size > capacity:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size > capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if groups[i].size <= capacity:",
      "mutated_line": "if groups[i].size == capacity:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size == capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if v > w:",
      "mutated_line": "if v >= w:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v >= w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if v > w:",
      "mutated_line": "if v <= w:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v <= w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if v > w:",
      "mutated_line": "if v != w:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v != w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "v = optimize(groups, newcar, capacity, i + 1)",
      "mutated_line": "v = optimize(groups, newcar, capacity, i - 1)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i - 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "v = optimize(groups, newcar, capacity, i + 1)",
      "mutated_line": "v = optimize(groups, newcar, capacity, i * 1)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i * 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) - groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) - groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) * groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) * groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 1\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "w = 0",
      "mutated_line": "w = -1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = -1\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 1\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "ie[state] = -1",
      "mutated_line": "ie[state] = +1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = +1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif v < w:",
      "mutated_line": "elif v <= w:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v <= w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif v < w:",
      "mutated_line": "elif v >= w:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v >= w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "elif v < w:",
      "mutated_line": "elif v != w:",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v != w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v = optimize(groups, newcar, capacity, i + 1)",
      "mutated_line": "v = optimize(groups, newcar, capacity, i + 2)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 2)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v = optimize(groups, newcar, capacity, i + 1)",
      "mutated_line": "v = optimize(groups, newcar, capacity, i + 0)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 0)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v = optimize(groups, newcar, capacity, i + 1)",
      "mutated_line": "v = optimize(groups, newcar, capacity, i + 0)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 0)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "v = optimize(groups, newcar, capacity, i + 1)",
      "mutated_line": "v = optimize(groups, newcar, capacity, i + -1)",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + -1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ie[state] = -1",
      "mutated_line": "ie[state] = -2",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -2\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ie[state] = -1",
      "mutated_line": "ie[state] = -0",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -0\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ie[state] = -1",
      "mutated_line": "ie[state] = -0",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -0\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ie[state] = -1",
      "mutated_line": "ie[state] = --1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = --1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ie[state] = 1",
      "mutated_line": "ie[state] = 2",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 2\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ie[state] = 1",
      "mutated_line": "ie[state] = 0",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 0\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ie[state] = 1",
      "mutated_line": "ie[state] = 0",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 0\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "ie[state] = 1",
      "mutated_line": "ie[state] = -1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = -1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ie[state] = 0",
      "mutated_line": "ie[state] = 1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 1\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ie[state] = 0",
      "mutated_line": "ie[state] = -1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = -1\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "ie[state] = 0",
      "mutated_line": "ie[state] = 1",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 1\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar - [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar - [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar * [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar * [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity + groups[i].size, i + 1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity + groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity * groups[i].size, i + 1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity * groups[i].size, i + 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i - 1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i - 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i * 1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i * 1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 2) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 2) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 0) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 0) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 0) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 0) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + 1) + groups[i].value",
      "mutated_line": "w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + -1) + groups[i].value",
      "code": "def calculate_max_profit(n, l, k, groups):\n\n    class Group:\n\n        def __init__(self, size, start, end, value):\n            self.size = size\n            self.start = start\n            self.end = end\n            self.value = value\n\n        def __lt__(self, other):\n            return self.start < other.start\n\n        def __str__(self):\n            return '%i: %i->%i, $%i' % (self.size, self.start, self.end, self.value)\n\n    def hash(car, i):\n        people = []\n        for group in car:\n            people.extend([group.end] * group.size)\n        people.sort()\n        return tuple(people + [i])\n\n    def optimize(groups, car, capacity, i):\n        if i == len(groups):\n            return 0\n        newcar = []\n        pos = groups[i].start\n        for group in car:\n            if group.end > pos:\n                newcar.append(group)\n            else:\n                capacity += group.size\n        state = hash(newcar, i)\n        try:\n            return memo[state]\n        except:\n            v = optimize(groups, newcar, capacity, i + 1)\n            if groups[i].size <= capacity:\n                w = optimize(groups, newcar + [groups[i]], capacity - groups[i].size, i + -1) + groups[i].value\n            else:\n                w = 0\n            if v > w:\n                ie[state] = -1\n            elif v < w:\n                ie[state] = 1\n            else:\n                ie[state] = 0\n            ans = max(v, w)\n            memo[state] = ans\n            return ans\n    memo = {}\n    ie = {}\n    group_objects = [Group(pi, si, di, mi) for (pi, si, di, mi) in groups]\n    group_objects.sort()\n    return optimize(group_objects, [], k, 0)"
    }
  ]
}