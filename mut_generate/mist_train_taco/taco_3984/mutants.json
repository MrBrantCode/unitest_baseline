{
  "task_id": "taco_3984",
  "entry_point": "find_tank_tap_pairs",
  "mutant_count": 72,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "indeg[b[i]] += 1",
      "mutated_line": "indeg[b[i]] -= 1",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] -= 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] / (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] / (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] + (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] + (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] ** (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] ** (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited[node] = 1",
      "mutated_line": "visited[node] = 2",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 2\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited[node] = 1",
      "mutated_line": "visited[node] = 0",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 0\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited[node] = 1",
      "mutated_line": "visited[node] = 0",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 0\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "visited[node] = 1",
      "mutated_line": "visited[node] = -1",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = -1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "indeg[b[i]] += 1",
      "mutated_line": "indeg[b[i]] += 2",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 2\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "indeg[b[i]] += 1",
      "mutated_line": "indeg[b[i]] += 0",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 0\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "indeg[b[i]] += 1",
      "mutated_line": "indeg[b[i]] += 0",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 0\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "indeg[b[i]] += 1",
      "mutated_line": "indeg[b[i]] += -1",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += -1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] * (n - 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n - 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] * (n * 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n * 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(2, n + 1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(2, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(0, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(0, n + 1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(0, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(-1, n + 1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(-1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n - 1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n - 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n * 1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n * 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -1 or indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 or indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if visited[nbr] == -1:",
      "mutated_line": "if visited[nbr] != -1:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] != -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [+1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [+1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + 2)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 2)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + 0)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 0)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + 0)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 0)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + -1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + -1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 2):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 2):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 0):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + 0):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 0):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for i in range(1, n + 1):",
      "mutated_line": "for i in range(1, n + -1):",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + -1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] != -1 and indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] != -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -1 and indeg[i] != 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] != 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if i != last_node[0]:",
      "mutated_line": "if i == last_node[0]:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i == last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if visited[nbr] == -1:",
      "mutated_line": "if visited[nbr] == +1:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == +1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-2] * (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-2] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-0] * (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-0] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [-0] * (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-0] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "visited = [-1] * (n + 1)",
      "mutated_line": "visited = [--1] * (n + 1)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [--1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == +1 and indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == +1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -1 and indeg[i] == 1:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 1:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -1 and indeg[i] == -1:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == -1:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -1 and indeg[i] == 1:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 1:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if visited[nbr] == -1:",
      "mutated_line": "if visited[nbr] == -2:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -2:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if visited[nbr] == -1:",
      "mutated_line": "if visited[nbr] == -0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -0:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if visited[nbr] == -1:",
      "mutated_line": "if visited[nbr] == -0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -0:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if visited[nbr] == -1:",
      "mutated_line": "if visited[nbr] == --1:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == --1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "diameter[0] = min(diameter[0], d)",
      "mutated_line": "diameter[1] = min(diameter[0], d)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[1] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "diameter[0] = min(diameter[0], d)",
      "mutated_line": "diameter[-1] = min(diameter[0], d)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[-1] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "diameter[0] = min(diameter[0], d)",
      "mutated_line": "diameter[1] = min(diameter[0], d)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[1] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "last_node[0] = nbr",
      "mutated_line": "last_node[1] = nbr",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[1] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "last_node[0] = nbr",
      "mutated_line": "last_node[-1] = nbr",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[-1] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "last_node[0] = nbr",
      "mutated_line": "last_node[1] = nbr",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[1] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -2 and indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -2 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -0 and indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -0 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == -0 and indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -0 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if visited[i] == -1 and indeg[i] == 0:",
      "mutated_line": "if visited[i] == --1 and indeg[i] == 0:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == --1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i != last_node[0]:",
      "mutated_line": "if i != last_node[1]:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[1]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i != last_node[0]:",
      "mutated_line": "if i != last_node[-1]:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[-1]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if i != last_node[0]:",
      "mutated_line": "if i != last_node[1]:",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[1]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans.sort(key=lambda x: x[0])",
      "mutated_line": "ans.sort(key=lambda x: x[1])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans.sort(key=lambda x: x[0])",
      "mutated_line": "ans.sort(key=lambda x: x[-1])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[-1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "ans.sort(key=lambda x: x[0])",
      "mutated_line": "ans.sort(key=lambda x: x[1])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[1])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "diameter[0] = min(diameter[0], d)",
      "mutated_line": "diameter[0] = min(diameter[1], d)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[1], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "diameter[0] = min(diameter[0], d)",
      "mutated_line": "diameter[0] = min(diameter[-1], d)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[-1], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "diameter[0] = min(diameter[0], d)",
      "mutated_line": "diameter[0] = min(diameter[1], d)",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[1], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([i, last_node[0], diameter[0]])",
      "mutated_line": "ans.append([i, last_node[1], diameter[0]])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[1], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([i, last_node[0], diameter[0]])",
      "mutated_line": "ans.append([i, last_node[-1], diameter[0]])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[-1], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([i, last_node[0], diameter[0]])",
      "mutated_line": "ans.append([i, last_node[1], diameter[0]])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[1], diameter[0]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([i, last_node[0], diameter[0]])",
      "mutated_line": "ans.append([i, last_node[0], diameter[1]])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[1]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([i, last_node[0], diameter[0]])",
      "mutated_line": "ans.append([i, last_node[0], diameter[-1]])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[-1]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ans.append([i, last_node[0], diameter[0]])",
      "mutated_line": "ans.append([i, last_node[0], diameter[1]])",
      "code": "from collections import defaultdict\nfrom sys import maxsize\n\ndef find_tank_tap_pairs(n, p, a, b, d):\n\n    def dfs(node, visited, adj, diameter, last_node):\n        visited[node] = 1\n        for (nbr, d) in adj[node]:\n            if visited[nbr] == -1:\n                diameter[0] = min(diameter[0], d)\n                last_node[0] = nbr\n                dfs(nbr, visited, adj, diameter, last_node)\n    adj = defaultdict(list)\n    indeg = defaultdict(int)\n    for i in range(p):\n        adj[a[i]].append((b[i], d[i]))\n        indeg[b[i]] += 1\n    visited = [-1] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if visited[i] == -1 and indeg[i] == 0:\n            diameter = [maxsize]\n            last_node = [i]\n            dfs(i, visited, adj, diameter, last_node)\n            if i != last_node[0]:\n                ans.append([i, last_node[0], diameter[1]])\n    ans.sort(key=lambda x: x[0])\n    return ans"
    }
  ]
}