{
  "task_id": "taco_1272",
  "entry_point": "find_square_and_rectangle_partition",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "eps = 1e-08",
      "mutated_line": "eps = 1.00000001",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1.00000001\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "eps = 1e-08",
      "mutated_line": "eps = -0.99999999",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = -0.99999999\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "eps = 1e-08",
      "mutated_line": "eps = 0",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 0\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "eps = 1e-08",
      "mutated_line": "eps = 1",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "eps = 1e-08",
      "mutated_line": "eps = -1e-08",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = -1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return sum([x * y for (x, y) in zip(v1, v2)]) < eps",
      "mutated_line": "return sum([x * y for (x, y) in zip(v1, v2)]) <= eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) <= eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return sum([x * y for (x, y) in zip(v1, v2)]) < eps",
      "mutated_line": "return sum([x * y for (x, y) in zip(v1, v2)]) >= eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) >= eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return sum([x * y for (x, y) in zip(v1, v2)]) < eps",
      "mutated_line": "return sum([x * y for (x, y) in zip(v1, v2)]) != eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) != eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps or abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps or abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return False\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return True\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return True\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for comb in itertools.combinations(idx, 4):",
      "mutated_line": "for comb in itertools.combinations(idx, 5):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 5):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for comb in itertools.combinations(idx, 4):",
      "mutated_line": "for comb in itertools.combinations(idx, 3):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 3):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for comb in itertools.combinations(idx, 4):",
      "mutated_line": "for comb in itertools.combinations(idx, 0):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 0):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for comb in itertools.combinations(idx, 4):",
      "mutated_line": "for comb in itertools.combinations(idx, 1):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 1):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for comb in itertools.combinations(idx, 4):",
      "mutated_line": "for comb in itertools.combinations(idx, -4):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, -4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "if is_square(fs) and is_rect(ss):",
      "mutated_line": "if is_square(fs) or is_rect(ss):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) or is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 50,
      "original_line": "if is_square(ss) and is_rect(fs):",
      "mutated_line": "if is_square(ss) or is_rect(fs):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) or is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = list(range(8))",
      "mutated_line": "idx = list(range(9))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(9))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = list(range(8))",
      "mutated_line": "idx = list(range(7))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(7))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = list(range(8))",
      "mutated_line": "idx = list(range(0))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(0))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = list(range(8))",
      "mutated_line": "idx = list(range(1))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(1))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "idx = list(range(8))",
      "mutated_line": "idx = list(range(-8))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(-8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) <= eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) <= eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) >= eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) >= eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) != eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) != eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) <= eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) <= eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) >= eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) >= eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) != eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) != eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l = ls[0]",
      "mutated_line": "l = ls[1]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[1]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l = ls[0]",
      "mutated_line": "l = ls[-1]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[-1]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "l = ls[0]",
      "mutated_line": "l = ls[1]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[1]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(lx - l) > eps:",
      "mutated_line": "if abs(lx - l) >= eps:",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) >= eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(lx - l) > eps:",
      "mutated_line": "if abs(lx - l) <= eps:",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) <= eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if abs(lx - l) > eps:",
      "mutated_line": "if abs(lx - l) != eps:",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) != eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if all_perpendicular(vs) and square_sides(vs):",
      "mutated_line": "if all_perpendicular(vs) or square_sides(vs):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) or square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "if all_perpendicular(vs) and rect_sides(vs):",
      "mutated_line": "if all_perpendicular(vs) or rect_sides(vs):",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) or rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ssi = list(set(idx) - set(comb))",
      "mutated_line": "ssi = list(set(idx) + set(comb))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) + set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ssi = list(set(idx) - set(comb))",
      "mutated_line": "ssi = list(set(idx) * set(comb))",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) * set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return True\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] + cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] + cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] * cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] * cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] + cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] + cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] * cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] * cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return False\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return False\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return sum([x * y for (x, y) in zip(v1, v2)]) < eps",
      "mutated_line": "return sum([x / y for (x, y) in zip(v1, v2)]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x / y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return sum([x * y for (x, y) in zip(v1, v2)]) < eps",
      "mutated_line": "return sum([x + y for (x, y) in zip(v1, v2)]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x + y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return sum([x * y for (x, y) in zip(v1, v2)]) < eps",
      "mutated_line": "return sum([x ** y for (x, y) in zip(v1, v2)]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x ** y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] + ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] + ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] * ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] * ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] + ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] + ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] * ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] * ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if abs(lx - l) > eps:",
      "mutated_line": "if abs(lx + l) > eps:",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx + l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if abs(lx - l) > eps:",
      "mutated_line": "if abs(lx * l) > eps:",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx * l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(5)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(5)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(3)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(3)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(0)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(0)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(1)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(1)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(-4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(-4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i - 1 for i in fsi], [i + 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i - 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i * 1 for i in fsi], [i + 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i * 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 1 for i in fsi], [i - 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i - 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 1 for i in fsi], [i * 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i * 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i - 1 for i in ssi], [i + 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i - 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i * 1 for i in ssi], [i + 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i * 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 1 for i in ssi], [i - 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i - 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 1 for i in ssi], [i * 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i * 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) * 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) * 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[i + 1 + 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[i + 1 + 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(5)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(5)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(3)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(3)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(0)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(0)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(1)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(1)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(-4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(-4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][1] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][1] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][-1] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][-1] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][1] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][1] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][1], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][1], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][-1], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][-1], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][1], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][1], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][2] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][2] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][0] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][0] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][0] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][0] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][-1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][-1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][2]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][2]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][0]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][0]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][0]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][0]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][-1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][-1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 2 for i in fsi], [i + 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 2 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 0 for i in fsi], [i + 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 0 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 0 for i in fsi], [i + 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 0 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + -1 for i in fsi], [i + 1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + -1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 1 for i in fsi], [i + 2 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 2 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 1 for i in fsi], [i + 0 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 0 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 1 for i in fsi], [i + 0 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 0 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return [i + 1 for i in fsi], [i + 1 for i in ssi]",
      "mutated_line": "return ([i + 1 for i in fsi], [i + -1 for i in ssi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + -1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 2 for i in ssi], [i + 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 2 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 0 for i in ssi], [i + 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 0 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 0 for i in ssi], [i + 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 0 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + -1 for i in ssi], [i + 1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + -1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 1 for i in ssi], [i + 2 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 2 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 1 for i in ssi], [i + 0 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 0 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 1 for i in ssi], [i + 0 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 0 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "return [i + 1 for i in ssi], [i + 1 for i in fsi]",
      "mutated_line": "return ([i + 1 for i in ssi], [i + -1 for i in fsi])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + -1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i - 1) % 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i - 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[i * 1 % 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[i * 1 % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 5]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 5]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 3]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 3]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 0]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 0]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % 1]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 1]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 1) % -4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % -4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[1] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[1] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[-1] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[-1] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[1] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[1] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[3]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[3]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[1]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[1]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[0]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[0]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[1]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[1]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[-2]) < eps and abs(ls[1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[-2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[2] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[2] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[0] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[0] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[0] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[0] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[-1] - ls[3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[-1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[4]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[4]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[2]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[2]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[0]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[0]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[1]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[1]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps",
      "mutated_line": "return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[-3]) < eps",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[-3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) * 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) * 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[i + 1 + 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[i + 1 + 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) * 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) * 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[i + 1 + 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[i + 1 + 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 2) % 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 2) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 0) % 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 0) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + 0) % 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 0) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])",
      "mutated_line": "return all([perpendicular(vs[i], vs[(i + -1) % 4]) for i in range(4)])",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + -1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i - 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i - 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[i * 1 % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[i * 1 % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 5][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 5][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 3][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 3][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 0][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 0][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 1][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 1][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % -4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % -4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i - 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i - 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[i * 1 % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[i * 1 % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 5][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 5][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 3][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 3][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 0][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 0][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 1][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 1][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % -4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % -4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 2) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 2) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 0) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 0) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 0) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 0) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + -1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + -1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 2) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 2) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 0) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 0) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 0) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 0) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + 1) % 4][1] - cs[i][1]] for i in range(4)]",
      "mutated_line": "return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + -1) % 4][1] - cs[i][1]] for i in range(4)]",
      "code": "import itertools\nimport math\n\ndef find_square_and_rectangle_partition(points):\n    eps = 1e-08\n    idx = list(range(8))\n\n    def perpendicular(v1, v2):\n        return sum([x * y for (x, y) in zip(v1, v2)]) < eps\n\n    def all_perpendicular(vs):\n        return all([perpendicular(vs[i], vs[(i + 1) % 4]) for i in range(4)])\n\n    def rect_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        return abs(ls[0] - ls[2]) < eps and abs(ls[1] - ls[3]) < eps\n\n    def square_sides(vs):\n        ls = list(map(lambda v: math.hypot(*v), vs))\n        l = ls[0]\n        for lx in ls:\n            if abs(lx - l) > eps:\n                return False\n        return True\n\n    def coords_to_vecs(cs):\n        return [[cs[(i + 1) % 4][0] - cs[i][0], cs[(i + -1) % 4][1] - cs[i][1]] for i in range(4)]\n\n    def is_square(coords):\n        for p in itertools.permutations(coords):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and square_sides(vs):\n                return True\n        return False\n\n    def is_rect(coord):\n        for p in itertools.permutations(coord):\n            vs = coords_to_vecs(p)\n            if all_perpendicular(vs) and rect_sides(vs):\n                return True\n        return False\n    for comb in itertools.combinations(idx, 4):\n        fsi = list(comb)\n        ssi = list(set(idx) - set(comb))\n        fs = [points[i] for i in fsi]\n        ss = [points[i] for i in ssi]\n        if is_square(fs) and is_rect(ss):\n            return ([i + 1 for i in fsi], [i + 1 for i in ssi])\n        if is_square(ss) and is_rect(fs):\n            return ([i + 1 for i in ssi], [i + 1 for i in fsi])\n    return None"
    }
  ]
}