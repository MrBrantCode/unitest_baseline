{
  "task_id": "taco_17588",
  "entry_point": "min_steps_to_balance_piles",
  "mutant_count": 161,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i -= 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 2\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 0\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 0\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += -1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i >= N:",
      "mutated_line": "if i > N:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i > N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i >= N:",
      "mutated_line": "if i < N:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i < N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if i >= N:",
      "mutated_line": "if i == N:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i == N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "allcnt += A[j][1]",
      "mutated_line": "allcnt -= A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt -= A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost -= (A[j][0] - A[0][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost -= (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost -= v * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost -= v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N + 1, -1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N + 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N * 1, -1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N * 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, +1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, +1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, +1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, +1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[0][0] < K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] < K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[0][0] > K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] > K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[0][0] == K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] == K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 1\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return -1\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 1\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(allcnt, cost) = (0, 0)",
      "mutated_line": "(allcnt, cost) = (1, 0)",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (1, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(allcnt, cost) = (0, 0)",
      "mutated_line": "(allcnt, cost) = (-1, 0)",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (-1, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(allcnt, cost) = (0, 0)",
      "mutated_line": "(allcnt, cost) = (1, 0)",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (1, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(allcnt, cost) = (0, 0)",
      "mutated_line": "(allcnt, cost) = (0, 1)",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 1)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(allcnt, cost) = (0, 0)",
      "mutated_line": "(allcnt, cost) = (0, -1)",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, -1)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "(allcnt, cost) = (0, 0)",
      "mutated_line": "(allcnt, cost) = (0, 1)",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 1)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] - K) / A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) / A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += A[j][0] - A[0][0] - K + A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += A[j][0] - A[0][0] - K + A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] - K) ** A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) ** A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(N - 1):",
      "mutated_line": "for j in range(N + 1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N + 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "for j in range(N - 1):",
      "mutated_line": "for j in range(N * 1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N * 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] - A[j][0] < K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] < K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] - A[j][0] > K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] > K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] - A[j][0] == K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] == K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v / A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v / A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v + A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v + A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v ** A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v ** A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "diff = vn - v",
      "mutated_line": "diff = vn + v",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn + v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "diff = vn - v",
      "mutated_line": "diff = vn * v",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn * v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while i < N:",
      "mutated_line": "while i <= N:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i <= N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while i < N:",
      "mutated_line": "while i >= N:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i >= N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "while i < N:",
      "mutated_line": "while i != N:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i != N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 2, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 0, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 0, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - -1, -1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - -1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -2, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -2, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -0, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -0, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -0, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -0, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, --1, -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, --1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -2):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -2):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -0):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -0):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -0):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -0):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, --1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, --1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] + A[0][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] + A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] * A[0][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] * A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "allcnt += A[j][1]",
      "mutated_line": "allcnt += A[j][2]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][2]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "allcnt += A[j][1]",
      "mutated_line": "allcnt += A[j][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][0]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "allcnt += A[j][1]",
      "mutated_line": "allcnt += A[j][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][0]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "allcnt += A[j][1]",
      "mutated_line": "allcnt += A[j][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][-1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] + K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] + K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0]) * K * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0]) * K * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(N - 1):",
      "mutated_line": "for j in range(N - 2):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 2):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(N - 1):",
      "mutated_line": "for j in range(N - 0):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 0):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(N - 1):",
      "mutated_line": "for j in range(N - 0):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 0):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for j in range(N - 1):",
      "mutated_line": "for j in range(N - -1):",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - -1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] + A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] + A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] * A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] * A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = A[j][0]",
      "mutated_line": "v = A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][1]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = A[j][0]",
      "mutated_line": "v = A[j][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][-1]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "v = A[j][0]",
      "mutated_line": "v = A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][1]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + 1][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][1]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + 1][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][-1]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + 1][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][1]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][0] - vn < K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn < K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][0] - vn > K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn > K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][0] - vn == K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn == K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost += (A[i][0] - v - K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost += (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "allcnt -= A[i][1]",
      "mutated_line": "allcnt += A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt += A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i -= 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "cost -= diff * allcnt",
      "mutated_line": "cost += diff * allcnt",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost += diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] + A[0][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] + A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] * A[0][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] * A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] - K) * A[j][2]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][2]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] - K) * A[j][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][0]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] - K) * A[j][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][0]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][0] - K) * A[j][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][-1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v * A[j][2]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][2]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v * A[j][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][0]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v * A[j][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][0]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cost += v * A[j][1]",
      "mutated_line": "cost += v * A[j][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][-1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j - 1][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j - 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j * 1][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j * 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][0] + vn <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] + vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][0] * vn <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] * vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v - K) / A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) / A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= A[i][0] - v - K + A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= A[i][0] - v - K + A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v - K) ** A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) ** A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 2\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 0\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 0\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += -1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "cost -= diff * allcnt",
      "mutated_line": "cost -= diff / allcnt",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff / allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "cost -= diff * allcnt",
      "mutated_line": "cost -= diff + allcnt",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff + allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "cost -= diff * allcnt",
      "mutated_line": "cost -= diff ** allcnt",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff ** allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A.sort(key=lambda p: p[0])",
      "mutated_line": "A.sort(key=lambda p: p[1])",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[1])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A.sort(key=lambda p: p[0])",
      "mutated_line": "A.sort(key=lambda p: p[-1])",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[-1])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "A.sort(key=lambda p: p[0])",
      "mutated_line": "A.sort(key=lambda p: p[1])",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[1])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][1] - A[0][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][1] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][-1] - A[0][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][-1] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][1] - A[0][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][1] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[0][1] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][1] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[0][-1] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][-1] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[0][1] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][1] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][1] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][1] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][-1] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][-1] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][1] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][1] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] - A[j][1] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][1] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] - A[j][-1] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][-1] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 1][0] - A[j][1] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][1] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + 2][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 2][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + 0][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 0][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + 0][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 0][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "vn = A[j + 1][0]",
      "mutated_line": "vn = A[j + -1][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + -1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v + K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v + K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v) * K * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v) * K * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "allcnt -= A[i][1]",
      "mutated_line": "allcnt -= A[i][2]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][2]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "allcnt -= A[i][1]",
      "mutated_line": "allcnt -= A[i][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][0]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "allcnt -= A[i][1]",
      "mutated_line": "allcnt -= A[i][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][0]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "allcnt -= A[i][1]",
      "mutated_line": "allcnt -= A[i][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][-1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[1][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[1][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[-1][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[-1][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if A[i][0] - A[0][0] <= K:",
      "mutated_line": "if A[i][0] - A[1][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[1][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][1] - A[0][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][1] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][-1] - A[0][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][-1] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][1] - A[0][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][1] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][1] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][1] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][-1] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][-1] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[0][1] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][1] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N + 1][0] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N + 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N * 1][0] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N * 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][1] - vn <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][1] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][-1] - vn <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][-1] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if A[i][0] - vn <= K:",
      "mutated_line": "if A[i][1] - vn <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][1] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] + v - K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] + v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] * v - K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] * v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v - K) * A[i][2]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][2]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v - K) * A[i][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][0]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v - K) * A[i][0]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][0]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][0] - v - K) * A[i][-1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][-1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[1][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[1][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[-1][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[-1][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cost += (A[j][0] - A[0][0] - K) * A[j][1]",
      "mutated_line": "cost += (A[j][0] - A[1][0] - K) * A[j][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[1][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 2][0] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 2][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 0][0] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 0][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - 0][0] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 0][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if A[N - 1][0] - A[j][0] <= K:",
      "mutated_line": "if A[N - -1][0] - A[j][0] <= K:",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - -1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][0] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][1] - v - K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][1] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][-1] - v - K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][-1] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "cost -= (A[i][0] - v - K) * A[i][1]",
      "mutated_line": "cost -= (A[i][1] - v - K) * A[i][1]",
      "code": "from collections import Counter\n\ndef min_steps_to_balance_piles(N, K, A):\n    C = Counter(A)\n    A = [[v, cnt] for (v, cnt) in C.items()]\n    A.sort(key=lambda p: p[0])\n    N = len(A)\n    for i in range(N - 1, -1, -1):\n        if A[i][0] - A[0][0] <= K:\n            break\n    i += 1\n    if i >= N:\n        return 0\n    (allcnt, cost) = (0, 0)\n    for j in range(i, N):\n        allcnt += A[j][1]\n        cost += (A[j][0] - A[0][0] - K) * A[j][1]\n    ans = cost\n    for j in range(N - 1):\n        if A[N - 1][0] - A[j][0] <= K:\n            break\n        v = A[j][0]\n        cost += v * A[j][1]\n        vn = A[j + 1][0]\n        diff = vn - v\n        while i < N:\n            if A[i][0] - vn <= K:\n                cost -= (A[i][1] - v - K) * A[i][1]\n                allcnt -= A[i][1]\n                i += 1\n            else:\n                cost -= diff * allcnt\n                break\n        ans = min(ans, cost)\n    return ans"
    }
  ]
}