{
  "task_id": "taco_13404",
  "entry_point": "max_partition_score",
  "mutant_count": 16,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "best = 1",
      "mutated_line": "best = 2",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 2\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "best = 1",
      "mutated_line": "best = 0",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 0\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "best = 1",
      "mutated_line": "best = 0",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 0\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "best = 1",
      "mutated_line": "best = -1",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = -1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for num in reversed(prefix_sums[:n - 1]):",
      "mutated_line": "for num in reversed(prefix_sums[:n + 1]):",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n + 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for num in reversed(prefix_sums[:n - 1]):",
      "mutated_line": "for num in reversed(prefix_sums[:n * 1]):",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n * 1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for num in reversed(prefix_sums[:n - 1]):",
      "mutated_line": "for num in reversed(prefix_sums[:n - 2]):",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 2]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for num in reversed(prefix_sums[:n - 1]):",
      "mutated_line": "for num in reversed(prefix_sums[:n - 0]):",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 0]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for num in reversed(prefix_sums[:n - 1]):",
      "mutated_line": "for num in reversed(prefix_sums[:n - 0]):",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 0]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for num in reversed(prefix_sums[:n - 1]):",
      "mutated_line": "for num in reversed(prefix_sums[:n - -1]):",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - -1]):\n        best = max(best, gcd(prefix_sums[-1], num))\n    return best"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "best = max(best, gcd(prefix_sums[-1], num))",
      "mutated_line": "best = max(best, gcd(prefix_sums[+1], num))",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[+1], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "best = max(best, gcd(prefix_sums[-1], num))",
      "mutated_line": "best = max(best, gcd(prefix_sums[-2], num))",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-2], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "best = max(best, gcd(prefix_sums[-1], num))",
      "mutated_line": "best = max(best, gcd(prefix_sums[-0], num))",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-0], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "best = max(best, gcd(prefix_sums[-1], num))",
      "mutated_line": "best = max(best, gcd(prefix_sums[-0], num))",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[-0], num))\n    return best"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "best = max(best, gcd(prefix_sums[-1], num))",
      "mutated_line": "best = max(best, gcd(prefix_sums[--1], num))",
      "code": "from itertools import accumulate\nfrom math import gcd\n\ndef max_partition_score(n, a):\n    \"\"\"\n    Calculate the maximum possible score for the optimal partition of array `a` of length `n`.\n\n    Parameters:\n    n (int): The length of the array `a`.\n    a (list[int]): The array of integers.\n\n    Returns:\n    int: The maximum possible score for the optimal partition.\n    \"\"\"\n    prefix_sums = list(accumulate(a))\n    best = 1\n    for num in reversed(prefix_sums[:n - 1]):\n        best = max(best, gcd(prefix_sums[--1], num))\n    return best"
    }
  ]
}