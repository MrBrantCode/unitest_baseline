{
  "task_id": "taco_2766",
  "entry_point": "calculate_independent_set_sum",
  "mutant_count": 184,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244354\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244352\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 0\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 1\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = -998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ROOT = 1",
      "mutated_line": "ROOT = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 2\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ROOT = 1",
      "mutated_line": "ROOT = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 0\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ROOT = 1",
      "mutated_line": "ROOT = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 0\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ROOT = 1",
      "mutated_line": "ROOT = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = -1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] / (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] / (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] + (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] + (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] ** (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] ** (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Parent[ROOT] = n + 1",
      "mutated_line": "Parent[ROOT] = n - 1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n - 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "Parent[ROOT] = n + 1",
      "mutated_line": "Parent[ROOT] = n * 1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n * 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] / (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] / (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] + (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] + (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] ** (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] ** (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] / (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] / (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] + (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] + (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] ** (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] ** (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] / (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] / (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] + (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] + (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] ** (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] ** (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] / (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] / (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] + (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] + (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] ** (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] ** (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1] - 1) * mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) * mod"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return DP0[1] + DP2[1] - 1 + mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return DP0[1] + DP2[1] - 1 + mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] * (n - 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n - 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] * (n * 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n * 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Parent[ROOT] = n + 1",
      "mutated_line": "Parent[ROOT] = n + 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 2\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Parent[ROOT] = n + 1",
      "mutated_line": "Parent[ROOT] = n + 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 0\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Parent[ROOT] = n + 1",
      "mutated_line": "Parent[ROOT] = n + 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 0\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "Parent[ROOT] = n + 1",
      "mutated_line": "Parent[ROOT] = n + -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + -1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] * (n - 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n - 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] * (n * 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n * 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] * (n - 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n - 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] * (n * 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n * 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] * (n - 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n - 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] * (n * 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n * 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] * (n - 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n - 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] * (n * 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n * 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 1 or len(E[x]) == 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 or len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ANS0 = 1",
      "mutated_line": "ANS0 = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 2\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ANS0 = 1",
      "mutated_line": "ANS0 = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 0\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ANS0 = 1",
      "mutated_line": "ANS0 = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 0\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ANS0 = 1",
      "mutated_line": "ANS0 = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = -1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ANS2 = 1",
      "mutated_line": "ANS2 = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 2\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ANS2 = 1",
      "mutated_line": "ANS2 = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 0\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ANS2 = 1",
      "mutated_line": "ANS2 = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 0\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ANS2 = 1",
      "mutated_line": "ANS2 = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = -1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ANS3 = 1",
      "mutated_line": "ANS3 = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 2\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ANS3 = 1",
      "mutated_line": "ANS3 = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 0\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ANS3 = 1",
      "mutated_line": "ANS3 = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 0\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "ANS3 = 1",
      "mutated_line": "ANS3 = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = -1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "DP2[x] = ANS3 - ANS2",
      "mutated_line": "DP2[x] = ANS3 + ANS2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 + ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "DP2[x] = ANS3 - ANS2",
      "mutated_line": "DP2[x] = ANS3 * ANS2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 * ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1] + 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] + 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1]) * 1 % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1]) * 1 % mod"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [+1] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [+1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] * (n + 2)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 2)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 0)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 0)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-1] * (n + -1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + -1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if Parent[to] == -1:",
      "mutated_line": "if Parent[to] != -1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] != -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [2] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [2] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [0] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [0] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [-1] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [-1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] * (n + 2)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 2)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 0)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 0)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "DP0 = [1] * (n + 1)",
      "mutated_line": "DP0 = [1] * (n + -1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + -1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [2] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [2] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [0] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [0] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [-1] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [-1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] * (n + 2)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 2)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 0)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 0)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "DP1 = [1] * (n + 1)",
      "mutated_line": "DP1 = [1] * (n + -1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + -1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [2] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [2] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [0] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [0] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [-1] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [-1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] * (n + 2)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 2)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 0)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 0)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "DP2 = [1] * (n + 1)",
      "mutated_line": "DP2 = [1] * (n + -1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + -1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [2] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [2] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [0] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [0] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [-1] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [-1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] * (n + 2)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 2)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 0)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] * (n + 0)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 0)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "DP3 = [1] * (n + 1)",
      "mutated_line": "DP3 = [1] * (n + -1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + -1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "for x in TOP_SORT[::-1]:",
      "mutated_line": "for x in TOP_SORT[::+1]:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::+1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x == 1 and len(E[x]) == 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x == 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 1 and len(E[x]) != 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) != 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "DP0[x] = 1",
      "mutated_line": "DP0[x] = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 2\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "DP0[x] = 1",
      "mutated_line": "DP0[x] = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 0\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "DP0[x] = 1",
      "mutated_line": "DP0[x] = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 0\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "DP0[x] = 1",
      "mutated_line": "DP0[x] = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = -1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "DP1[x] = 1",
      "mutated_line": "DP1[x] = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 2\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "DP1[x] = 1",
      "mutated_line": "DP1[x] = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 0\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "DP1[x] = 1",
      "mutated_line": "DP1[x] = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 0\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "DP1[x] = 1",
      "mutated_line": "DP1[x] = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = -1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "DP2[x] = 0",
      "mutated_line": "DP2[x] = 1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 1\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "DP2[x] = 0",
      "mutated_line": "DP2[x] = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = -1\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "DP2[x] = 0",
      "mutated_line": "DP2[x] = 1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 1\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "DP3[x] = 1",
      "mutated_line": "DP3[x] = 2",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 2\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "DP3[x] = 1",
      "mutated_line": "DP3[x] = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 0\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "DP3[x] = 1",
      "mutated_line": "DP3[x] = 0",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 0\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "DP3[x] = 1",
      "mutated_line": "DP3[x] = -1",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = -1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if to == Parent[x]:",
      "mutated_line": "if to != Parent[x]:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to != Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) * mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) * mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) + mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) + mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) * mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) * mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) + mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) + mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) * mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) * mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) + mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) + mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] - DP2[1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] - DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] * DP2[1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] * DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1] - 2) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 2) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1] - 0) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 0) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1] - 0) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 0) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[1] - -1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - -1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n - 1)]",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n * 1)]",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-2] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-2] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-0] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [-0] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-0] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "Parent = [-1] * (n + 1)",
      "mutated_line": "Parent = [--1] * (n + 1)",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [--1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "if Parent[to] == -1:",
      "mutated_line": "if Parent[to] == +1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == +1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for x in TOP_SORT[::-1]:",
      "mutated_line": "for x in TOP_SORT[::-2]:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-2]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for x in TOP_SORT[::-1]:",
      "mutated_line": "for x in TOP_SORT[::-0]:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-0]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for x in TOP_SORT[::-1]:",
      "mutated_line": "for x in TOP_SORT[::-0]:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-0]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for x in TOP_SORT[::-1]:",
      "mutated_line": "for x in TOP_SORT[::--1]:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::--1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 2 and len(E[x]) == 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 2 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 0 and len(E[x]) == 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 0 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 0 and len(E[x]) == 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 0 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != -1 and len(E[x]) == 1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != -1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 1 and len(E[x]) == 2:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 2:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 1 and len(E[x]) == 0:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 0:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 1 and len(E[x]) == 0:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 0:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if x != 1 and len(E[x]) == 1:",
      "mutated_line": "if x != 1 and len(E[x]) == -1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == -1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 / (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 / (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = (ANS0 + (DP0[to] + DP1[to] + DP2[to] + DP3[to])) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = (ANS0 + (DP0[to] + DP1[to] + DP2[to] + DP3[to])) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 ** (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 ** (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = ANS2 / (DP0[to] + DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 / (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = (ANS2 + (DP0[to] + DP2[to])) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = (ANS2 + (DP0[to] + DP2[to])) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = ANS2 ** (DP0[to] + DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 ** (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 / (DP0[to] + DP1[to] + DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 / (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = (ANS3 + (DP0[to] + DP1[to] + DP2[to])) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = (ANS3 + (DP0[to] + DP1[to] + DP2[to])) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 ** (DP0[to] + DP1[to] + DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 ** (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + 2)]",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + 0)]",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + 0)]",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "E = [[] for _ in range(n + 1)]",
      "mutated_line": "E = [[] for _ in range(n + -1)]",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if Parent[to] == -1:",
      "mutated_line": "if Parent[to] == -2:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -2:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if Parent[to] == -1:",
      "mutated_line": "if Parent[to] == -0:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -0:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if Parent[to] == -1:",
      "mutated_line": "if Parent[to] == -0:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -0:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if Parent[to] == -1:",
      "mutated_line": "if Parent[to] == --1:",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == --1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] - DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] - DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * ((DP0[to] + DP1[to] + DP2[to]) * DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * ((DP0[to] + DP1[to] + DP2[to]) * DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = ANS2 * (DP0[to] - DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] - DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod",
      "mutated_line": "ANS2 = ANS2 * (DP0[to] * DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] * DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] - DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] - DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 * ((DP0[to] + DP1[to]) * DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * ((DP0[to] + DP1[to]) * DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[2] + DP2[1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[2] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[0] + DP2[1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[0] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[0] + DP2[1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[0] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[-1] + DP2[1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[-1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[2] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[2] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[0] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[0] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[0] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[0] - 1) % mod"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return (DP0[1] + DP2[1] - 1) % mod",
      "mutated_line": "return (DP0[1] + DP2[-1] - 1) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[-1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] - DP2[to] + DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] - DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * ((DP0[to] + DP1[to]) * DP2[to] + DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * ((DP0[to] + DP1[to]) * DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 * (DP0[to] - DP1[to] + DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] - DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod",
      "mutated_line": "ANS3 = ANS3 * (DP0[to] * DP1[to] + DP2[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] * DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * (DP0[to] - DP1[to] + DP2[to] + DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] - DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "ANS0 = ANS0 * (DP0[to] + DP1[to] + DP2[to] + DP3[to]) % mod",
      "mutated_line": "ANS0 = ANS0 * (DP0[to] * DP1[to] + DP2[to] + DP3[to]) % mod",
      "code": "def calculate_independent_set_sum(n, edges):\n    mod = 998244353\n    E = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        E[u].append(v)\n        E[v].append(u)\n    ROOT = 1\n    QUE = [ROOT]\n    Parent = [-1] * (n + 1)\n    Parent[ROOT] = n + 1\n    TOP_SORT = []\n    while QUE:\n        x = QUE.pop()\n        TOP_SORT.append(x)\n        for to in E[x]:\n            if Parent[to] == -1:\n                Parent[to] = x\n                QUE.append(to)\n    DP0 = [1] * (n + 1)\n    DP1 = [1] * (n + 1)\n    DP2 = [1] * (n + 1)\n    DP3 = [1] * (n + 1)\n    for x in TOP_SORT[::-1]:\n        if x != 1 and len(E[x]) == 1:\n            DP0[x] = 1\n            DP1[x] = 1\n            DP2[x] = 0\n            DP3[x] = 1\n            continue\n        ANS0 = 1\n        ANS2 = 1\n        ANS3 = 1\n        for to in E[x]:\n            if to == Parent[x]:\n                continue\n            ANS0 = ANS0 * (DP0[to] * DP1[to] + DP2[to] + DP3[to]) % mod\n            ANS2 = ANS2 * (DP0[to] + DP2[to]) % mod\n            ANS3 = ANS3 * (DP0[to] + DP1[to] + DP2[to]) % mod\n        DP0[x] = ANS0\n        DP1[x] = ANS0\n        DP2[x] = ANS3 - ANS2\n        DP3[x] = ANS3\n    return (DP0[1] + DP2[1] - 1) % mod"
    }
  ]
}