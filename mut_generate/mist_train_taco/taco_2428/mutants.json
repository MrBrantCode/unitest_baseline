{
  "task_id": "taco_2428",
  "entry_point": "process_queries",
  "mutant_count": 89,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] != 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] != 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[1]] -= 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] -= 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "counts = collections.defaultdict(lambda: 0)",
      "mutated_line": "counts = collections.defaultdict(lambda : 1)",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 1)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "counts = collections.defaultdict(lambda: 0)",
      "mutated_line": "counts = collections.defaultdict(lambda : -1)",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : -1)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "counts = collections.defaultdict(lambda: 0)",
      "mutated_line": "counts = collections.defaultdict(lambda : 1)",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 1)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 2:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 0:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 0:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == 0:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 0:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[0] == -1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == -1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[1]] += 2",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 2\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[1]] += 0",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 0\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[1]] += 0",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 0\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[1]] += -1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += -1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] != 2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] != 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[1] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[1] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[-1] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[-1] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if query[0] == 1:",
      "mutated_line": "if query[1] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[1] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "heapq.heappush(max_q, -query[1])",
      "mutated_line": "heapq.heappush(max_q, +query[1])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, +query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 3:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 1:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 0:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 0:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 1:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[0] == -2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == -2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[1]] += 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] += 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[0] != 3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] != 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[2]] += 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[2]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[0]] += 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[0]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[0]] += 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[0]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "counts[query[1]] += 1",
      "mutated_line": "counts[query[-1]] += 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[-1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(min_q, query[1])",
      "mutated_line": "heapq.heappush(min_q, query[2])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[2])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(min_q, query[1])",
      "mutated_line": "heapq.heappush(min_q, query[0])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[0])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(min_q, query[1])",
      "mutated_line": "heapq.heappush(min_q, query[0])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[0])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "heapq.heappush(min_q, query[1])",
      "mutated_line": "heapq.heappush(min_q, query[-1])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[-1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[1] == 2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[1] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[-1] == 2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[-1] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif query[0] == 2:",
      "mutated_line": "elif query[1] == 2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[1] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[1]] -= 2",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 2\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[1]] -= 0",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 0\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[1]] -= 0",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 0\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[1]] -= -1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= -1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[0] == 4:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 4:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[0] == 2:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 2:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[0] == 0:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 0:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[0] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 1:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[0] == -3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == -3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "while len(max_q) and not counts[-max_q[0]]:",
      "mutated_line": "while len(max_q) or not counts[-max_q[0]]:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) or not counts[-max_q[0]]:\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[0] != 4:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] != 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(max_q, -query[1])",
      "mutated_line": "heapq.heappush(max_q, -query[2])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[2])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(max_q, -query[1])",
      "mutated_line": "heapq.heappush(max_q, -query[0])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[0])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(max_q, -query[1])",
      "mutated_line": "heapq.heappush(max_q, -query[0])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[0])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "heapq.heappush(max_q, -query[1])",
      "mutated_line": "heapq.heappush(max_q, -query[-1])",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[-1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res.append(\"-1\")",
      "mutated_line": "res.append('')",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[1] == 3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[1] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[-1] == 3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[-1] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "elif query[0] == 3:",
      "mutated_line": "elif query[1] == 3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[1] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[0] == 5:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 5:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[0] == 3:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 3:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[0] == 0:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 0:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[0] == 1:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 1:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[0] == -4:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == -4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "while len(min_q) and not counts[min_q[0]]:",
      "mutated_line": "while len(min_q) or not counts[min_q[0]]:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) or not counts[min_q[0]]:\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not counts[query[1]]:",
      "mutated_line": "if not counts[query[2]]:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[2]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not counts[query[1]]:",
      "mutated_line": "if not counts[query[0]]:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[0]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not counts[query[1]]:",
      "mutated_line": "if not counts[query[0]]:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[0]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if not counts[query[1]]:",
      "mutated_line": "if not counts[query[-1]]:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[-1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[2]] -= 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[2]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[0]] -= 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[0]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[0]] -= 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[0]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "counts[query[1]] -= 1",
      "mutated_line": "counts[query[-1]] -= 1",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[-1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res.append(\"-1\")",
      "mutated_line": "res.append('')",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[1] == 4:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[1] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[-1] == 4:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[-1] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "elif query[0] == 4:",
      "mutated_line": "elif query[1] == 4:",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[1] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "while len(max_q) and not counts[-max_q[0]]:",
      "mutated_line": "while len(max_q) and (not counts[+max_q[0]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[+max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "res.append(str(-max_q[0]))",
      "mutated_line": "res.append(str(+max_q[0]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(+max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "res.append(\"-1\")",
      "mutated_line": "res.append('')",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(max_q) and not counts[-max_q[0]]:",
      "mutated_line": "while len(max_q) and (not counts[-max_q[1]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[1]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(max_q) and not counts[-max_q[0]]:",
      "mutated_line": "while len(max_q) and (not counts[-max_q[-1]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[-1]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while len(max_q) and not counts[-max_q[0]]:",
      "mutated_line": "while len(max_q) and (not counts[-max_q[1]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[1]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res.append(str(-max_q[0]))",
      "mutated_line": "res.append(str(-max_q[1]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[1]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res.append(str(-max_q[0]))",
      "mutated_line": "res.append(str(-max_q[-1]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[-1]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res.append(str(-max_q[0]))",
      "mutated_line": "res.append(str(-max_q[1]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[1]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(min_q) and not counts[min_q[0]]:",
      "mutated_line": "while len(min_q) and (not counts[min_q[1]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[1]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(min_q) and not counts[min_q[0]]:",
      "mutated_line": "while len(min_q) and (not counts[min_q[-1]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[-1]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "while len(min_q) and not counts[min_q[0]]:",
      "mutated_line": "while len(min_q) and (not counts[min_q[1]]):",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[1]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[0]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res.append(str(min_q[0]))",
      "mutated_line": "res.append(str(min_q[1]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[1]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res.append(str(min_q[0]))",
      "mutated_line": "res.append(str(min_q[-1]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[-1]))\n            else:\n                res.append('-1')\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "res.append(str(min_q[0]))",
      "mutated_line": "res.append(str(min_q[1]))",
      "code": "import collections\nimport heapq\n\ndef process_queries(queries):\n    \"\"\"\n    Process a list of queries on an array and return the results of queries 3 and 4.\n\n    Parameters:\n    queries (list of lists): A list where each element is a list representing a query.\n                             Each query list contains two integers:\n                             - The first integer is the type of query (1, 2, 3, or 4).\n                             - The second integer (if applicable) is the value X.\n\n    Returns:\n    list of str: A list of strings where each string is the result of a query 3 or 4.\n                 If the array is empty for query 3 or 4, the result is \"-1\".\n    \"\"\"\n    res = []\n    counts = collections.defaultdict(lambda : 0)\n    min_q = []\n    max_q = []\n    for query in queries:\n        if query[0] == 1:\n            counts[query[1]] += 1\n            heapq.heappush(min_q, query[1])\n            heapq.heappush(max_q, -query[1])\n        elif query[0] == 2:\n            if not counts[query[1]]:\n                res.append('-1')\n            else:\n                counts[query[1]] -= 1\n        elif query[0] == 3:\n            while len(max_q) and (not counts[-max_q[0]]):\n                heapq.heappop(max_q)\n            if len(max_q):\n                res.append(str(-max_q[0]))\n            else:\n                res.append('-1')\n        elif query[0] == 4:\n            while len(min_q) and (not counts[min_q[0]]):\n                heapq.heappop(min_q)\n            if len(min_q):\n                res.append(str(min_q[1]))\n            else:\n                res.append('-1')\n    return res"
    }
  ]
}