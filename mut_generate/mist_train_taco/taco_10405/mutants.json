{
  "task_id": "taco_10405",
  "entry_point": "count_queen_placements",
  "mutant_count": 141,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000008",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000008\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1000000006",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000006\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 0\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 1000000007",
      "mutated_line": "mod = -1000000007",
      "code": "def count_queen_placements(test_cases):\n    mod = -1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans -= 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 1\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = 0",
      "mutated_line": "y = -1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = -1\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = 0",
      "mutated_line": "y = 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 1\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y or mx[y] == (1 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y or mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "y += 1",
      "mutated_line": "y -= 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y -= 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if y == Y:",
      "mutated_line": "if y != Y:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y != Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "free = 0",
      "mutated_line": "free = 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 1\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "free = 0",
      "mutated_line": "free = -1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = -1\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "free = 0",
      "mutated_line": "free = 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 1\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 1 << free == 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free == 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "free += 1",
      "mutated_line": "free -= 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free -= 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if free >= X:",
      "mutated_line": "if free > X:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free > X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if free >= X:",
      "mutated_line": "if free < X:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free < X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if free >= X:",
      "mutated_line": "if free == X:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free == X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if free_x is None:",
      "mutated_line": "if free_x is not None:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is not None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 2\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 0\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 0\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += -1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if free_x is not None:",
      "mutated_line": "if free_x is None:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "ans += rec(nmx, X, Y)",
      "mutated_line": "ans -= rec(nmx, X, Y)",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans -= rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return ans % mod",
      "mutated_line": "return ans * mod",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans * mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "return ans % mod",
      "mutated_line": "return ans + mod",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans + mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if arg not in pool:",
      "mutated_line": "if arg in pool:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X or 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X or 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x == 0 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x == 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else False",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else False\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y <= Y and mx[y] == (1 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y <= Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y >= Y and mx[y] == (1 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y >= Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y != Y and mx[y] == (1 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y != Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] != (1 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] != (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y += 1",
      "mutated_line": "y += 2",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 2\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y += 1",
      "mutated_line": "y += 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 0\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y += 1",
      "mutated_line": "y += 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 0\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "y += 1",
      "mutated_line": "y += -1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += -1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] | 1 << free != 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] | 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 1 << free != 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 1:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 1 << free != -1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != -1:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 1 << free != 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 1:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "free += 1",
      "mutated_line": "free += 2",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 2\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "free += 1",
      "mutated_line": "free += 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 0\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "free += 1",
      "mutated_line": "free += 0",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 0\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "free += 1",
      "mutated_line": "free += -1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += -1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [+1, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [+1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, 1, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 1, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, -1, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, -1, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, 1, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 1, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, 0, 2]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 2]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, 0, 0]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 0]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, 0, 0]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 0]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-1, 0, -1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, -1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 1\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return -1\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 1\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "imx[free_y] |= 1 << free_x",
      "mutated_line": "imx[free_y] |= 2 << free_x",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 2 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "imx[free_y] |= 1 << free_x",
      "mutated_line": "imx[free_y] |= 0 << free_x",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 0 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "imx[free_y] |= 1 << free_x",
      "mutated_line": "imx[free_y] |= 0 << free_x",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 0 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "imx[free_y] |= 1 << free_x",
      "mutated_line": "imx[free_y] |= -1 << free_x",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= -1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 < x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 < x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 > x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 > x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 == x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 == x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 < y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 < y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 > y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 > y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 == y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 == y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] | 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] | 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 1 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 1 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != -1 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != -1 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 1 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 1 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (1 << X) + 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) + 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (1 << X) * 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) * 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-2, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-2, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-0, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-0, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [-0, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-0, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "for dx in [-1, 0, 1]:",
      "mutated_line": "for dx in [--1, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [--1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [+1, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [+1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, 1, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 1, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, -1, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, -1, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, 1, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 1, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, 0, 2]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 2]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, 0, 0]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 0]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, 0, 0]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 0]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-1, 0, -1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, -1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 0 or dy == 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 or dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 3) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 3) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 0) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 0) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 1) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), -2) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), -2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 1 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 1 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if -1 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if -1 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 1 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 1 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 1 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 1 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and -1 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and -1 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 1 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 1 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (1 << X) - 2:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 2:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (1 << X) - 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 0:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (1 << X) - 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 0:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (1 << X) - -1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - -1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 2 << free != 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 2 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 0 << free != 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 0 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & 0 << free != 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 0 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "while mx[y] & 1 << free != 0:",
      "mutated_line": "while mx[y] & -1 << free != 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & -1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-2, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-2, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-0, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-0, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [-0, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-0, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for dy in [-1, 0, 1]:",
      "mutated_line": "for dy in [--1, 0, 1]:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [--1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx != 0 and dy == 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx != 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 0 and dy != 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy != 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 2 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 2 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 0 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 0 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & 0 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 0 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "mutated_line": "return mx[y] & -1 << x != 0 if 0 <= x < X and 0 <= y < Y else True",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & -1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (2 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (2 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (0 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (0 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (0 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (0 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while y < Y and mx[y] == (1 << X) - 1:",
      "mutated_line": "while y < Y and mx[y] == (-1 << X) - 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (-1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 1 and dy == 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 1 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == -1 and dy == 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == -1 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 1 and dy == 0:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 1 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 0 and dy == 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 1:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 0 and dy == -1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == -1:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if dx == 0 and dy == 0:",
      "mutated_line": "if dx == 0 and dy == 1:",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 1:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "nmx[cy] |= 1 << cx",
      "mutated_line": "nmx[cy] |= 2 << cx",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 2 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "nmx[cy] |= 1 << cx",
      "mutated_line": "nmx[cy] |= 0 << cx",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 0 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "nmx[cy] |= 1 << cx",
      "mutated_line": "nmx[cy] |= 0 << cx",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 0 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "nmx[cy] |= 1 << cx",
      "mutated_line": "nmx[cy] |= -1 << cx",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= -1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(cx, cy) = (cx + dx, cy + dy)",
      "mutated_line": "(cx, cy) = (cx - dx, cy + dy)",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx - dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(cx, cy) = (cx + dx, cy + dy)",
      "mutated_line": "(cx, cy) = (cx * dx, cy + dy)",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx * dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(cx, cy) = (cx + dx, cy + dy)",
      "mutated_line": "(cx, cy) = (cx + dx, cy - dy)",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy - dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "(cx, cy) = (cx + dx, cy + dy)",
      "mutated_line": "(cx, cy) = (cx + dx, cy * dy)",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy * dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int('MUTATED'.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int('MUTATED'.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c != '.' else '1' for c in row)), 2) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c != '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('' if c == '.' else '1' for c in row)), 2) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('' if c == '.' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '.' else '' for c in row)), 2) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '.' else '' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "mx = [int(''.join(('0' if c == '.' else '1' for c in row)), 2) for row in board]",
      "mutated_line": "mx = [int(''.join(('0' if c == '' else '1' for c in row)), 2) for row in board]",
      "code": "def count_queen_placements(test_cases):\n    mod = 1000000007\n\n    def memoize(func):\n        pool = {}\n\n        def wrapper(*arg):\n            if arg not in pool:\n                pool[arg] = func(*arg)\n            return pool[arg]\n        return wrapper\n\n    def is_wall(x, y, mx, X, Y):\n        return mx[y] & 1 << x != 0 if 0 <= x < X and 0 <= y < Y else True\n\n    def get_free(mx, X, Y):\n        y = 0\n        while y < Y and mx[y] == (1 << X) - 1:\n            y += 1\n        if y == Y:\n            return (None, None)\n        free = 0\n        while mx[y] & 1 << free != 0:\n            free += 1\n        if free >= X:\n            return (None, None)\n        return (free, y)\n\n    def place_queen(x, y, mx, X, Y):\n        nmx = list(mx)\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                (cx, cy) = (x, y)\n                while not is_wall(cx, cy, nmx, X, Y):\n                    nmx[cy] |= 1 << cx\n                    (cx, cy) = (cx + dx, cy + dy)\n        return tuple(nmx)\n\n    @memoize\n    def rec(mx, X, Y):\n        (free_x, free_y) = get_free(mx, X, Y)\n        if free_x is None:\n            return 0\n        imx = list(mx)\n        imx[free_y] |= 1 << free_x\n        ans = rec(tuple(imx), X, Y)\n        nmx = place_queen(free_x, free_y, mx, X, Y)\n        ans += 1\n        (free_x, free_y) = get_free(nmx, X, Y)\n        if free_x is not None:\n            ans += rec(nmx, X, Y)\n        return ans % mod\n    results = []\n    for (N, M, board) in test_cases:\n        mx = [int(''.join(('0' if c == '' else '1' for c in row)), 2) for row in board]\n        results.append(rec(tuple(mx), M, N))\n    return results"
    }
  ]
}