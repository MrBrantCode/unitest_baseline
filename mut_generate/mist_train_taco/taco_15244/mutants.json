{
  "task_id": "taco_15244",
  "entry_point": "generate_minimal_unique_substring_string",
  "mutant_count": 21,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "strr = ''",
      "mutated_line": "strr = 'MUTATED'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = 'MUTATED'\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while len(strr) < n:",
      "mutated_line": "while len(strr) <= n:",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) <= n:\n        strr += '0' * ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while len(strr) < n:",
      "mutated_line": "while len(strr) >= n:",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) >= n:\n        strr += '0' * ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "while len(strr) < n:",
      "mutated_line": "while len(strr) != n:",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) != n:\n        strr += '0' * ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr -= '0' * ((n - k) // 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr -= '0' * ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 2) - '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 2) - '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 2) * '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 2) * '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' / ((n - k) // 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' / ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' + (n - k) // 2 + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' + (n - k) // 2 + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' ** ((n - k) // 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' ** ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 2) + ''",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 2) + ''\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '' * ((n - k) // 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '' * ((n - k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) / 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) / 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) * 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) * 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n + k) // 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n + k) // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * (n * k // 2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * (n * k // 2) + '1'\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 3) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 3) + '1'\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 1) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 1) + '1'\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 0) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 0) + '1'\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // 1) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // 1) + '1'\n    return strr[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "strr += '0' * ((n - k) // 2) + '1'",
      "mutated_line": "strr += '0' * ((n - k) // -2) + '1'",
      "code": "def generate_minimal_unique_substring_string(n: int, k: int) -> str:\n    strr = ''\n    while len(strr) < n:\n        strr += '0' * ((n - k) // -2) + '1'\n    return strr[:n]"
    }
  ]
}