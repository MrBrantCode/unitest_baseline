{
  "task_id": "taco_8783",
  "entry_point": "analyze_black_king_positions",
  "mutant_count": 267,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "fullCover = getCoveredPos(Q, K) | kCover",
      "mutated_line": "fullCover = getCoveredPos(Q, K) & kCover",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) & kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "fullCover = getCoveredPos(Q, K) | kCover",
      "mutated_line": "fullCover = getCoveredPos(Q, K) ^ kCover",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) ^ kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "freeQueen = Q not in kCover",
      "mutated_line": "freeQueen = Q in kCover",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] / 4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] / 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] + 4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] + 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] ** 4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] ** 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(2, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(2, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(0, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(0, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(0, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(0, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(-1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(-1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 2), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 2), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 0), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 0), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 0), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 0), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, -1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, -1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (1, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (1, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (-1, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (-1, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (1, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (1, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 2), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 2), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 0), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 0), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 0), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 0), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, -1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, -1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (2, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (2, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (0, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (0, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (0, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (0, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (-1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (-1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, -1), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, -1), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (+1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (+1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 1), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 1), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, -1), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, -1), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 1), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 1), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (1, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (1, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (-1, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (1, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (1, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, +1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, +1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (+1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (+1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 2), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 2), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 0), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 0), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 0), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 0), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, -1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, -1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (2, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (2, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (0, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (0, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (0, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (0, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (-1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (-1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, +1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, +1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (+1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (+1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, +1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, +1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(2, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(2, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(0, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(0, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(0, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(0, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(-1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(-1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 3), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 3), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 1), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 1), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 0), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 0), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 1), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 1), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, -2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, -2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (3, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (3, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (1, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (1, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (0, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (0, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (1, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (1, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (-2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (-2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 2), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 2), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 0), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 0), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 0), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 0), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, -1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, -1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (+1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (+1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 3), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 3), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 1), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 1), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 0), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 0), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 1), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 1), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, -2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, -2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (3, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (3, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (1, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (1, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (0, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (0, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (1, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (1, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (-2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (-2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, +1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, +1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (2, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (2, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (0, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (0, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (0, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (0, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (-1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (-1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, +2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, +2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (+2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (+2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 2), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 2), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 0), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 0), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 0), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 0), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, -1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (+1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (+1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, +2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, +2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (+2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (+2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, +1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, +1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 or 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 or 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] * 5",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 5\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] * 3",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 3\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] * 0",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 0\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] * 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 1\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [0] * -4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * -4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for x in range(8):",
      "mutated_line": "for x in range(9):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(9):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for x in range(8):",
      "mutated_line": "for x in range(7):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(7):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for x in range(8):",
      "mutated_line": "for x in range(0):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(0):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for x in range(8):",
      "mutated_line": "for x in range(1):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(1):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "for x in range(8):",
      "mutated_line": "for x in range(-8):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(-8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) + safePosAround] -= 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] -= 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-2, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-2, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-0, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-0, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-0, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-0, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (--1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (--1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -2), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -2), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -0), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -0), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -0), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -0), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, --1), (-1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, --1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-2, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-2, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-0, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-0, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-0, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-0, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (--1, 1), (1, -1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (--1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -2), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -2), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -0), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -0), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -0), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -0), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, --1), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, --1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-2, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-0, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-0, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-0, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-0, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (--1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (--1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -2)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -2)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -0)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -0)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -0)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -0)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]",
      "mutated_line": "ALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, --1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, --1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-2, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-2, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-0, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-0, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-0, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-0, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (--1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (--1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -2), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -2), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -0), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -0), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -0), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -0), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, --1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, --1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -3), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -3), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -1), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -1), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -0), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -0), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -1), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -1), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, --2), (-2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, --2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-3, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-3, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-1, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-1, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-0, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-0, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-1, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-1, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (--2, 1), (-1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (--2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-2, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-2, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-0, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-0, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-0, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-0, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (--1, -2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (--1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -3), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -3), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -1), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -1), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -0), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -0), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -1), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -1), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, --2), (-2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, --2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-3, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-3, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-1, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-0, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-0, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-1, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-1, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (--2, -1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (--2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -2)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -2)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -0)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -0)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -0)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -0)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]",
      "mutated_line": "AMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, --1)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, --1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 < x < 8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 < x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 > x < 8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 > x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 == x < 8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 == x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 < y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 < y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 > y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 > y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 == y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 == y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) + 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) + 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) * 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) * 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) + 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) + 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) * 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) * 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [1] * 4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [1] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [-1] * 4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [-1] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "counts = [0] * 4",
      "mutated_line": "counts = [1] * 4",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [1] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for y in range(8):",
      "mutated_line": "for y in range(9):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(9):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for y in range(8):",
      "mutated_line": "for y in range(7):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(7):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for y in range(8):",
      "mutated_line": "for y in range(0):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(0):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for y in range(8):",
      "mutated_line": "for y in range(1):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(1):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for y in range(8):",
      "mutated_line": "for y in range(-8):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(-8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if black in kCover or black == Q:",
      "mutated_line": "if black in kCover and black == Q:",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover and black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) + safePosAround] += 2",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 2\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) + safePosAround] += 0",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 0\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) + safePosAround] += 0",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 0\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) + safePosAround] += -1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += -1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 1 <= x < 8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 1 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return -1 <= x < 8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return -1 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 1 <= x < 8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 1 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 9 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 9 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 7 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 7 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 0 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 0 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 1 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 1 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < -8 and 0 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < -8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 1 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 1 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and -1 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and -1 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 1 <= y < 8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 1 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 <= y < 9",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 9\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 <= y < 7",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 7\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 <= y < 0",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 0\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 <= y < 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 1\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0 <= x < 8 and 0 <= y < 8",
      "mutated_line": "return 0 <= x < 8 and 0 <= y < -8",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < -8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 98, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 98, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 96, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 96, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 0, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 0, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 1, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 1, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - -97, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - -97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 50) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 50) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 48) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 48) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 0) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 0) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 1) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 1) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - -49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - -49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if black in kCover or black == Q:",
      "mutated_line": "if black not in kCover or black == Q:",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black not in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if black in kCover or black == Q:",
      "mutated_line": "if black in kCover or black != Q:",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black != Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) - safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) - safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black not in fullCover) * safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) * safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "pos = tuple((z + dz for (z, dz) in zip(start, m)))",
      "mutated_line": "pos = tuple((z - dz for (z, dz) in zip(start, m)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z - dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "pos = tuple((z + dz for (z, dz) in zip(start, m)))",
      "mutated_line": "pos = tuple((z * dz for (z, dz) in zip(start, m)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z * dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for n in count(1):",
      "mutated_line": "for n in count(2):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(2):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for n in count(1):",
      "mutated_line": "for n in count(0):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(0):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for n in count(1):",
      "mutated_line": "for n in count(0):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(0):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for n in count(1):",
      "mutated_line": "for n in count(-1):",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(-1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if not posInBoard(*pos) or pos == king:",
      "mutated_line": "if not posInBoard(*pos) and pos == king:",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) and pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) or (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) or (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 / (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 / (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 + (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 + (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 ** (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 ** (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] - dx * n, start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] - dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] * (dx * n), start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] * (dx * n), start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[1] - dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] - dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[1] * (dy * n))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] * (dy * n))\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if not posInBoard(*pos) or pos == king:",
      "mutated_line": "if not posInBoard(*pos) or pos != king:",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos != king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[1]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[1]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[-1]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[-1]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[1]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[1]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[2]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[2]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[0]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[0]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[0]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[0]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]",
      "mutated_line": "(K, Q) = [(ord(s[0]) - 97, ord(s[-1]) - 49) for s in (king, amazon)]",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[-1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover and (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover and (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[3 * (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[3 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[1 * (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[1 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[0 * (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[0 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[1 * (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[1 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[-2 * (black not in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[-2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "counts[2 * (black not in fullCover) + safePosAround] += 1",
      "mutated_line": "counts[2 * (black in fullCover) + safePosAround] += 1",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx / n, start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx / n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + (dx + n), start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + (dx + n), start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx ** n, start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx ** n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[1] + dy / n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy / n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[1] + (dy + n))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + (dy + n))\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[1] + dy ** n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy ** n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q or freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q or freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[1] + dx * n, start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[1] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[-1] + dx * n, start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[-1] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[1] + dx * n, start[1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[1] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[2] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[2] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[0] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[0] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[0] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[0] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "pos = (start[0] + dx * n, start[1] + dy * n)",
      "mutated_line": "pos = (start[0] + dx * n, start[-1] + dy * n)",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[-1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh != Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh != Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x - dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x - dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x * dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x * dx, y + dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y - dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y - dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y + dy) for (dx, dy) in ALL_MOVES)))",
      "mutated_line": "safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y * dy) for (dx, dy) in ALL_MOVES)))",
      "code": "from itertools import count\nALL_MOVES = [(1, 1), (0, 1), (1, 0), (-1, 0), (0, -1), (-1, 1), (1, -1), (-1, -1)]\nAMA_MOVES = [(1, 2), (2, 1), (-1, 2), (2, -1), (1, -2), (-2, 1), (-1, -2), (-2, -1)]\n\ndef analyze_black_king_positions(king: str, amazon: str) -> list[int]:\n\n    def posInBoard(x, y):\n        return 0 <= x < 8 and 0 <= y < 8\n\n    def getCoveredPos(start, king=None):\n        covered = {start}\n        for m in AMA_MOVES if king else ALL_MOVES:\n            pos = tuple((z + dz for (z, dz) in zip(start, m)))\n            if posInBoard(*pos):\n                covered.add(pos)\n        if king:\n            for (dx, dy) in ALL_MOVES:\n                for n in count(1):\n                    pos = (start[0] + dx * n, start[1] + dy * n)\n                    if not posInBoard(*pos) or pos == king:\n                        break\n                    covered.add(pos)\n        return covered\n    (K, Q) = [(ord(s[0]) - 97, ord(s[1]) - 49) for s in (king, amazon)]\n    kCover = getCoveredPos(K)\n    fullCover = getCoveredPos(Q, K) | kCover\n    freeQueen = Q not in kCover\n    counts = [0] * 4\n    for x in range(8):\n        for y in range(8):\n            black = (x, y)\n            if black in kCover or black == Q:\n                continue\n            safePosAround = any((posInBoard(*neigh) and (neigh not in fullCover or (neigh == Q and freeQueen)) for neigh in ((x + dx, y * dy) for (dx, dy) in ALL_MOVES)))\n            counts[2 * (black not in fullCover) + safePosAround] += 1\n    return counts"
    }
  ]
}