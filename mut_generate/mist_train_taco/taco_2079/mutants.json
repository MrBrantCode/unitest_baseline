{
  "task_id": "taco_2079",
  "entry_point": "calculate_dish_qualities",
  "mutant_count": 192,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 - 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 * 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] / N",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] / N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] + N",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] + N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [0] ** N",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] ** N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sum_of_qualities = 0",
      "mutated_line": "sum_of_qualities = 1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 1\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sum_of_qualities = 0",
      "mutated_line": "sum_of_qualities = -1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = -1\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "sum_of_qualities = 0",
      "mutated_line": "sum_of_qualities = 1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 1\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "product_of_qualities = 1",
      "mutated_line": "product_of_qualities = 2",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 2\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "product_of_qualities = 1",
      "mutated_line": "product_of_qualities = 0",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 0\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "product_of_qualities = 1",
      "mutated_line": "product_of_qualities = 0",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 0\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "product_of_qualities = 1",
      "mutated_line": "product_of_qualities = -1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = -1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ASR",
      "lineno": 40,
      "original_line": "sum_of_qualities += z",
      "mutated_line": "sum_of_qualities -= z",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities -= z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 * 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 + 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 8\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 6\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 0\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 1\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + -7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[0] = A1",
      "mutated_line": "A[1] = A1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[1] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[0] = A1",
      "mutated_line": "A[-1] = A1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[-1] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[0] = A1",
      "mutated_line": "A[1] = A1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[1] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(2, N):",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(2, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(0, N):",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(0, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(0, N):",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(0, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for x in range(1, N):",
      "mutated_line": "for x in range(-1, N):",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(-1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + 1, s) < r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) < r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + 1, s) > r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) > r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + 1, s) == r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) == r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = [None] * n",
      "mutated_line": "ans = [None] / n",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] / n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = [None] * n",
      "mutated_line": "ans = [None] + n",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] + n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "ans = [None] * n",
      "mutated_line": "ans = [None] ** n",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] ** n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = (La * L1 + Lc) * Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) * Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = La * L1 + Lc + Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = La * L1 + Lc + Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = (Da * D1 + Dc) * Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) * Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = Da * D1 + Dc + Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = Da * D1 + Dc + Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L = L1 + 1",
      "mutated_line": "L = L1 - 1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 - 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "L = L1 + 1",
      "mutated_line": "L = L1 * 1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 * 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "product_of_qualities = product_of_qualities * z % mod",
      "mutated_line": "product_of_qualities = product_of_qualities * z * mod",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z * mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "product_of_qualities = product_of_qualities * z % mod",
      "mutated_line": "product_of_qualities = product_of_qualities * z + mod",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z + mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 11 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 9 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 0 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 1 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = -10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 10 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 8 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 0 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 1 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10**9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** -9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [1] * N",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [1] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [-1] * N",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [-1] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "A = [0] * N",
      "mutated_line": "A = [1] * N",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [1] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) * m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) * m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = a * pow(A[x - 1], 2, m) + b * A[x - 1] + c + m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = a * pow(A[x - 1], 2, m) + b * A[x - 1] + c + m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) * m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) * m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = d * pow(A[x - 1], 2, m) + e * A[x - 1] + f + m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = d * pow(A[x - 1], 2, m) + e * A[x - 1] + f + m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque or deque[-1] > arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque or deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k or arr[i - k] == deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k or arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i > k - 1:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i > k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i < k - 1:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i < k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i == k - 1:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i == k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = (La * L1 - Lc) % Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 - Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = La * L1 * Lc % Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = La * L1 * Lc % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = (Da * D1 - Dc) % Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 - Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = Da * D1 * Dc % Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = Da * D1 * Dc % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L = L1 + 1",
      "mutated_line": "L = L1 + 2",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 2\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L = L1 + 1",
      "mutated_line": "L = L1 + 0",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 0\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L = L1 + 1",
      "mutated_line": "L = L1 + 0",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 0\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "L = L1 + 1",
      "mutated_line": "L = L1 + -1",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + -1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L + K - 1 - D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 - D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min((L + K - 1) * D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min((L + K - 1) * D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "product_of_qualities = product_of_qualities * z % mod",
      "mutated_line": "product_of_qualities = product_of_qualities / z % mod",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities / z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "product_of_qualities = product_of_qualities * z % mod",
      "mutated_line": "product_of_qualities = (product_of_qualities + z) % mod",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = (product_of_qualities + z) % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "product_of_qualities = product_of_qualities * z % mod",
      "mutated_line": "product_of_qualities = product_of_qualities ** z % mod",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities ** z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x - 1, s) <= r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x - 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x * 1, s) <= r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x * 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] - c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] - c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1]) * c % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1]) * c % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] - f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] - f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1]) * f % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1]) * f % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[-1] >= arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] >= arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[-1] <= arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] <= arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[-1] != arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] != arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i > k and arr[i - k] == deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i > k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i < k and arr[i - k] == deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i < k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i == k and arr[i - k] == deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i == k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k and arr[i - k] != deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] != deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i >= k + 1:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k + 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i >= k * 1:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k * 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = (La / L1 + Lc) % Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La / L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = (La + L1 + Lc) % Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La + L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "L1 = (La * L1 + Lc) % Lm",
      "mutated_line": "L1 = (La ** L1 + Lc) % Lm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La ** L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = (Da / D1 + Dc) % Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da / D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = (Da + D1 + Dc) % Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da + D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "D1 = (Da * D1 + Dc) % Dm",
      "mutated_line": "D1 = (Da ** D1 + Dc) % Dm",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da ** D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L + K + 1 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K + 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min((L + K) * 1 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min((L + K) * 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L + 1], v[R - K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L + 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L * 1], v[R - K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L * 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L - 1], v[R + K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R + K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L - 1], v[R * K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R * K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + 2, s) <= r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 2, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + 0, s) <= r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 0, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + 0, s) <= r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 0, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if pow(t, x + 1, s) <= r:",
      "mutated_line": "if pow(t, x + -1, s) <= r:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + -1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) - b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) - b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) * (b * A[x - 1]) + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) * (b * A[x - 1]) + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) - e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) - e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) * (e * A[x - 1]) + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) * (e * A[x - 1]) + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i >= k - 2:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 2:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i >= k - 0:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 0:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i >= k - 0:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 0:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if i >= k - 1:",
      "mutated_line": "if i >= k - -1:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - -1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k - 1] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k - 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[(i - k) * 1] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[(i - k) * 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + 1] = deque[1]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[1]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + 1] = deque[-1]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[-1]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + 1] = deque[1]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[1]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L - K - 1 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L - K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L * K - 1 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L * K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L + K - 2 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 2 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L + K - 0 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 0 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L + K - 0 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 0 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "R = min(L + K - 1 + D1, N)",
      "mutated_line": "R = min(L + K - -1 + D1, N)",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - -1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L - 2], v[R - K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 2], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L - 0], v[R - K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 0], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L - 0], v[R - K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 0], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "z = min(v[L - 1], v[R - K])",
      "mutated_line": "z = min(v[L - -1], v[R - K])",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - -1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a / pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a / pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a + pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a + pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a ** pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a ** pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b / A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b / A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + (b + A[x - 1]) + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + (b + A[x - 1]) + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b ** A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b ** A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d / pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d / pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d + pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d + pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d ** pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d ** pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e / A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e / A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + (e + A[x - 1]) + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + (e + A[x - 1]) + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e ** A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e ** A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[+1] > arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[+1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k and arr[i + k] == deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i + k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k and arr[i * k] == deque[0]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i * k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k and arr[i - k] == deque[1]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[1]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k and arr[i - k] == deque[-1]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[-1]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if i >= k and arr[i - k] == deque[0]:",
      "mutated_line": "if i >= k and arr[i - k] == deque[1]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[1]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i + k + 1] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i + k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i * k + 1] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i * k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + 2] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 2] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + 0] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 0] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + 0] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 0] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "ans[i - k + 1] = deque[0]",
      "mutated_line": "ans[i - k + -1] = deque[0]",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + -1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[-2] > arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-2] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[-0] > arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-0] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[-0] > arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-0] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while deque and deque[-1] > arr[i]:",
      "mutated_line": "while deque and deque[--1] > arr[i]:",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[--1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 3, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 3, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 1, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 1, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 0, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 0, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 1, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 1, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], -2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], -2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x + 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x + 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x * 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x * 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 3, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 3, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 1, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 1, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 0, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 0, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 1, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 1, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], -2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], -2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x + 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x + 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x * 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x * 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x + 1], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x + 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x * 1], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x * 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 2] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 2] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 0] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 0] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 0] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 0] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - -1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - -1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x + 1], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x + 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x * 1], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x * 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 2] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 2] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 0] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 0] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 0] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 0] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - -1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - -1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 2], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 2], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 0], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 0], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - 0], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 0], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m",
      "mutated_line": "A[x] = (a * pow(A[x - -1], 2, m) + b * A[x - 1] + c) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - -1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 2], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 2], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 0], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 0], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - 0], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - 0], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "A[x] = (d * pow(A[x - 1], 2, m) + e * A[x - 1] + f) % m",
      "mutated_line": "A[x] = (d * pow(A[x - -1], 2, m) + e * A[x - 1] + f) % m",
      "code": "def calculate_dish_qualities(N, K, Q, a, b, c, d, e, f, r, s, t, m, A1, L1, La, Lc, Lm, D1, Da, Dc, Dm):\n    mod = 10 ** 9 + 7\n    A = [0] * N\n    A[0] = A1\n    for x in range(1, N):\n        if pow(t, x + 1, s) <= r:\n            A[x] = (a * pow(A[x - 1], 2, m) + b * A[x - 1] + c) % m\n        else:\n            A[x] = (d * pow(A[x - -1], 2, m) + e * A[x - 1] + f) % m\n\n    def SRMQ(arr, k):\n        from collections import deque\n        n = len(arr)\n        ans = [None] * n\n        deque = deque()\n        for i in range(n):\n            while deque and deque[-1] > arr[i]:\n                deque.pop()\n            deque.append(arr[i])\n            if i >= k and arr[i - k] == deque[0]:\n                deque.popleft()\n            if i >= k - 1:\n                ans[i - k + 1] = deque[0]\n        return ans\n    v = SRMQ(A, K)\n    sum_of_qualities = 0\n    product_of_qualities = 1\n    for _ in range(Q):\n        L1 = (La * L1 + Lc) % Lm\n        D1 = (Da * D1 + Dc) % Dm\n        L = L1 + 1\n        R = min(L + K - 1 + D1, N)\n        z = min(v[L - 1], v[R - K])\n        sum_of_qualities += z\n        product_of_qualities = product_of_qualities * z % mod\n    return (sum_of_qualities, product_of_qualities)"
    }
  ]
}