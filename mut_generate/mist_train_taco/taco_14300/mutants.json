{
  "task_id": "taco_14300",
  "entry_point": "maximize_defended_castles_score",
  "mutant_count": 38,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "S += b",
      "mutated_line": "S -= b",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S -= b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while len(q) > S:",
      "mutated_line": "while len(q) >= S:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) >= S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while len(q) > S:",
      "mutated_line": "while len(q) <= S:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) <= S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "while len(q) > S:",
      "mutated_line": "while len(q) != S:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) != S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "vacant = S - a",
      "mutated_line": "vacant = S + a",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S + a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "vacant = S - a",
      "mutated_line": "vacant = S * a",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S * a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if vacant < 0:",
      "mutated_line": "if vacant <= 0:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant <= 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if vacant < 0:",
      "mutated_line": "if vacant >= 0:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant >= 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if vacant < 0:",
      "mutated_line": "if vacant != 0:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant != 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(q) > vacant:",
      "mutated_line": "while len(q) >= vacant:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) >= vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(q) > vacant:",
      "mutated_line": "while len(q) <= vacant:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) <= vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "while len(q) > vacant:",
      "mutated_line": "while len(q) != vacant:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) != vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b + 1] = max(Tmp[b - 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b + 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b * 1] = max(Tmp[b - 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b * 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 1], a + 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a + 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 1], a * 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a * 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if vacant < 0:",
      "mutated_line": "if vacant < 1:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 1:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if vacant < 0:",
      "mutated_line": "if vacant < -1:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < -1:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if vacant < 0:",
      "mutated_line": "if vacant < 1:",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 1:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return +1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 2] = max(Tmp[b - 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 2] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 0] = max(Tmp[b - 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 0] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 0] = max(Tmp[b - 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 0] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - -1] = max(Tmp[b - 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - -1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b + 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b + 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b * 1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b * 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 2)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 2)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 0)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 0)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 0)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 0)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 1], a - -1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - -1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -2\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -0\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -0\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return --1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 2], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 2], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 0], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 0], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - 0], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - 0], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Tmp[b - 1] = max(Tmp[b - 1], a - 1)",
      "mutated_line": "Tmp[b - 1] = max(Tmp[b - -1], a - 1)",
      "code": "import heapq as hp\n\ndef maximize_defended_castles_score(n, m, k, castles, portals):\n    Tmp = [i for i in range(n)]\n    for (a, b) in portals:\n        Tmp[b - 1] = max(Tmp[b - -1], a - 1)\n    Val = [[] for _ in range(n)]\n    for (i, (_, _, c)) in enumerate(castles):\n        Val[Tmp[i]].append(c)\n    q = []\n    S = k\n    for (i, (a, b, _)) in enumerate(castles):\n        vacant = S - a\n        if vacant < 0:\n            return -1\n        while len(q) > vacant:\n            hp.heappop(q)\n        S += b\n        for p in Val[i]:\n            hp.heappush(q, p)\n    while len(q) > S:\n        hp.heappop(q)\n    return sum(q)"
    }
  ]
}