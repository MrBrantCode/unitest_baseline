{
  "task_id": "taco_9591",
  "entry_point": "calculate_winning_probability",
  "mutant_count": 240,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "A = [0] * H",
      "mutated_line": "A = [0] / H",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] / H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "A = [0] * H",
      "mutated_line": "A = [0] + H",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] + H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "A = [0] * H",
      "mutated_line": "A = [0] ** H",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] ** H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 1] = 2",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 2\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 1] = 0",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 0\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 1] = 0",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 0\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 1] = -1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = -1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] / N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] / N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] + N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] + N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] ** N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] ** N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P + 1] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P + 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P * 1] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P * 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] / N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] / N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] + N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] + N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] ** N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] ** N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H + 1, -1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H + 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H * 1, -1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H * 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, +1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, +1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -1, +1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, +1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if b > 0:",
      "mutated_line": "if b >= 0:",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b >= 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if b > 0:",
      "mutated_line": "if b <= 0:",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b <= 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if b > 0:",
      "mutated_line": "if b != 0:",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b != 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "A = [0] * H",
      "mutated_line": "A = [1] * H",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [1] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "A = [0] * H",
      "mutated_line": "A = [-1] * H",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [-1] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "A = [0] * H",
      "mutated_line": "A = [1] * H",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [1] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "A[a - 1] = b",
      "mutated_line": "A[a + 1] = b",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a + 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "A[a - 1] = b",
      "mutated_line": "A[a * 1] = b",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a * 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[1][P - 1] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[1][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[-1][P - 1] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[-1][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[1][P - 1] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[1][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 2] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 2] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 0] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 0] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - 0] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 0] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "S[0][P - 1] = 1",
      "mutated_line": "S[0][P - -1] = 1",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - -1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 2, -1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 2, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 0, -1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 0, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 0, -1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 0, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - -1, -1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - -1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -2, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -2, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -0, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -0, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -0, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -0, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, --1, -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, --1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -1, -2):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -2):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -1, -0):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -0):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -1, -0):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -0):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "for i in range(H - 1, -1, -1):",
      "mutated_line": "for i in range(H - 1, -1, --1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, --1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(K + 1):",
      "mutated_line": "for j in range(K - 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K - 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "for j in range(K + 1):",
      "mutated_line": "for j in range(K * 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K * 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if b > 0:",
      "mutated_line": "if b > 1:",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 1:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if b > 0:",
      "mutated_line": "if b > -1:",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > -1:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if b > 0:",
      "mutated_line": "if b > 1:",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 1:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] -= (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] -= (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "ASR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] -= (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] -= (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[a - 1] = b",
      "mutated_line": "A[a - 2] = b",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 2] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[a - 1] = b",
      "mutated_line": "A[a - 0] = b",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 0] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[a - 1] = b",
      "mutated_line": "A[a - 0] = b",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 0] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "A[a - 1] = b",
      "mutated_line": "A[a - -1] = b",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - -1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[1] * N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[1] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[-1] * N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[-1] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[1] * N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[1] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] * N for _ in range(K - 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K - 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] * N for _ in range(K * 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K * 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[1] * N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[1] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[-1] * N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[-1] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[1] * N for _ in range(K + 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[1] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] * N for _ in range(K - 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K - 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] * N for _ in range(K * 1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K * 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(K + 1):",
      "mutated_line": "for j in range(K + 2):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 2):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(K + 1):",
      "mutated_line": "for j in range(K + 0):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 0):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(K + 1):",
      "mutated_line": "for j in range(K + 0):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 0):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "for j in range(K + 1):",
      "mutated_line": "for j in range(K + -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + -1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K - k) * (H - M - k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) * (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K - k) // (H - M - k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) // (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] -= (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] -= (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) / v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) / v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) + v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) + v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += ((T[k][0] * (N - 2) + T[k][1]) / (N - 1)) ** v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += ((T[k][0] * (N - 2) + T[k][1]) / (N - 1)) ** v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) / v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) / v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) + v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) + v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += ((T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1)) ** v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += ((T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1)) ** v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] * N for _ in range(K + 2)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 2)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] * N for _ in range(K + 0)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 0)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] * N for _ in range(K + 0)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 0)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "S = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "S = [[0] * N for _ in range(K + -1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + -1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] * N for _ in range(K + 2)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 2)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] * N for _ in range(K + 0)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 0)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] * N for _ in range(K + 0)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 0)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "T = [[0] * N for _ in range(K + 1)]",
      "mutated_line": "T = [[0] * N for _ in range(K + -1)]",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + -1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K + k) / (H - M - k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K + k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = K * k / (H - M - k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = K * k / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K - k) / (H - M + k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M + k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K - k) / ((H - M) * k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / ((H - M) * k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(2, N - 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(2, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(0, N - 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(0, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(0, N - 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(0, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(-1, N - 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(-1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(1, N + 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N + 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(1, N * 1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N * 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) / v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) / v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) + v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) + v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += ((T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1)) ** v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += ((T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1)) ** v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][1] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][1] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][-1] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][-1] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][1] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][1] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) * (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) * (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) // (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) // (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N + 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N + 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N * 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N * 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) * (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) * (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) // (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) // (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b + 1], Si[b]) = (Si[b], Si[b - 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b + 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b * 1], Si[b]) = (Si[b], Si[b - 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b * 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b + 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b + 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b * 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b * 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K - k) / (H + M - k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H + M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "v = (K - k) / (H - M - k)",
      "mutated_line": "v = (K - k) / (H * M - k)",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H * M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(1, N - 2):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 2):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(1, N - 0):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 0):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(1, N - 0):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 0):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N - 1):",
      "mutated_line": "for j in range(1, N - -1):",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - -1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) * (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) * (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) // (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) // (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k - 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k - 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k * 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k * 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) - T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) - T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += T[k][0] * (N - 2) * T[k][1] / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += T[k][0] * (N - 2) * T[k][1] / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N + 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N + 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N * 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N * 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k - 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k - 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k * 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k * 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 2] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 2] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 0] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 0] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 0] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 0] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - -1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - -1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) - T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) - T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += T[k][N - 1] * (N - 2) * T[k][N - 2] / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += T[k][N - 1] * (N - 2) * T[k][N - 2] / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N + 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N + 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N * 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N * 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 2], Si[b]) = (Si[b], Si[b - 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 2], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 0], Si[b]) = (Si[b], Si[b - 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 0], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 0], Si[b]) = (Si[b], Si[b - 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 0], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - -1], Si[b]) = (Si[b], Si[b - 1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - -1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 2])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 2])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 0])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 0])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 0])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 0])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - 1])",
      "mutated_line": "(Si[b - 1], Si[b]) = (Si[b], Si[b - -1])",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - -1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k - 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k - 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k * 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k * 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) - T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) - T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3)) * T[k][j + 1] / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3)) * T[k][j + 1] / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N + 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N + 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N * 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N * 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 2][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 2][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 0][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 0][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 0][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 0][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + -1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + -1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] / (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] / (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] + (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] + (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] ** (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] ** (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 2) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 2) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 0) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 0) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 0) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 0) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - -1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - -1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 2][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 2][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 0][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 0][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 0][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 0][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + -1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + -1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] / (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] / (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] + (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] + (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] ** (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] ** (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 2) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 2) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 0) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 0) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 0) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 0) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - -1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - -1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 2][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 2][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 0][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 0][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 0][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 0][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + -1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + -1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] - T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] - T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] * (T[k][j] * (N - 3)) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] * (T[k][j] * (N - 3)) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 2) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 2) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 0) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 0) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 0) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 0) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - -1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - -1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N + 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N + 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N * 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N * 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][2]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][0]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][0]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][0]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][0]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][-1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][-1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N + 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N + 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N * 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N * 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N + 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N + 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N * 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N * 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] / (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] / (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + (T[k][j] + (N - 3)) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + (T[k][j] + (N - 3)) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] ** (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] ** (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j - 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j - 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j * 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j * 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][1] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][1] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][-1] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][-1] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][1] * (N - 2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][1] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 3) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 3) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 1) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 1) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 0) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 0) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - 1) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 1) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][0] += (T[k][0] * (N - -2) + T[k][1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - -2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N + 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N + 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N * 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N * 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 3) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 3) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 1) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 1) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 0) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 0) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 1) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 1) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - -2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - -2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 3]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 3]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 1]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 0]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 0]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 1]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - -2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - -2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j + 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j + 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j * 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j * 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N + 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N + 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N * 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N * 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 2]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 0]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 0]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 0]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 0]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + -1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + -1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 2] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 2] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 0] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 0] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - 0] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 0] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "mutated_line": "S[k + 1][N - 1] += (T[k][N - -1] * (N - 2) + T[k][N - 2]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - -1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 2] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 2] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 0] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 0] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 0] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 0] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - -1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - -1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 4) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 4) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 2) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 2) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 0) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 0) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 1) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 1) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - 3) + T[k][j + 1]) / (N - 1) * v",
      "mutated_line": "S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - -3) + T[k][j + 1]) / (N - 1) * v",
      "code": "def calculate_winning_probability(H, N, P, M, K, initial_bars):\n    A = [0] * H\n    for (a, b) in initial_bars:\n        A[a - 1] = b\n    S = [[0] * N for _ in range(K + 1)]\n    S[0][P - 1] = 1\n    T = [[0] * N for _ in range(K + 1)]\n    for i in range(H - 1, -1, -1):\n        b = A[i]\n        for j in range(K + 1):\n            T[j][:] = S[j][:]\n        if b > 0:\n            for Si in S:\n                (Si[b - 1], Si[b]) = (Si[b], Si[b - 1])\n        else:\n            for k in range(K):\n                v = (K - k) / (H - M - k)\n                for j in range(1, N - 1):\n                    S[k + 1][j] += (T[k][j - 1] + T[k][j] * (N - -3) + T[k][j + 1]) / (N - 1) * v\n                S[k + 1][0] += (T[k][0] * (N - 2) + T[k][1]) / (N - 1) * v\n                S[k + 1][N - 1] += (T[k][N - 1] * (N - 2) + T[k][N - 2]) / (N - 1) * v\n    return max(S[K])"
    }
  ]
}