{
  "task_id": "taco_11725",
  "entry_point": "minimize_discomfort",
  "mutant_count": 93,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 0 and M == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 and M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N != 0 or M == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N != 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 0 or M != 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M != 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 1\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return -1\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 1\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 ** N + 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N + 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 ** N * 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N * 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if state in memo:",
      "mutated_line": "if state not in memo:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state not in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 * 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 * 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 + 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 + 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(1, 0, 0)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(1, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(-1, 0, 0)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(-1, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(1, 0, 0)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(1, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(0, 1, 0)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(0, -1, 0)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, -1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(0, 1, 0)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 1, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(0, 0, 1)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(0, 0, -1)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, -1)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return dfs(0, 0, 0)",
      "mutated_line": "return dfs(0, 0, 1)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 1)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 1 or M == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 1 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == -1 or M == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == -1 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 1 or M == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 1 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 0 or M == 1:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 1:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 0 or M == -1:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == -1:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 0 or M == 0:",
      "mutated_line": "if N == 0 or M == 1:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 1:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "rest = sum((d - SA for d in D if SA <= d))",
      "mutated_line": "rest = sum((d + SA for d in D if SA <= d))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d + SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "rest = sum((d - SA for d in D if SA <= d))",
      "mutated_line": "rest = sum((d * SA for d in D if SA <= d))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d * SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 * N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 * N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 + N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 + N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 ** N - 2: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 2: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 ** N - 0: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 0: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 ** N - 0: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 0: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {2 ** N - -1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - -1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 11 ** 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 11 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 9 ** 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 9 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 0 ** 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 0 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 1 ** 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 1 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = -10 ** 18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = -10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 ** 19",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 19\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 ** 17",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 17\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 ** 0",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 0\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 ** 1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 1\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "res = 10 ** 18",
      "mutated_line": "res = 10 ** -18",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** -18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 1 != 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 != 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "rest = sum((d - SA for d in D if SA <= d))",
      "mutated_line": "rest = sum((d - SA for d in D if SA < d))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA < d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "rest = sum((d - SA for d in D if SA <= d))",
      "mutated_line": "rest = sum((d - SA for d in D if SA > d))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA > d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "rest = sum((d - SA for d in D if SA <= d))",
      "mutated_line": "rest = sum((d - SA for d in D if SA == d))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA == d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {3 ** N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {3 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {1 ** N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {1 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {0 ** N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {0 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {1 ** N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {1 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "memo = {2 ** N - 1: rest}",
      "mutated_line": "memo = {-2 ** N - 1: rest}",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {-2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i | 1 == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i | 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 1 == 1:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 1:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 1 == -1:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == -1:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 1 == 1:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 1:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 1\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = -1\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 1\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "nxt = su + S[i]",
      "mutated_line": "nxt = su - S[i]",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su - S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "nxt = su + S[i]",
      "mutated_line": "nxt = su * S[i]",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su * S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j < M or D[j] <= nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M or D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "s += min(nxt - D[j], D[j] - su)",
      "mutated_line": "s -= min(nxt - D[j], D[j] - su)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s -= min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j -= 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 2 == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 2 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 0 == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 0 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & 0 == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 0 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if state >> i & 1 == 0:",
      "mutated_line": "if state >> i & -1 == 0:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & -1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j <= M and D[j] <= nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j <= M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j >= M and D[j] <= nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j >= M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j != M and D[j] <= nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j != M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j < M and D[j] < nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] < nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j < M and D[j] > nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] > nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while j < M and D[j] <= nxt:",
      "mutated_line": "while j < M and D[j] == nxt:",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] == nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 2\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 0\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 0\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += -1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s - dfs(state | 1 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s - dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s * dfs(state | 1 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s * dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s += min(nxt - D[j], D[j] - su)",
      "mutated_line": "s += min(nxt + D[j], D[j] - su)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt + D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s += min(nxt - D[j], D[j] - su)",
      "mutated_line": "s += min(nxt * D[j], D[j] - su)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt * D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s += min(nxt - D[j], D[j] - su)",
      "mutated_line": "s += min(nxt - D[j], D[j] + su)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] + su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "s += min(nxt - D[j], D[j] - su)",
      "mutated_line": "s += min(nxt - D[j], D[j] * su)",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] * su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state & 1 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state & 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state ^ 1 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state ^ 1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state | 1 << i, su - S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su - S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state | 1 << i, su * S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 1 << i, su * S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state | 2 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 2 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state | 0 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 0 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state | 0 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | 0 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "res = min(res, s + dfs(state | 1 << i, su + S[i], j))",
      "mutated_line": "res = min(res, s + dfs(state | -1 << i, su + S[i], j))",
      "code": "def minimize_discomfort(N, M, S, D):\n    if N == 0 or M == 0:\n        return 0\n    S.sort()\n    D.sort()\n    SA = sum(S)\n    rest = sum((d - SA for d in D if SA <= d))\n    memo = {2 ** N - 1: rest}\n\n    def dfs(state, su, idx):\n        if state in memo:\n            return memo[state]\n        res = 10 ** 18\n        for i in range(N):\n            if state >> i & 1 == 0:\n                s = 0\n                j = idx\n                nxt = su + S[i]\n                while j < M and D[j] <= nxt:\n                    s += min(nxt - D[j], D[j] - su)\n                    j += 1\n                res = min(res, s + dfs(state | -1 << i, su + S[i], j))\n        memo[state] = res\n        return res\n    return dfs(0, 0, 0)"
    }
  ]
}