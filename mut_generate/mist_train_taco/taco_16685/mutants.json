{
  "task_id": "taco_16685",
  "entry_point": "calculate_max_force",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 1\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a = 0",
      "mutated_line": "a = -1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = -1\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 1\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 1\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = -1\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 1\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "c += i * (b - a)",
      "mutated_line": "c -= i * (b - a)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c -= i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 1\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = 0",
      "mutated_line": "a = -1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = -1\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "a = 0",
      "mutated_line": "a = 1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 1\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "a += A - b",
      "mutated_line": "a -= A - b",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a -= A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "max_level = -1",
      "mutated_line": "max_level = +1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = +1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left += bottom_lift[floor_width - 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left += bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c += i * (b - a)",
      "mutated_line": "c += i / (b - a)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i / (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c += i * (b - a)",
      "mutated_line": "c += i + (b - a)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i + (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c += i * (b - a)",
      "mutated_line": "c += i ** (b - a)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i ** (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "root_lift = [0]",
      "mutated_line": "root_lift = [1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [1]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "root_lift = [0]",
      "mutated_line": "root_lift = [-1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [-1]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "root_lift = [0]",
      "mutated_line": "root_lift = [1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [1]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "a += A - b",
      "mutated_line": "a += A + b",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A + b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "a += A - b",
      "mutated_line": "a += A * b",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A * b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_level = -1",
      "mutated_line": "max_level = -2",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -2\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_level = -1",
      "mutated_line": "max_level = -0",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -0\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_level = -1",
      "mutated_line": "max_level = -0",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -0\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "max_level = -1",
      "mutated_line": "max_level = --1",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = --1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if m < a:",
      "mutated_line": "if m <= a:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m <= a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if m < a:",
      "mutated_line": "if m >= a:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m >= a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if m < a:",
      "mutated_line": "if m != a:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m != a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "money_left = m - a",
      "mutated_line": "money_left = m + a",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m + a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "money_left = m - a",
      "mutated_line": "money_left = m * a",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m * a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if floor_width > n - A_width:",
      "mutated_line": "if floor_width >= n - A_width:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width >= n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if floor_width > n - A_width:",
      "mutated_line": "if floor_width <= n - A_width:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width <= n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if floor_width > n - A_width:",
      "mutated_line": "if floor_width != n - A_width:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width != n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if floor_width > 0:",
      "mutated_line": "if floor_width >= 0:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width >= 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if floor_width > 0:",
      "mutated_line": "if floor_width <= 0:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width <= 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if floor_width > 0:",
      "mutated_line": "if floor_width != 0:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width != 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf * A_width - cm * floor",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width - cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf * A_width * (cm * floor)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width * (cm * floor)\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if max_level < level:",
      "mutated_line": "if max_level <= level:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level <= level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if max_level < level:",
      "mutated_line": "if max_level >= level:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level >= level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if max_level < level:",
      "mutated_line": "if max_level != level:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level != level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c += i * (b - a)",
      "mutated_line": "c += i * (b + a)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b + a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c += i * (b - a)",
      "mutated_line": "c += i * (b * a)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b * a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if floor_width > n - A_width:",
      "mutated_line": "if floor_width > n + A_width:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n + A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if floor_width > n - A_width:",
      "mutated_line": "if floor_width > n * A_width:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n * A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "floor_width = n - A_width",
      "mutated_line": "floor_width = n + A_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n + A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "floor_width = n - A_width",
      "mutated_line": "floor_width = n * A_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n * A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left -= bottom_lift[floor_width + 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width + 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left -= bottom_lift[floor_width * 1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width * 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if floor_width > 0:",
      "mutated_line": "if floor_width > 1:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 1:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if floor_width > 0:",
      "mutated_line": "if floor_width > -1:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > -1:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if floor_width > 0:",
      "mutated_line": "if floor_width > 1:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 1:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 1] - money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] - money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 1] * (money_left // floor_width)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] * (money_left // floor_width)\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if floor > A:",
      "mutated_line": "if floor >= A:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor >= A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if floor > A:",
      "mutated_line": "if floor <= A:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor <= A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if floor > A:",
      "mutated_line": "if floor != A:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor != A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf / A_width + cm * floor",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf / A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf + A_width + cm * floor",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf + A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf ** A_width + cm * floor",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf ** A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf * A_width + cm / floor",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm / floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf * A_width + (cm + floor)",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + (cm + floor)\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "level = cf * A_width + cm * floor",
      "mutated_line": "level = cf * A_width + cm ** floor",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm ** floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for id in xlat[n - A_width:]:",
      "mutated_line": "for id in xlat[n + A_width:]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n + A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "for id in xlat[n - A_width:]:",
      "mutated_line": "for id in xlat[n * A_width:]:",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n * A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left -= bottom_lift[floor_width - 2]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 2]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left -= bottom_lift[floor_width - 0]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 0]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left -= bottom_lift[floor_width - 0]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 0]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "money_left -= bottom_lift[floor_width - 1]",
      "mutated_line": "money_left -= bottom_lift[floor_width - -1]",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - -1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 1] + money_left / floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left / floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 1] + money_left * floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 1] + money_left * floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width + 1] + money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width + 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width * 1] + money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width * 1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 2] + money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 2] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 0] + money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 0] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - 0] + money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - 0] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "floor = sorted_skills[floor_width - 1] + money_left // floor_width",
      "mutated_line": "floor = sorted_skills[floor_width - -1] + money_left // floor_width",
      "code": "def calculate_max_force(n, A, cf, cm, m, skills):\n    from bisect import bisect\n    xlat = sorted(list(range(n)), key=skills.__getitem__)\n    sorted_skills = [skills[_] for _ in xlat]\n    bottom_lift = []\n    a = 0\n    c = 0\n    for (i, b) in enumerate(sorted_skills):\n        c += i * (b - a)\n        bottom_lift.append(c)\n        a = b\n    root_lift = [0]\n    a = 0\n    for b in reversed(sorted_skills):\n        a += A - b\n        root_lift.append(a)\n    max_level = -1\n    save = None\n    for (A_width, a) in enumerate(root_lift):\n        if m < a:\n            break\n        money_left = m - a\n        floor_width = bisect(bottom_lift, money_left)\n        if floor_width > n - A_width:\n            floor_width = n - A_width\n        money_left -= bottom_lift[floor_width - 1]\n        if floor_width > 0:\n            floor = sorted_skills[floor_width - -1] + money_left // floor_width\n            if floor > A:\n                floor = A\n        else:\n            floor = A\n        level = cf * A_width + cm * floor\n        if max_level < level:\n            max_level = level\n            save = (A_width, floor, floor_width)\n    (A_width, floor, floor_width) = save\n    for id in xlat[:floor_width]:\n        skills[id] = floor\n    for id in xlat[n - A_width:]:\n        skills[id] = A\n    return (max_level, skills)"
    }
  ]
}