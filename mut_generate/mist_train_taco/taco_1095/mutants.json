{
  "task_id": "taco_1095",
  "entry_point": "can_move_through_hole",
  "mutant_count": 234,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ok = 1",
      "mutated_line": "ok = 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 2\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ok = 1",
      "mutated_line": "ok = 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 0\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ok = 1",
      "mutated_line": "ok = 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 0\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ok = 1",
      "mutated_line": "ok = -1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = -1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) - (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) - (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) * ((y1 - y0) * (y2 - y0))",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) * ((y1 - y0) * (y2 - y0))\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) + (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) + (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) * ((y1 - y0) * (x2 - x0))",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) * ((y1 - y0) * (x2 - x0))\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 - (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 - (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 * (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 * (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n + 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n * 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) * 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) * 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) + 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) + 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "LCR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) and (not max(el1[0], er0[0]) <= min(el1[1], er1[1])):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) and (not max(el1[0], er0[0]) <= min(el1[1], er1[1])):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return 'Possible'",
      "mutated_line": "return ''",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return ''\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return 'Impossible'",
      "mutated_line": "return ''",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) / (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) / (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return x1 - x0 + (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return x1 - x0 + (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) ** (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) ** (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) / (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) / (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0 + (y2 - y0))",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0 + (y2 - y0))\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) ** (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) ** (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) / (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) / (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return x1 - x0 + (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return x1 - x0 + (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) ** (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) ** (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) / (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) / (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0 + (x2 - x0))",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0 + (x2 - x0))\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) ** (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) ** (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) * 2 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) * 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return x0 - x1 + 2 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return x0 - x1 + 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) * 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) * 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1 + 2)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1 + 2)\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 2):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 0):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 0):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - -1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p1 = vertices[i + 1]",
      "mutated_line": "p1 = vertices[i - 1]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i - 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "p1 = vertices[i + 1]",
      "mutated_line": "p1 = vertices[i * 1]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i * 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) ** 1.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 1.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** -0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) ** 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 1\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "d0 = dist2(p0, p1) ** 0.5",
      "mutated_line": "d0 = dist2(p0, p1) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** -0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "el0 = [-d0, d0]",
      "mutated_line": "el0 = [+d0, d0]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [+d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "el1 = [-d0, d0]",
      "mutated_line": "el1 = [+d0, d0]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [+d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "er0 = [-d0, d0]",
      "mutated_line": "er0 = [+d0, d0]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [+d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "er1 = [-d0, d0]",
      "mutated_line": "er1 = [+d0, d0]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [+d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) * 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) * 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) + 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) + 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) * 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) * 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) + 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) + 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "cv0 = dot3(p0, p1, q0) / d1",
      "mutated_line": "cv0 = dot3(p0, p1, q0) * d1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) * d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "cv0 = dot3(p0, p1, q0) / d1",
      "mutated_line": "cv0 = dot3(p0, p1, q0) // d1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) // d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cv1 = dot3(p1, p0, q0) / d2",
      "mutated_line": "cv1 = dot3(p1, p0, q0) * d2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) * d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cv1 = dot3(p1, p0, q0) / d2",
      "mutated_line": "cv1 = dot3(p1, p0, q0) // d2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) // d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv >= 0:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv >= 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv <= 0:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv <= 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv != 0:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv != 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i - 2, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i - 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i * 2, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i * 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) * 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) * 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) + 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) + 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) * 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) * 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) + 0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) + 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "cv0 = dot3(p1, p0, q1) / d1",
      "mutated_line": "cv0 = dot3(p1, p0, q1) * d1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) * d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 46,
      "original_line": "cv0 = dot3(p1, p0, q1) / d1",
      "mutated_line": "cv0 = dot3(p1, p0, q1) // d1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) // d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "cv1 = dot3(p0, p1, q1) / d2",
      "mutated_line": "cv1 = dot3(p0, p1, q1) * d2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) * d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "cv1 = dot3(p0, p1, q1) / d2",
      "mutated_line": "cv1 = dot3(p0, p1, q1) // d2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) // d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv >= 0:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv >= 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv <= 0:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv <= 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv != 0:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv != 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ok = 0",
      "mutated_line": "ok = 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 1\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ok = 0",
      "mutated_line": "ok = -1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = -1\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "ok = 0",
      "mutated_line": "ok = 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 1\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 + x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 + x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return x1 * x0 * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return x1 * x0 * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 + x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 + x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 * x0) + (y1 - y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 * x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + (y1 + y0) * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 + y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + y1 * y0 * (y2 - y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + y1 * y0 * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 + y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 + y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)",
      "mutated_line": "return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 * y0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 * y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 + x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 + x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return x1 * x0 * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return x1 * x0 * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 + y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 + y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 * y0) - (y1 - y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 * y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - (y1 + y0) * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 + y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - y1 * y0 * (x2 - x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - y1 * y0 * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 + x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 + x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)",
      "mutated_line": "return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 * x0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 * x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 + x1) ** 2 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 + x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 * x1) ** 2 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 * x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 3 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 3 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 1 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 1 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 0 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 0 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 1 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 1 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** -2 + (y0 - y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** -2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 + y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 + y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 * y1) ** 2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 * y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 3",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 3\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 1\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 0\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 1\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return (x0 - x1) ** 2 + (y0 - y1) ** 2",
      "mutated_line": "return (x0 - x1) ** 2 + (y0 - y1) ** -2",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** -2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p1 = vertices[i + 1]",
      "mutated_line": "p1 = vertices[i + 2]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 2]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p1 = vertices[i + 1]",
      "mutated_line": "p1 = vertices[i + 0]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 0]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p1 = vertices[i + 1]",
      "mutated_line": "p1 = vertices[i + 0]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 0]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "p1 = vertices[i + 1]",
      "mutated_line": "p1 = vertices[i + -1]",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + -1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) ** 1.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 1.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** -0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) ** 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 1\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "d1 = dist2(p0, q0) ** 0.5",
      "mutated_line": "d1 = dist2(p0, q0) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** -0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) ** 1.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 1.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** -0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) ** 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 1\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d2 = dist2(p1, q0) ** 0.5",
      "mutated_line": "d2 = dist2(p1, q0) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** -0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv > 1:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 1:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv > -1:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > -1:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv > 1:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 1:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i + 3, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 3, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i + 1, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 1, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 0, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i + 1, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 1, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "for j in range(i + 2, n):",
      "mutated_line": "for j in range(i + -2, n):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + -2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) ** 1.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 1.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** -0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) ** 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 1\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "d1 = dist2(p1, q1) ** 0.5",
      "mutated_line": "d1 = dist2(p1, q1) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** -0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) ** 1.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 1.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** -0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) ** 0",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) ** 1",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 1\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "d2 = dist2(p0, q1) ** 0.5",
      "mutated_line": "d2 = dist2(p0, q1) ** -0.5",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** -0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv > 1:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 1:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv > -1:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > -1:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "if sv > 0:",
      "mutated_line": "if sv > 1:",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 1:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) < min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) < min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) > min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) > min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) == min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) == min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) < min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) < min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) > min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) > min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "ROR",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) == min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) == min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "el0[0] = max(el0[0], cv0)",
      "mutated_line": "el0[1] = max(el0[0], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[1] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "el0[0] = max(el0[0], cv0)",
      "mutated_line": "el0[-1] = max(el0[0], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[-1] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "el0[0] = max(el0[0], cv0)",
      "mutated_line": "el0[1] = max(el0[0], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[1] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[1] = max(el1[0], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[1] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[-1] = max(el1[0], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[-1] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[1] = max(el1[0], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[1] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[0] = max(el1[0], +cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], +cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[2] = min(er0[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[2] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[0] = min(er0[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[0] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[0] = min(er0[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[0] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[-1] = min(er0[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[-1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[1] = min(er0[1], +cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], +cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[2] = min(er1[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[2] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[0] = min(er1[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[0] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[0] = min(er1[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[0] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[-1] = min(er1[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[-1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "er1[0] = max(er1[0], cv0)",
      "mutated_line": "er1[1] = max(er1[0], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[1] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "er1[0] = max(er1[0], cv0)",
      "mutated_line": "er1[-1] = max(er1[0], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[-1] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "er1[0] = max(er1[0], cv0)",
      "mutated_line": "er1[1] = max(er1[0], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[1] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[1] = max(er0[0], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[1] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[-1] = max(er0[0], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[-1] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[1] = max(er0[0], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[1] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[0] = max(er0[0], +cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], +cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[2] = min(el1[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[2] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[0] = min(el1[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[0] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[0] = min(el1[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[0] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[-1] = min(el1[1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[-1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "UOI",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[1] = min(el1[1], +cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], +cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[2] = min(el0[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[2] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[0] = min(el0[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[0] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[0] = min(el0[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[0] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[-1] = min(el0[1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[-1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "el0[0] = max(el0[0], cv0)",
      "mutated_line": "el0[0] = max(el0[1], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[1], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "el0[0] = max(el0[0], cv0)",
      "mutated_line": "el0[0] = max(el0[-1], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[-1], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "el0[0] = max(el0[0], cv0)",
      "mutated_line": "el0[0] = max(el0[1], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[1], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[0] = max(el1[1], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[1], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[0] = max(el1[-1], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[-1], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "el1[0] = max(el1[0], -cv1)",
      "mutated_line": "el1[0] = max(el1[1], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[1], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[1] = min(er0[2], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[2], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[1] = min(er0[0], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[0], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[1] = min(er0[0], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[0], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "er0[1] = min(er0[1], -cv0)",
      "mutated_line": "er0[1] = min(er0[-1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[-1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[1] = min(er1[2], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[2], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[1] = min(er1[0], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[0], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[1] = min(er1[0], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[0], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "er1[1] = min(er1[1], cv1)",
      "mutated_line": "er1[1] = min(er1[-1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[-1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "er1[0] = max(er1[0], cv0)",
      "mutated_line": "er1[0] = max(er1[1], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[1], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "er1[0] = max(er1[0], cv0)",
      "mutated_line": "er1[0] = max(er1[-1], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[-1], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "er1[0] = max(er1[0], cv0)",
      "mutated_line": "er1[0] = max(er1[1], cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[1], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[0] = max(er0[1], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[1], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[0] = max(er0[-1], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[-1], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "er0[0] = max(er0[0], -cv1)",
      "mutated_line": "er0[0] = max(er0[1], -cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[1], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[1] = min(el1[2], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[2], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[1] = min(el1[0], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[0], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[1] = min(el1[0], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[0], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "el1[1] = min(el1[1], -cv0)",
      "mutated_line": "el1[1] = min(el1[-1], -cv0)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[-1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[1] = min(el0[2], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[2], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[1] = min(el0[0], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[0], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[1] = min(el0[0], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[0], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "el0[1] = min(el0[1], cv1)",
      "mutated_line": "el0[1] = min(el0[-1], cv1)",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[-1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[1], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[1], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[-1], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[-1], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[1], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[1], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[1]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[1]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[-1]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[-1]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[1]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[1]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[2], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[2], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[0], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[0], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[0], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[0], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[-1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[-1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[2]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[2]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[0]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[0]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[0]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[0]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[-1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[-1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[1], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[1], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[-1], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[-1], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[1], er0[0]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[1], er0[0]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[1]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[1]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[-1]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[-1]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[1]) <= min(el1[1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[1]) <= min(el1[1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[2], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[2], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[0], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[0], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[0], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[0], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[-1], er1[1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[-1], er1[1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[2]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[2]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[0]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[0]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[0]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[0]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[1]):",
      "mutated_line": "if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[-1]):",
      "code": "def can_move_through_hole(n, vertices):\n\n    def dot3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0)\n\n    def cross3(p0, p1, p2):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        (x2, y2) = p2\n        return (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0)\n\n    def dist2(p0, p1):\n        (x0, y0) = p0\n        (x1, y1) = p1\n        return (x0 - x1) ** 2 + (y0 - y1) ** 2\n    ok = 1\n    for i in range(n - 1):\n        p0 = vertices[i]\n        p1 = vertices[i + 1]\n        d0 = dist2(p0, p1) ** 0.5\n        el0 = [-d0, d0]\n        el1 = [-d0, d0]\n        er0 = [-d0, d0]\n        er1 = [-d0, d0]\n        for j in range(i):\n            q0 = vertices[j]\n            d1 = dist2(p0, q0) ** 0.5\n            d2 = dist2(p1, q0) ** 0.5\n            sv = cross3(p0, p1, q0)\n            cv0 = dot3(p0, p1, q0) / d1\n            cv1 = dot3(p1, p0, q0) / d2\n            if sv > 0:\n                el0[0] = max(el0[0], cv0)\n                el1[0] = max(el1[0], -cv1)\n            else:\n                er0[1] = min(er0[1], -cv0)\n                er1[1] = min(er1[1], cv1)\n        for j in range(i + 2, n):\n            q1 = vertices[j]\n            d1 = dist2(p1, q1) ** 0.5\n            d2 = dist2(p0, q1) ** 0.5\n            sv = cross3(p1, p0, q1)\n            cv0 = dot3(p1, p0, q1) / d1\n            cv1 = dot3(p0, p1, q1) / d2\n            if sv > 0:\n                er1[0] = max(er1[0], cv0)\n                er0[0] = max(er0[0], -cv1)\n            else:\n                el1[1] = min(el1[1], -cv0)\n                el0[1] = min(el0[1], cv1)\n        if not max(el0[0], er0[0]) <= min(el0[1], er0[1]) or not max(el1[0], er0[0]) <= min(el1[1], er1[-1]):\n            ok = 0\n            break\n    if ok:\n        return 'Possible'\n    else:\n        return 'Impossible'"
    }
  ]
}