{
  "task_id": "taco_11043",
  "entry_point": "calculate_bst_liking",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 - 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 - 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 * 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 * 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "e = o = 0",
      "mutated_line": "e = o = 1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 1\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "e = o = 0",
      "mutated_line": "e = o = -1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = -1\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "e = o = 0",
      "mutated_line": "e = o = 1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 1\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "e += de * l[k] % MOD",
      "mutated_line": "e -= de * l[k] % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e -= de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "o += do * l[k] % MOD",
      "mutated_line": "o -= do * l[k] % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o -= do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) * MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) * MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = e * alpha % MOD + (MOD - o * beta % MOD) + MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = e * alpha % MOD + (MOD - o * beta % MOD) + MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 * 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 * 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 + 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 + 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 10",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 10\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 8\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 0\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 1\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 9 + -9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + -9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "bt = [1]",
      "mutated_line": "bt = [2]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [2]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "bt = [1]",
      "mutated_line": "bt = [0]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [0]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "bt = [1]",
      "mutated_line": "bt = [0]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [0]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "bt = [1]",
      "mutated_line": "bt = [-1]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [-1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(2, N + 1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(2, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(0, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(0, N + 1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(0, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(-1, N + 1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(-1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N - 1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N - 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N * 1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N * 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 1\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 0",
      "mutated_line": "c = -1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = -1\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "c = 0",
      "mutated_line": "c = 1",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 1\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "c += l * r % MOD",
      "mutated_line": "c -= l * r % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c -= l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += de * l[k] % MOD",
      "mutated_line": "e += de * l[k] * MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] * MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += de * l[k] % MOD",
      "mutated_line": "e += de * l[k] + MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] + MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "o += do * l[k] % MOD",
      "mutated_line": "o += do * l[k] * MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] * MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "o += do * l[k] % MOD",
      "mutated_line": "o += do * l[k] + MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] + MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD - (MOD - o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD - (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = e * alpha % MOD * (MOD - o * beta % MOD) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = e * alpha % MOD * (MOD - o * beta % MOD) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 11 ** 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 11 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 9 ** 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 9 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 0 ** 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 0 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 1 ** 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 1 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = -10 ** 9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = -10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 10 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 10 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 8 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 8 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 0 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 0 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** 1 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 1 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 9",
      "mutated_line": "MOD = 10 ** -9 + 9",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** -9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 2):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 2):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 0):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + 0):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 0):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(1, N + 1):",
      "mutated_line": "for i in range(1, N + -1):",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + -1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c += l * r % MOD",
      "mutated_line": "c += l * r * MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r * MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c += l * r % MOD",
      "mutated_line": "c += l * r + MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r + MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "bt.append(c % MOD)",
      "mutated_line": "bt.append(c * MOD)",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c * MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "bt.append(c % MOD)",
      "mutated_line": "bt.append(c + MOD)",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c + MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += de * l[k] % MOD",
      "mutated_line": "e += de / l[k] % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de / l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += de * l[k] % MOD",
      "mutated_line": "e += (de + l[k]) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += (de + l[k]) % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += de * l[k] % MOD",
      "mutated_line": "e += de ** l[k] % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de ** l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "o += do * l[k] % MOD",
      "mutated_line": "o += do / l[k] % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do / l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "o += do * l[k] % MOD",
      "mutated_line": "o += (do + l[k]) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += (do + l[k]) % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "o += do * l[k] % MOD",
      "mutated_line": "o += do ** l[k] % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do ** l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha * MOD + (MOD - o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha * MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha + MOD + (MOD - o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha + MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD + o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD + o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + MOD * (o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + MOD * (o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i - j + 1]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j + 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[(i - j) * 1]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[(i - j) * 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [(de + l * r) * MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) * MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [de + l * r + MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [de + l * r + MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c += l * r % MOD",
      "mutated_line": "c += l / r % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l / r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c += l * r % MOD",
      "mutated_line": "c += (l + r) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += (l + r) % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "c += l * r % MOD",
      "mutated_line": "c += l ** r % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l ** r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e / alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e / alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = ((e + alpha) % MOD + (MOD - o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = ((e + alpha) % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e ** alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e ** alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD - o * beta * MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta * MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD - (o * beta + MOD))) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - (o * beta + MOD))) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i + j - 1]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i + j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i * j - 1]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i * j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i - j - 2]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 2]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i - j - 0]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 0]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i - j - 0]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 0]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "r = bt[i - j - 1]",
      "mutated_line": "r = bt[i - j - -1]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - -1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) * MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) * MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [de + o * r + MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [de + o * r + MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, (do + e * r) * MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) * MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, do + e * r + MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, do + e * r + MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j - 1, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j - 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get((k + j) * 1, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get((k + j) * 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j - 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j - 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[(k + j) * 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[(k + j) * 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) * MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) * MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [de + o * l + MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [de + o * l + MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) * MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) * MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, do + e * l + MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, do + e * l + MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(de, do) = d.get(j, [0, 0])",
      "mutated_line": "(de, do) = d.get(j, [1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [1, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(de, do) = d.get(j, [0, 0])",
      "mutated_line": "(de, do) = d.get(j, [-1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [-1, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(de, do) = d.get(j, [0, 0])",
      "mutated_line": "(de, do) = d.get(j, [1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [1, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(de, do) = d.get(j, [0, 0])",
      "mutated_line": "(de, do) = d.get(j, [0, 1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 1])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(de, do) = d.get(j, [0, 0])",
      "mutated_line": "(de, do) = d.get(j, [0, -1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, -1])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "(de, do) = d.get(j, [0, 0])",
      "mutated_line": "(de, do) = d.get(j, [0, 1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 1])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [(de - l * r) % MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de - l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [de * (l * r) % MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [de * (l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD - o / beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o / beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD - (o + beta) % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - (o + beta) % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD",
      "mutated_line": "result = (e * alpha % MOD + (MOD - o ** beta % MOD)) % MOD",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o ** beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(de, do) = d.get(k, [0, 0])",
      "mutated_line": "(de, do) = d.get(k, [1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [1, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(de, do) = d.get(k, [0, 0])",
      "mutated_line": "(de, do) = d.get(k, [-1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [-1, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(de, do) = d.get(k, [0, 0])",
      "mutated_line": "(de, do) = d.get(k, [1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [1, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(de, do) = d.get(k, [0, 0])",
      "mutated_line": "(de, do) = d.get(k, [0, 1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 1])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(de, do) = d.get(k, [0, 0])",
      "mutated_line": "(de, do) = d.get(k, [0, -1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, -1])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "(de, do) = d.get(k, [0, 0])",
      "mutated_line": "(de, do) = d.get(k, [0, 1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 1])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de - o * r) % MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de - o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [de * (o * r) % MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [de * (o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, (do - e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do - e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, do * (e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, do * (e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i - j + 1].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j + 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[(i - j) * 1].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[(i - j) * 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k - j + 1, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k - j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k * j + 1, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k * j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 2, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 2, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 0, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 0, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 0, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 0, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + -1, [0, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + -1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 1, [1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [1, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 1, [-1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [-1, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 1, [1, 0])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [1, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 1, [0, 1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 1])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 1, [0, -1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, -1])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "(de, do) = d.get(k + j + 1, [0, 0])",
      "mutated_line": "(de, do) = d.get(k + j + 1, [0, 1])",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 1])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k - j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k - j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k * j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k * j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 2] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 2] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 0] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 0] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 0] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 0] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + -1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + -1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de - o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de - o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [de * (o * l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [de * (o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, (do - e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do - e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, do * (e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, do * (e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [(de + l / r) % MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l / r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [(de + (l + r)) % MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + (l + r)) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d[j] = [(de + l * r) % MOD, do]",
      "mutated_line": "d[j] = [(de + l ** r) % MOD, do]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l ** r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o / r) % MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o / r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + (o + r)) % MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + (o + r)) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o ** r) % MOD, (do + e * r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o ** r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, (do + e / r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e / r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, (do + (e + r)) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + (e + r)) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]",
      "mutated_line": "d[k] = [(de + o * r) % MOD, (do + e ** r) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e ** r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i + j - 1].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i + j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i * j - 1].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i * j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i - j - 2].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 2].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i - j - 0].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 0].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i - j - 0].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 0].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "for (k, (e, o)) in oe[i - j - 1].items():",
      "mutated_line": "for (k, (e, o)) in oe[i - j - -1].items():",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - -1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o / l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o / l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + (o + l)) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + (o + l)) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o ** l) % MOD, (do + e * l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o ** l) % MOD, (do + e * l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e / l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e / l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + (e + l)) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + (e + l)) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e * l) % MOD]",
      "mutated_line": "d[k + j + 1] = [(de + o * l) % MOD, (do + e ** l) % MOD]",
      "code": "def calculate_bst_liking(N, alpha, beta, A):\n    MOD = 10 ** 9 + 9\n    bt = [1]\n    oe = [{}]\n    for i in range(1, N + 1):\n        c = 0\n        d = {}\n        for j in range(i):\n            l = bt[j]\n            r = bt[i - j - 1]\n            for (k, (e, o)) in oe[j].items():\n                (de, do) = d.get(k, [0, 0])\n                d[k] = [(de + o * r) % MOD, (do + e * r) % MOD]\n            for (k, (e, o)) in oe[i - j - 1].items():\n                (de, do) = d.get(k + j + 1, [0, 0])\n                d[k + j + 1] = [(de + o * l) % MOD, (do + e ** l) % MOD]\n            (de, do) = d.get(j, [0, 0])\n            d[j] = [(de + l * r) % MOD, do]\n            c += l * r % MOD\n        bt.append(c % MOD)\n        oe.append(d)\n    d = oe[N]\n    l = sorted(A)\n    e = o = 0\n    for (k, (de, do)) in d.items():\n        e += de * l[k] % MOD\n        o += do * l[k] % MOD\n    e %= MOD\n    o %= MOD\n    result = (e * alpha % MOD + (MOD - o * beta % MOD)) % MOD\n    return result"
    }
  ]
}