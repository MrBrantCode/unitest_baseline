{
  "task_id": "taco_18719",
  "entry_point": "min_operations_to_increasing_array",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 1\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = -1\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 1\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [-1] + sorted(b) - [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) - [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = ([-1] + sorted(b)) * [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = ([-1] + sorted(b)) * [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "ans += len(nums) - length_of_lis(nums, mn, mx)",
      "mutated_line": "ans -= len(nums) - length_of_lis(nums, mn, mx)",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans -= len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mn_val = mn - 1",
      "mutated_line": "mn_val = mn + 1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn + 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "mn_val = mn - 1",
      "mutated_line": "mn_val = mn * 1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn * 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mx_val = mx - len(nums)",
      "mutated_line": "mx_val = mx + len(nums)",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx + len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mx_val = mx - len(nums)",
      "mutated_line": "mx_val = mx * len(nums)",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx * len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return len(chain) - 1",
      "mutated_line": "return len(chain) + 1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) + 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return len(chain) - 1",
      "mutated_line": "return len(chain) * 1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) * 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [-1] - sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] - sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [-1] * sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] * sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if mn >= mx:",
      "mutated_line": "if mn > mx:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn > mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if mn >= mx:",
      "mutated_line": "if mn < mx:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn < mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if mn >= mx:",
      "mutated_line": "if mn == mx:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn == mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - 1 <= len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 <= len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - 1 >= len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 >= len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - 1 != len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 != len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += len(nums) - length_of_lis(nums, mn, mx)",
      "mutated_line": "ans += len(nums) + length_of_lis(nums, mn, mx)",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) + length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "ans += len(nums) - length_of_lis(nums, mn, mx)",
      "mutated_line": "ans += len(nums) * length_of_lis(nums, mn, mx)",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) * length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mn_val = mn - 1",
      "mutated_line": "mn_val = mn - 2",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 2\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mn_val = mn - 1",
      "mutated_line": "mn_val = mn - 0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 0\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mn_val = mn - 1",
      "mutated_line": "mn_val = mn - 0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 0\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "mn_val = mn - 1",
      "mutated_line": "mn_val = mn - -1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - -1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "v = x - i",
      "mutated_line": "v = x + i",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x + i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "v = x - i",
      "mutated_line": "v = x * i",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x * i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val > v and v > mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v and v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if new_len == len(chain):",
      "mutated_line": "if new_len != len(chain):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len != len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return len(chain) - 1",
      "mutated_line": "return len(chain) - 2",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 2\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return len(chain) - 1",
      "mutated_line": "return len(chain) - 0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 0\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return len(chain) - 1",
      "mutated_line": "return len(chain) - 0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 0\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return len(chain) - 1",
      "mutated_line": "return len(chain) - -1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - -1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('-inf') if b1 != -1 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 != -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "mx = float('inf') if b2 == n else a[b2]",
      "mutated_line": "mx = float('inf') if b2 != n else a[b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 != n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return +1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn + 1 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn + 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if (mx - mn) * 1 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if (mx - mn) * 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return +1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val >= v or v > mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val >= v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val <= v or v > mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val <= v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val != v or v > mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val != v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val > v or v >= mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v >= mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val > v or v <= mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v <= mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if mn_val > v or v > mx_val:",
      "mutated_line": "if mn_val > v or v != mx_val:",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v != mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [+1] + sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [+1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for b1, b2 in zip(s_b, s_b[1:]):",
      "mutated_line": "for (b1, b2) in zip(s_b, s_b[2:]):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[2:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for b1, b2 in zip(s_b, s_b[1:]):",
      "mutated_line": "for (b1, b2) in zip(s_b, s_b[0:]):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[0:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for b1, b2 in zip(s_b, s_b[1:]):",
      "mutated_line": "for (b1, b2) in zip(s_b, s_b[0:]):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[0:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for b1, b2 in zip(s_b, s_b[1:]):",
      "mutated_line": "for (b1, b2) in zip(s_b, s_b[-1:]):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[-1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('-inf') if b1 == +1 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == +1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('') if b1 == -1 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "mx = float('inf') if b2 == n else a[b2]",
      "mutated_line": "mx = float('') if b2 == n else a[b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nums = a[b1 + 1:b2]",
      "mutated_line": "nums = a[b1 - 1:b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 - 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "nums = a[b1 + 1:b2]",
      "mutated_line": "nums = a[b1 * 1:b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 * 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -2\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -0\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -0\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return --1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx + mn - 1 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx + mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx * mn - 1 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx * mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - 2 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 2 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - 0 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 0 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - 0 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 0 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if mx - mn - 1 < len(nums):",
      "mutated_line": "if mx - mn - -1 < len(nums):",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - -1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -2\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -0\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -0\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return --1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [-2] + sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-2] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [-0] + sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-0] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [-0] + sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-0] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "s_b = [-1] + sorted(b) + [n]",
      "mutated_line": "s_b = [--1] + sorted(b) + [n]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [--1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('-inf') if b1 == -2 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -2 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('-inf') if b1 == -0 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -0 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('-inf') if b1 == -0 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -0 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "mn = float('-inf') if b1 == -1 else a[b1]",
      "mutated_line": "mn = float('-inf') if b1 == --1 else a[b1]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == --1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nums = a[b1 + 1:b2]",
      "mutated_line": "nums = a[b1 + 2:b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 2:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nums = a[b1 + 1:b2]",
      "mutated_line": "nums = a[b1 + 0:b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 0:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nums = a[b1 + 1:b2]",
      "mutated_line": "nums = a[b1 + 0:b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + 0:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "nums = a[b1 + 1:b2]",
      "mutated_line": "nums = a[b1 + -1:b2]",
      "code": "import bisect\n\ndef min_operations_to_increasing_array(n, k, a, b):\n\n    def length_of_lis(nums, mn, mx):\n        mn_val = mn - 1\n        mx_val = mx - len(nums)\n        chain = [mn_val]\n        for (i, x) in enumerate(nums):\n            v = x - i\n            if mn_val > v or v > mx_val:\n                continue\n            new_len = bisect.bisect_right(chain, v)\n            if new_len == len(chain):\n                chain.append(v)\n            else:\n                chain[new_len] = min(chain[new_len], v)\n        return len(chain) - 1\n    ans = 0\n    s_b = [-1] + sorted(b) + [n]\n    for (b1, b2) in zip(s_b, s_b[1:]):\n        mn = float('-inf') if b1 == -1 else a[b1]\n        mx = float('inf') if b2 == n else a[b2]\n        nums = a[b1 + -1:b2]\n        if mn >= mx:\n            return -1\n        if mx - mn - 1 < len(nums):\n            return -1\n        ans += len(nums) - length_of_lis(nums, mn, mx)\n    return ans"
    }
  ]
}