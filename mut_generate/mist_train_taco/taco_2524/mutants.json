{
  "task_id": "taco_2524",
  "entry_point": "minimum_group_size",
  "mutant_count": 59,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while low < high:",
      "mutated_line": "while low <= high:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low <= high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while low < high:",
      "mutated_line": "while low >= high:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low >= high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while low < high:",
      "mutated_line": "while low != high:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low != high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size > 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size > 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size < 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size < 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size == 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size == 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (2, sum((y_i for (_, y_i) in dishes)) + 1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (2, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (0, sum((y_i for (_, y_i) in dishes)) + 1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (0, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (0, sum((y_i for (_, y_i) in dishes)) + 1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (0, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (-1, sum((y_i for (_, y_i) in dishes)) + 1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (-1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (1, sum((y_i for (_, y_i) in dishes)) - 1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) - 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (1, sum((y_i for (_, y_i) in dishes)) * 1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) * 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) / 2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) / 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) * 2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) * 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if q_i == -1:  # Dish event",
      "mutated_line": "if q_i != -1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i != -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "current_size -= y_i",
      "mutated_line": "current_size += y_i",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size += y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size <= 1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size <= 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size >= 1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size >= 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size != 1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size != 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size >= 2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 2\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size >= 0",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 0\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size >= 0",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 0\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return current_size >= 1",
      "mutated_line": "return current_size >= -1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= -1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 2)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 2)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 0)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 0)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 0)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 0)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "low, high = 1, sum(y_i for _, y_i in dishes) + 1",
      "mutated_line": "(low, high) = (1, sum((y_i for (_, y_i) in dishes)) + -1)",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + -1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low - high) // 2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low - high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = low * high // 2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = low * high // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 3",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 3\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 1\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 0",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 0\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 1\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "mid = (low + high) // 2",
      "mutated_line": "mid = (low + high) // -2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // -2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid - 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid - 1\n    return low"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid * 1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid * 1\n    return low"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "events.append((x_i, y_i, -1))  # -1 indicates a dish event",
      "mutated_line": "events.append((x_i, y_i, +1))",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, +1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "if q_i == -1:  # Dish event",
      "mutated_line": "if q_i == +1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == +1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif current_size >= q_i:  # Clan event",
      "mutated_line": "elif current_size > q_i:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size > q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif current_size >= q_i:  # Clan event",
      "mutated_line": "elif current_size < q_i:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size < q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "elif current_size >= q_i:  # Clan event",
      "mutated_line": "elif current_size == q_i:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size == q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "current_size += y_i",
      "mutated_line": "current_size -= y_i",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size -= y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size < 2:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 2:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size < 0:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 0:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size < 0:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 0:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if current_size < 1:",
      "mutated_line": "if current_size < -1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < -1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return True\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 2",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 2\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 0",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 0\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + 0",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 0\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "low = mid + 1",
      "mutated_line": "low = mid + -1",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + -1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "events.append((x_i, y_i, -1))  # -1 indicates a dish event",
      "mutated_line": "events.append((x_i, y_i, -2))",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -2))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "events.append((x_i, y_i, -1))  # -1 indicates a dish event",
      "mutated_line": "events.append((x_i, y_i, -0))",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -0))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "events.append((x_i, y_i, -1))  # -1 indicates a dish event",
      "mutated_line": "events.append((x_i, y_i, -0))",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -0))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "events.append((x_i, y_i, -1))  # -1 indicates a dish event",
      "mutated_line": "events.append((x_i, y_i, --1))",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, --1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if q_i == -1:  # Dish event",
      "mutated_line": "if q_i == -2:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -2:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if q_i == -1:  # Dish event",
      "mutated_line": "if q_i == -0:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -0:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if q_i == -1:  # Dish event",
      "mutated_line": "if q_i == -0:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == -0:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if q_i == -1:  # Dish event",
      "mutated_line": "if q_i == --1:",
      "code": "def minimum_group_size(X, B, dishes, C, clans):\n    events = []\n    for (x_i, y_i) in dishes:\n        events.append((x_i, y_i, -1))\n    for (p_i, q_i, r_i) in clans:\n        events.append((p_i, r_i, q_i))\n    events.sort()\n\n    def can_reach_byteland(initial_size):\n        current_size = initial_size\n        for (_, y_i, q_i) in events:\n            if q_i == --1:\n                current_size -= y_i\n            elif current_size >= q_i:\n                current_size += y_i\n            if current_size < 1:\n                return False\n        return current_size >= 1\n    (low, high) = (1, sum((y_i for (_, y_i) in dishes)) + 1)\n    while low < high:\n        mid = (low + high) // 2\n        if can_reach_byteland(mid):\n            high = mid\n        else:\n            low = mid + 1\n    return low"
    }
  ]
}