{
  "task_id": "taco_550",
  "entry_point": "find_minimal_penalty",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 3,
      "original_line": "start -= 1",
      "mutated_line": "start += 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start += 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "end -= 1",
      "mutated_line": "end += 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end += 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "start -= 1",
      "mutated_line": "start -= 2",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 2\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "start -= 1",
      "mutated_line": "start -= 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 0\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "start -= 1",
      "mutated_line": "start -= 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 0\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "start -= 1",
      "mutated_line": "start -= -1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= -1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end -= 1",
      "mutated_line": "end -= 2",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 2\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end -= 1",
      "mutated_line": "end -= 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 0\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end -= 1",
      "mutated_line": "end -= 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 0\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "end -= 1",
      "mutated_line": "end -= -1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= -1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 1\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = -1\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 1\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "forbid = 0",
      "mutated_line": "forbid = 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 1\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "forbid = 0",
      "mutated_line": "forbid = -1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = -1\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "forbid = 0",
      "mutated_line": "forbid = 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 1\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "curbit = 512",
      "mutated_line": "curbit = 513",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 513\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "curbit = 512",
      "mutated_line": "curbit = 511",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 511\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "curbit = 512",
      "mutated_line": "curbit = 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 0\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "curbit = 512",
      "mutated_line": "curbit = 1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 1\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "curbit = 512",
      "mutated_line": "curbit = -512",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = -512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "seen = [False] * n",
      "mutated_line": "seen = [False] / n",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] / n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "seen = [False] * n",
      "mutated_line": "seen = [False] + n",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] + n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "seen = [False] * n",
      "mutated_line": "seen = [False] ** n",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] ** n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return True\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return +1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "curbit >>= 1",
      "mutated_line": "curbit >>= 2",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 2\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "curbit >>= 1",
      "mutated_line": "curbit >>= 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "curbit >>= 1",
      "mutated_line": "curbit >>= 0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 0\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "curbit >>= 1",
      "mutated_line": "curbit >>= -1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= -1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if v == end:",
      "mutated_line": "if v != end:",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v != end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "mutated_line": "stack -= [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack -= [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if not can_reach(0):",
      "mutated_line": "if not can_reach(1):",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(1):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if not can_reach(0):",
      "mutated_line": "if not can_reach(-1):",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(-1):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if not can_reach(0):",
      "mutated_line": "if not can_reach(1):",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(1):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -2\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -0\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -0\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return --1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if can_reach(forbid | curbit):",
      "mutated_line": "if can_reach(forbid & curbit):",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid & curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if can_reach(forbid | curbit):",
      "mutated_line": "if can_reach(forbid ^ curbit):",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid ^ curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 1].append((v + 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v + 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 1].append((v * 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v * 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 1].append((u + 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u + 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 1].append((u * 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u * 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "seen = [False] * n",
      "mutated_line": "seen = [True] * n",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [True] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return False\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "seen[v] = True",
      "mutated_line": "seen[v] = False",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = False\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u + 1].append((v - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u + 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u * 1].append((v - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u * 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 1].append((v - 2, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 2, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 1].append((v - 0, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 0, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 1].append((v - 0, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 0, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 1].append((v - -1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - -1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v + 1].append((u - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v + 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v * 1].append((u - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v * 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 1].append((u - 2, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 2, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 1].append((u - 0, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 0, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 1].append((u - 0, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 0, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 1].append((u - -1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - -1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 2].append((v - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 2].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 0].append((v - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 0].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - 0].append((v - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 0].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "edge[u - 1].append((v - 1, cost))",
      "mutated_line": "edge[u - -1].append((v - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - -1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 2].append((u - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 2].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 0].append((u - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 0].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - 0].append((u - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 0].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "edge[v - 1].append((u - 1, cost))",
      "mutated_line": "edge[v - -1].append((u - 1, cost))",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - -1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "mutated_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid != 0]",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid != 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "mutated_line": "stack += [v2 for (v2, cost) in edge[v] if cost | forbid == 0]",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost | forbid == 0]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "mutated_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 1]",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 1]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "mutated_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == -1]",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == -1]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 0]",
      "mutated_line": "stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 1]",
      "code": "def find_minimal_penalty(n, edges, start, end):\n    start -= 1\n    end -= 1\n    edge = [[] for _ in range(n)]\n    for (u, v, cost) in edges:\n        edge[u - 1].append((v - 1, cost))\n        edge[v - 1].append((u - 1, cost))\n\n    def can_reach(forbid):\n        seen = [False] * n\n        stack = [start]\n        while stack:\n            v = stack.pop()\n            if v == end:\n                return True\n            if not seen[v]:\n                seen[v] = True\n                stack += [v2 for (v2, cost) in edge[v] if cost & forbid == 1]\n        return False\n    if not can_reach(0):\n        return -1\n    ans = 0\n    forbid = 0\n    curbit = 512\n    while curbit:\n        if can_reach(forbid | curbit):\n            forbid |= curbit\n        else:\n            ans |= curbit\n        curbit >>= 1\n    return ans"
    }
  ]
}