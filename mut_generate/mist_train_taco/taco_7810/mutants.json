{
  "task_id": "taco_7810",
  "entry_point": "calculate_ipl_accommodation_ways",
  "mutant_count": 258,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int = 998244353) -> int:",
      "mutated_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244354) -> int:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244354) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int = 998244353) -> int:",
      "mutated_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244352) -> int:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244352) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int = 998244353) -> int:",
      "mutated_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=0) -> int:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=0) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int = 998244353) -> int:",
      "mutated_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=1) -> int:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=1) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int = 998244353) -> int:",
      "mutated_line": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=-998244353) -> int:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=-998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 1\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = -1\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 1\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 2 > r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 > r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 2 < r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 < r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 2 == r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 == r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] / 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] / 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] + 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] + 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] ** 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] ** 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] / 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] / 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] + 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] + 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] ** 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] ** 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n == r and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r and r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 or r > 0 or n > r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 or r > 0 or n > r:\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fball[r][n] = 0",
      "mutated_line": "fball[r][n] = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 1\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fball[r][n] = 0",
      "mutated_line": "fball[r][n] = -1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = -1\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "fball[r][n] = 0",
      "mutated_line": "fball[r][n] = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 1\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 or r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 or r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 2 or r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 or r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 or n > 0 or n >= 2 * r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 or n > 0 or n >= 2 * r:\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cric[r][n] = 0",
      "mutated_line": "cric[r][n] = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 1\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cric[r][n] = 0",
      "mutated_line": "cric[r][n] = -1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = -1\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "cric[r][n] = 0",
      "mutated_line": "cric[r][n] = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 1\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p - q // 2 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p - q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p * (q // 2) >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p * (q // 2) >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 102 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 102 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 100 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 100 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 0 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 0 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 1 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 1 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * -101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * -101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 102 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 102 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 100 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 100 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 0 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 0 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 1 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 1 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * -101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * -101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n != r or r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n != r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n == r or r != 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r != 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fball[r][n] = 1",
      "mutated_line": "fball[r][n] = 2",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 2\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fball[r][n] = 1",
      "mutated_line": "fball[r][n] = 0",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 0\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fball[r][n] = 1",
      "mutated_line": "fball[r][n] = 0",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 0\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "fball[r][n] = 1",
      "mutated_line": "fball[r][n] = -1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = -1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n >= 0 and r > 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n >= 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n <= 0 and r > 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n <= 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n != 0 and r > 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n != 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r >= 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r >= 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r <= 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r <= 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r != 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r != 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r > 0 and (n >= r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n >= r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r > 0 and (n <= r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n <= r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r > 0 and (n != r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n != r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) * MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) * MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD + MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD + MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n != 0 and r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n != 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r != 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r != 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cric[r][n] = 0",
      "mutated_line": "cric[r][n] = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 1\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cric[r][n] = 0",
      "mutated_line": "cric[r][n] = -1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = -1\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cric[r][n] = 0",
      "mutated_line": "cric[r][n] = 1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 1\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n > 2 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n > 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n < 2 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n < 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n == 2 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n == 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 2 and r != 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r != 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cric[r][n] = 1",
      "mutated_line": "cric[r][n] = 2",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 2\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cric[r][n] = 1",
      "mutated_line": "cric[r][n] = 0",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 0\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cric[r][n] = 1",
      "mutated_line": "cric[r][n] = 0",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 0\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cric[r][n] = 1",
      "mutated_line": "cric[r][n] = -1",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = -1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r >= 0 and n > 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r >= 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r <= 0 and n > 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r <= 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r != 0 and n > 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r != 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n >= 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n >= 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n <= 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n <= 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n != 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n != 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n > 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n > 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n < 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n < 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n == 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n == 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) * MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) * MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD + MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD + MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(2, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(2, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(0, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(0, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(0, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(0, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(-1, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(-1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(1, 102):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 102):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(1, 100):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 100):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(1, 0):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 0):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(1, 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 1):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for r in range(1, 101):",
      "mutated_line": "for r in range(1, -101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, -101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q / 2 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q / 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q * 2 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q * 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(2, minv + 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(2, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(0, minv + 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(0, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(0, minv + 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(0, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(-1, minv + 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(-1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(1, minv - 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv - 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(1, minv * 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv * 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i < q // 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i < q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i > q // 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i > q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i == q // 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i == q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[1] * 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[1] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[-1] * 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[-1] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[1] * 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[1] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 101 for _ in range(102)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(102)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 101 for _ in range(100)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(100)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 101 for _ in range(0)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(0)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 101 for _ in range(1)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(1)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "fball = [[0] * 101 for _ in range(101)]",
      "mutated_line": "fball = [[0] * 101 for _ in range(-101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(-101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[1] * 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[1] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[-1] * 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[-1] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[1] * 101 for _ in range(101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[1] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 101 for _ in range(102)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(102)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 101 for _ in range(100)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(100)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 101 for _ in range(0)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(0)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 101 for _ in range(1)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(1)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "cric = [[0] * 101 for _ in range(101)]",
      "mutated_line": "cric = [[0] * 101 for _ in range(-101)]",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(-101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n == r or r == 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 2:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n == r or r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 0:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n == r or r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 0:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if n == r or r == 1:",
      "mutated_line": "if n == r or r == -1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == -1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 1 and r > 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 1 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > -1 and r > 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > -1 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 1 and r > 0 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 1 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r > 1 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 1 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r > -1 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > -1 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if n > 0 and r > 0 and (n > r):",
      "mutated_line": "if n > 0 and r > 1 and (n > r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 1 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD - r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD - r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = fball[r - 1][n - 1] % MOD * (r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = fball[r - 1][n - 1] % MOD * (r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 1 and r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 1 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == -1 and r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == -1 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 1 and r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 1 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 1:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r == -1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == -1:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if n == 0 and r == 0:",
      "mutated_line": "if n == 0 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 1:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 3 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 3 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 1 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 1 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 0 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 0 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 1 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 1 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= -2 and r == 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= -2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 2 and r == 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 2:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 2 and r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 0:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 2 and r == 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 0:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if n >= 2 and r == 1:",
      "mutated_line": "if n >= 2 and r == -1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == -1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 1 and n > 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 1 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > -1 and n > 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > -1 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 1 and n > 0 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 1 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 1 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 1 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > -1 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > -1 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 1 and (n >= 2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 1 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 2 / r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 / r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 2 + r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 + r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 2 ** r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 ** r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD - (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD - (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = r * cric[r][n - 1] % MOD * ((n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = r * cric[r][n - 1] % MOD * ((n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(2, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(2, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(0, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(0, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(0, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(0, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(-1, 101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(-1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(1, 102):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 102):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(1, 100):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 100):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(1, 0):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 0):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(1, 1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 1):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for n in range(1, 101):",
      "mutated_line": "for n in range(1, -101):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, -101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 3 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 3 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 1 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 1 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 0 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 0 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // 1 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 1 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if p + q // 2 >= r:",
      "mutated_line": "if p + q // -2 >= r:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // -2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(1, minv + 2):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 2):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(1, minv + 0):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 0):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(1, minv + 0):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 0):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for i in range(1, minv + 1):",
      "mutated_line": "for i in range(1, minv + -1):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + -1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r + i <= q // 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r + i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r * i <= q // 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r * i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q / 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q / 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q * 2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q * 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) * MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) * MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = ans + fball[i][p] * cric[r - i][q] % MOD + MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = ans + fball[i][p] * cric[r - i][q] % MOD + MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] * MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] * MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] + MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] + MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] * MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] * MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + (r * fball[r][n - 1] + MOD)) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + (r * fball[r][n - 1] + MOD)) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 3 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 3 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 1 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 1 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 0 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 0 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= 1 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 1 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if r > 0 and n > 0 and (n >= 2 * r):",
      "mutated_line": "if r > 0 and n > 0 and (n >= -2 * r):",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= -2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] * MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] * MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] + MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] + MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] * MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] * MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + ((n - 1) * cric[r - 1][n - 2] + MOD)) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + ((n - 1) * cric[r - 1][n - 2] + MOD)) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q // 3:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 3:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q // 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 1:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q // 0:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 0:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q // 1:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 1:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if r - i <= q // 2:",
      "mutated_line": "if r - i <= q // -2:",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // -2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans - fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans - fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = ans * (fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = ans * (fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r / fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r / fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + (r + fball[r][n - 1]) % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + (r + fball[r][n - 1]) % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r ** fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r ** fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r / cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r / cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = ((r + cric[r][n - 1]) % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = ((r + cric[r][n - 1]) % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r ** cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r ** cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) / cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) / cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1 + cric[r - 1][n - 2]) % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1 + cric[r - 1][n - 2]) % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) ** cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) ** cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + fball[i][p] * cric[r - i][q] * MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] * MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + (fball[i][p] * cric[r - i][q] + MOD)) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + (fball[i][p] * cric[r - i][q] + MOD)) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n + 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n + 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n * 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n * 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n + 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n + 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + n * 1 * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + n * 1 * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + fball[i][p] / cric[r - i][q] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] / cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + (fball[i][p] + cric[r - i][q]) % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + (fball[i][p] + cric[r - i][q]) % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + fball[i][p] ** cric[r - i][q] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] ** cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r + 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r + 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r * 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r * 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 2] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 2] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 0] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 0] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 0] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 0] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - -1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - -1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n + 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n + 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n * 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n * 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n + 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n + 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n * 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n * 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 2) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 2) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 0) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 0) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 0) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 0) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - -1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - -1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n + 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n + 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n * 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n * 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 2][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 2][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 0][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 0][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 0][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 0][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - -1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - -1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 2] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 0] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 0] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 0] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 0] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD",
      "mutated_line": "fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - -1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - -1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 2] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 2] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 0] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 0] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 0] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 0] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - -1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - -1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r + 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r + 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r * 1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r * 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 3] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 3] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 1] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 0] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 0] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 1] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 1] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - -2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - -2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 2][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 2][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 0][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 0][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 0][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 0][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD",
      "mutated_line": "cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - -1][n - 2] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - -1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + fball[i][p] * cric[r + i][q] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r + i][q] % MOD) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "ans = (ans + fball[i][p] * cric[r - i][q] % MOD) % MOD",
      "mutated_line": "ans = (ans + fball[i][p] * cric[r * i][q] % MOD) % MOD",
      "code": "def calculate_ipl_accommodation_ways(p: int, q: int, r: int, MOD: int=998244353) -> int:\n    fball = [[0] * 101 for _ in range(101)]\n    cric = [[0] * 101 for _ in range(101)]\n\n    def calSNum(n, r):\n        if n == r or r == 1:\n            fball[r][n] = 1\n            return\n        if n > 0 and r > 0 and (n > r):\n            fball[r][n] = (fball[r - 1][n - 1] % MOD + r * fball[r][n - 1] % MOD) % MOD\n            return\n        fball[r][n] = 0\n\n    def calASNum(n, r):\n        if n == 0 and r == 0:\n            cric[r][n] = 0\n            return\n        if n >= 2 and r == 1:\n            cric[r][n] = 1\n            return\n        if r > 0 and n > 0 and (n >= 2 * r):\n            cric[r][n] = (r * cric[r][n - 1] % MOD + (n - 1) * cric[r - 1][n - 2] % MOD) % MOD\n            return\n        cric[r][n] = 0\n\n    def preCompute():\n        for r in range(1, 101):\n            for n in range(1, 101):\n                calSNum(n, r)\n                calASNum(n, r)\n    preCompute()\n    ans = 0\n    if p + q // 2 >= r:\n        minv = min(p, r)\n        for i in range(1, minv + 1):\n            if r - i <= q // 2:\n                ans = (ans + fball[i][p] * cric[r * i][q] % MOD) % MOD\n    return ans"
    }
  ]
}