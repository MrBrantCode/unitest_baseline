{
  "task_id": "taco_5290",
  "entry_point": "generate_lexicographically_minimal_calendar",
  "mutant_count": 26,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n / 2",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n / 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n * 2",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n * 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "line_length = total_length // num_lines",
      "mutated_line": "line_length = total_length / num_lines",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length / num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "line_length = total_length // num_lines",
      "mutated_line": "line_length = total_length * num_lines",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length * num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n // 3",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 3\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n // 1",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 1\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n // 0",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 0\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n // 1",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 1\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "num_lines = n // 2",
      "mutated_line": "num_lines = n // -2",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // -2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "sorted_city_names = sorted(city_names, reverse=True)",
      "mutated_line": "total_length = sum((len(city) for city in sorted_city_names))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=False)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if len(x) + len(y) == line_length:",
      "mutated_line": "if len(x) + len(y) != line_length:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) != line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "for y in sorted_city_names[::-1]:",
      "mutated_line": "for y in sorted_city_names[::+1]:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::+1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if len(x) + len(y) == line_length:",
      "mutated_line": "if len(x) - len(y) == line_length:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) - len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if len(x) + len(y) == line_length:",
      "mutated_line": "if len(x) * len(y) == line_length:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) * len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for y in sorted_city_names[::-1]:",
      "mutated_line": "for y in sorted_city_names[::-2]:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-2]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for y in sorted_city_names[::-1]:",
      "mutated_line": "for y in sorted_city_names[::-0]:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-0]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for y in sorted_city_names[::-1]:",
      "mutated_line": "for y in sorted_city_names[::-0]:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-0]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "for y in sorted_city_names[::-1]:",
      "mutated_line": "for y in sorted_city_names[::--1]:",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::--1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x + separator - y, y + separator + x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator - y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min((x + separator) * y, y + separator + x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min((x + separator) * y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x + separator + y, y + separator - x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y + separator - x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x + separator + y, (y + separator) * x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, (y + separator) * x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x - separator + y, y + separator + x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x - separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x * separator + y, y + separator + x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x * separator + y, y + separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x + separator + y, y - separator + x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y - separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "calendar_lines.append(min(x + separator + y, y + separator + x))",
      "mutated_line": "calendar_lines.append(min(x + separator + y, y * separator + x))",
      "code": "def generate_lexicographically_minimal_calendar(n, city_names, separator):\n    num_lines = n // 2\n    sorted_city_names = sorted(city_names, reverse=True)\n    total_length = sum((len(city) for city in sorted_city_names))\n    line_length = total_length // num_lines\n    calendar_lines = []\n    for _ in range(num_lines):\n        x = sorted_city_names.pop()\n        for y in sorted_city_names[::-1]:\n            if len(x) + len(y) == line_length:\n                calendar_lines.append(min(x + separator + y, y * separator + x))\n                sorted_city_names.remove(y)\n                break\n    return sorted(calendar_lines)"
    }
  ]
}