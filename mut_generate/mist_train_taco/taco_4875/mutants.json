{
  "task_id": "taco_4875",
  "entry_point": "max_good_subset_size",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if N == 0:",
      "mutated_line": "if N != 0:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N != 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 1\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = -1\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 1\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "b = -1",
      "mutated_line": "b = +1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = +1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e = 0",
      "mutated_line": "e = 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 1\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e = 0",
      "mutated_line": "e = -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = -1\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "e = 0",
      "mutated_line": "e = 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 1\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "processed_num = 0",
      "mutated_line": "processed_num = 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 1\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "processed_num = 0",
      "mutated_line": "processed_num = -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = -1\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "processed_num = 0",
      "mutated_line": "processed_num = 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 1\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 1:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N == 0:",
      "mutated_line": "if N == -1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == -1:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N == 0:",
      "mutated_line": "if N == 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 1:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = -1",
      "mutated_line": "b = -2",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -2\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = -1",
      "mutated_line": "b = -0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -0\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = -1",
      "mutated_line": "b = -0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -0\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "b = -1",
      "mutated_line": "b = --1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = --1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b <= N - 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b <= N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b >= N - 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b >= N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b != N - 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b != N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if mas_p[cur_p_i][2] in processed_p:",
      "mutated_line": "if mas_p[cur_p_i][2] not in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] not in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "e -= mas_p[cur_p_i][1]",
      "mutated_line": "e += mas_p[cur_p_i][1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e += mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num -= 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num -= 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(1)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(-1)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(-1)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "results.append(0)",
      "mutated_line": "results.append(1)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(1)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = mas_p[cur_p_i][0]",
      "mutated_line": "p = mas_p[cur_p_i][1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][1]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = mas_p[cur_p_i][0]",
      "mutated_line": "p = mas_p[cur_p_i][-1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][-1]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = mas_p[cur_p_i][0]",
      "mutated_line": "p = mas_p[cur_p_i][1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][1]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b < N + 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N + 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b < N * 1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N * 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 1][2] not in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] not in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "b += 1",
      "mutated_line": "b -= 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b -= 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num -= 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num -= 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) > e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) > e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) < e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) < e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) == e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) == e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "b += 1",
      "mutated_line": "b -= 1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b -= 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "e += mas_e[b][1]",
      "mutated_line": "e -= mas_e[b][1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e -= mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += 2",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 2\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 0\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 0\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += -1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b < N - 2:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 2:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b < N - 0:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 0:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b < N - 0:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 0:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while b < N - 1:",
      "mutated_line": "while b < N - -1:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - -1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b += 1",
      "mutated_line": "b += 2",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 2\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 0\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 0\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "b += 1",
      "mutated_line": "b += -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += -1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += 2",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 2\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 0\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 0\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "processed_num += 1",
      "mutated_line": "processed_num += -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += -1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p / (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p / (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p + (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p + (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p ** (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p ** (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e - mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e - mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e * mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e * mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b += 1",
      "mutated_line": "b += 2",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 2\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 0\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b += 1",
      "mutated_line": "b += 0",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 0\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "b += 1",
      "mutated_line": "b += -1",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += -1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mas_p[cur_p_i][2] in processed_p:",
      "mutated_line": "if mas_p[cur_p_i][3] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][3] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mas_p[cur_p_i][2] in processed_p:",
      "mutated_line": "if mas_p[cur_p_i][1] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][1] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mas_p[cur_p_i][2] in processed_p:",
      "mutated_line": "if mas_p[cur_p_i][0] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][0] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mas_p[cur_p_i][2] in processed_p:",
      "mutated_line": "if mas_p[cur_p_i][1] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][1] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if mas_p[cur_p_i][2] in processed_p:",
      "mutated_line": "if mas_p[cur_p_i][-2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][-2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b + 1 + processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 + processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, (b + 1) * processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, (b + 1) * processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "e -= mas_p[cur_p_i][1]",
      "mutated_line": "e -= mas_p[cur_p_i][2]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][2]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "e -= mas_p[cur_p_i][1]",
      "mutated_line": "e -= mas_p[cur_p_i][0]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][0]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "e -= mas_p[cur_p_i][1]",
      "mutated_line": "e -= mas_p[cur_p_i][0]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][0]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "e -= mas_p[cur_p_i][1]",
      "mutated_line": "e -= mas_p[cur_p_i][-1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][-1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mas_e.sort(key=lambda el: el[1])",
      "mutated_line": "mas_e.sort(key=lambda el: el[2])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[2])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mas_e.sort(key=lambda el: el[1])",
      "mutated_line": "mas_e.sort(key=lambda el: el[0])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[0])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mas_e.sort(key=lambda el: el[1])",
      "mutated_line": "mas_e.sort(key=lambda el: el[0])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[0])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "mas_e.sort(key=lambda el: el[1])",
      "mutated_line": "mas_e.sort(key=lambda el: el[-1])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[-1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[0], +el[1]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], +el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 1][3] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][3] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 1][1] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][1] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 1][0] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][0] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 1][1] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][1] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 1][-2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][-2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 + processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 + processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * ((b + 1 + 1) * processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * ((b + 1 + 1) * processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += mas_e[b][1]",
      "mutated_line": "e += mas_e[b][2]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][2]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += mas_e[b][1]",
      "mutated_line": "e += mas_e[b][0]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][0]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += mas_e[b][1]",
      "mutated_line": "e += mas_e[b][0]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][0]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "e += mas_e[b][1]",
      "mutated_line": "e += mas_e[b][-1]",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][-1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b - 1 - processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b - 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b * 1 - processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b * 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "processed_p.add(mas_p[cur_p_i][2])",
      "mutated_line": "processed_p.add(mas_p[cur_p_i][3])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][3])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "processed_p.add(mas_p[cur_p_i][2])",
      "mutated_line": "processed_p.add(mas_p[cur_p_i][1])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][1])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "processed_p.add(mas_p[cur_p_i][2])",
      "mutated_line": "processed_p.add(mas_p[cur_p_i][0])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][0])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "processed_p.add(mas_p[cur_p_i][2])",
      "mutated_line": "processed_p.add(mas_p[cur_p_i][1])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][1])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "processed_p.add(mas_p[cur_p_i][2])",
      "mutated_line": "processed_p.add(mas_p[cur_p_i][-2])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][-2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[1], -el[1]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[1], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[-1], -el[1]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[-1], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[1], -el[1]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[1], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b - 1][2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b - 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b * 1][2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b * 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 - 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 - 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * ((b + 1) * 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * ((b + 1) * 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][2]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][2]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][0]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][0]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][0]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][0]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][-1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][-1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "processed_p.add(mas_e[b][2])",
      "mutated_line": "processed_p.add(mas_e[b][3])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][3])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "processed_p.add(mas_e[b][2])",
      "mutated_line": "processed_p.add(mas_e[b][1])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][1])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "processed_p.add(mas_e[b][2])",
      "mutated_line": "processed_p.add(mas_e[b][0])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][0])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "processed_p.add(mas_e[b][2])",
      "mutated_line": "processed_p.add(mas_e[b][1])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][1])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "processed_p.add(mas_e[b][2])",
      "mutated_line": "processed_p.add(mas_e[b][-2])",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][-2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b + 2 - processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 2 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b + 0 - processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 0 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b + 0 - processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 0 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans = max(ans, b + 1 - processed_num)",
      "mutated_line": "ans = max(ans, b + -1 - processed_num)",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + -1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[0], -el[2]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[2]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[0], -el[0]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[0]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[0], -el[0]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[0]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "mas_p.sort(key=lambda el: (el[0], -el[1]))",
      "mutated_line": "mas_p.sort(key=lambda el: (el[0], -el[-1]))",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[-1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 2][2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 2][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 0][2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 0][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + 0][2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 0][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if mas_e[b + 1][2] in processed_p:",
      "mutated_line": "if mas_e[b + -1][2] in processed_p:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + -1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b - 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b - 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b * 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b * 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 2 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 2 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 0 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 0 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 0 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 0 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + -1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + -1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b - 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b - 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b * 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b * 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 2 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 2 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 0 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 0 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 0 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 0 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + -1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + -1 + 1 - processed_num) >= e + mas_e[b + 1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 2][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 2][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 0][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 0][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 0][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 0][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + 1][1]:",
      "mutated_line": "if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + -1][1]:",
      "code": "def max_good_subset_size(test_cases):\n    results = []\n    for minions in test_cases:\n        N = len(minions)\n        if N == 0:\n            results.append(0)\n            continue\n        mas_p = [(a, b, i) for (i, (a, b)) in enumerate(minions)]\n        mas_e = mas_p[:]\n        mas_e.sort(key=lambda el: el[1])\n        mas_p.sort(key=lambda el: (el[0], -el[1]))\n        ans = 0\n        b = -1\n        e = 0\n        processed_p = set()\n        processed_num = 0\n        for cur_p_i in range(N):\n            p = mas_p[cur_p_i][0]\n            while b < N - 1:\n                if mas_e[b + 1][2] in processed_p:\n                    b += 1\n                    processed_num += 1\n                    continue\n                if p * (b + 1 + 1 - processed_num) >= e + mas_e[b + -1][1]:\n                    b += 1\n                    e += mas_e[b][1]\n                    processed_p.add(mas_e[b][2])\n                    continue\n                else:\n                    break\n            if mas_p[cur_p_i][2] in processed_p:\n                ans = max(ans, b + 1 - processed_num)\n                e -= mas_p[cur_p_i][1]\n                processed_num += 1\n            else:\n                processed_p.add(mas_p[cur_p_i][2])\n        results.append(ans)\n    return results"
    }
  ]
}