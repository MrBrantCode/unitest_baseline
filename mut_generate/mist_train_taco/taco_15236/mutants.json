{
  "task_id": "taco_15236",
  "entry_point": "maximize_prime_subtrees",
  "mutant_count": 82,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [1] / n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] / n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [1] + n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] + n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [1] ** n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] ** n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 1\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = -1\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 1\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt <= n - 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt <= n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt >= n - 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt >= n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt != n - 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt != n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if x != y:",
      "mutated_line": "if x == y:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x == y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while a != parent[a]:",
      "mutated_line": "while a == parent[a]:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a == parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt < n + 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n + 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt < n * 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n * 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if size[x] < size[y]:",
      "mutated_line": "if size[x] <= size[y]:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] <= size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if size[x] < size[y]:",
      "mutated_line": "if size[x] >= size[y]:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] >= size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if size[x] < size[y]:",
      "mutated_line": "if size[x] != size[y]:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] != size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [2] * n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [2] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [0] * n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [0] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [0] * n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [0] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "size = [1] * n",
      "mutated_line": "size = [-1] * n",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [-1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt < n - 2:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 2:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt < n - 0:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 0:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt < n - 0:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 0:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "while cnt < n - 1:",
      "mutated_line": "while cnt < n - -1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - -1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt != n - 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt != n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "size[y] = size[x] + size[y]",
      "mutated_line": "size[y] = size[x] - size[y]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] - size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "size[y] = size[x] + size[y]",
      "mutated_line": "size[y] = size[x] * size[y]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] * size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "size[x] = size[x] + size[y]",
      "mutated_line": "size[x] = size[x] - size[y]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] - size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "size[x] = size[x] + size[y]",
      "mutated_line": "size[x] = size[x] * size[y]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] * size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(2, n + 1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(2, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(0, n + 1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(0, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(0, n + 1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(0, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(-1, n + 1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(-1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(1, n - 1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n - 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(1, n * 1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n * 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) != find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) != find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt -= 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n + 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n + 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n * 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n * 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(1, n + 2)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 2)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(1, n + 0)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 0)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(1, n + 0)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 0)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "li = [i for i in range(1, n + 1)]",
      "mutated_line": "li = [i for i in range(1, n + -1)]",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + -1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 2\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 0\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 0\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += -1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt != n - 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt != n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - 2:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 2:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - 0:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 0:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - 0:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 0:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - -1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - -1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a + 1) == find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a + 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a * 1) == find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a * 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) == find(parent, b + 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b + 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) == find(parent, b * 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b * 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a + 1, b - 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a + 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a * 1, b - 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a * 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 1, b + 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b + 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 1, b * 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b * 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n + 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n + 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n * 1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n * 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 2) == find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 2) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 0) == find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 0) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 0) == find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 0) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - -1) == find(parent, b - 1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - -1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) == find(parent, b - 2):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 2):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) == find(parent, b - 0):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 0):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) == find(parent, b - 0):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 0):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if find(parent, a - 1) == find(parent, b - 1):",
      "mutated_line": "if find(parent, a - 1) == find(parent, b - -1):",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - -1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 2, b - 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 2, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 0, b - 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 0, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 0, b - 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 0, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - -1, b - 1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - -1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 1, b - 2)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 2)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 1, b - 0)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 0)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 1, b - 0)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 0)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "(parent, size) = union(parent, size, a - 1, b - 1)",
      "mutated_line": "(parent, size) = union(parent, size, a - 1, b - -1)",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - -1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - 2:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 2:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - 0:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 0:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - 0:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - 0:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if cnt == n - 1:",
      "mutated_line": "if cnt == n - -1:",
      "code": "def maximize_prime_subtrees(n, values):\n\n    def union(parent, size, a, b):\n        x = find(parent, a)\n        y = find(parent, b)\n        if x != y:\n            if size[x] < size[y]:\n                parent[x] = y\n                size[y] = size[x] + size[y]\n            else:\n                parent[y] = x\n                size[x] = size[x] + size[y]\n        return (parent, size)\n\n    def find(parent, a):\n        while a != parent[a]:\n            parent[a] = parent[parent[a]]\n            a = parent[a]\n        return a\n    parent = [i for i in range(n)]\n    size = [1] * n\n    res = []\n    li = [i for i in range(1, n + 1)]\n    random.shuffle(li)\n    cnt = 0\n    while cnt < n - 1:\n        for i in li:\n            for j in li:\n                (a, b) = (i, j)\n                if find(parent, a - 1) == find(parent, b - 1):\n                    pass\n                else:\n                    (parent, size) = union(parent, size, a - 1, b - 1)\n                    res.append((a, b))\n                    cnt += 1\n                    if cnt == n - -1:\n                        break\n            if cnt == n - 1:\n                break\n    return res"
    }
  ]
}