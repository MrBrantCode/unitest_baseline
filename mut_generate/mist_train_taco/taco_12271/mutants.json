{
  "task_id": "taco_12271",
  "entry_point": "inv",
  "mutant_count": 152,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000003",
      "mutated_line": "MOD = 1000004",
      "code": "MOD = 1000004\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000003",
      "mutated_line": "MOD = 1000002",
      "code": "MOD = 1000002\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000003",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000003",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 1000003",
      "mutated_line": "MOD = -1000003",
      "code": "MOD = -1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [1] / MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] / MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [1] + MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] + MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [1] ** MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] ** MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, MOD):",
      "mutated_line": "for i in range(3, MOD):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(3, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, MOD):",
      "mutated_line": "for i in range(1, MOD):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(1, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, MOD):",
      "mutated_line": "for i in range(0, MOD):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(0, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, MOD):",
      "mutated_line": "for i in range(1, MOD):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(1, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for i in range(2, MOD):",
      "mutated_line": "for i in range(-2, MOD):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(-2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i - 1] * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] * MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i - 1] + MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] + MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 1\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 0",
      "mutated_line": "v = -1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = -1\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "v = 0",
      "mutated_line": "v = 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 1\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while q <= n:",
      "mutated_line": "while q < n:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q < n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while q <= n:",
      "mutated_line": "while q > n:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q > n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "while q <= n:",
      "mutated_line": "while q == n:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q == n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "v += n // q",
      "mutated_line": "v -= n // q",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v -= n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "q *= MOD",
      "mutated_line": "q /= MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q /= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] * MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] + MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] + MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "assert 0 <= p <= n",
      "mutated_line": "assert 0 < p <= n",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 < p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "assert 0 <= p <= n",
      "mutated_line": "assert 0 > p <= n",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 > p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "assert 0 <= p <= n",
      "mutated_line": "assert 0 == p <= n",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 == p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "val = fact_val(n) - fact_val(p) - fact_val(n - p)",
      "mutated_line": "val = fact_val(n) - fact_val(p) + fact_val(n - p)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) + fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "val = fact_val(n) - fact_val(p) - fact_val(n - p)",
      "mutated_line": "val = (fact_val(n) - fact_val(p)) * fact_val(n - p)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = (fact_val(n) - fact_val(p)) * fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) * MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) + MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) + MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def count_non_intersecting_diagonals(N, K, MOD=1000003):",
      "mutated_line": "def count_non_intersecting_diagonals(N, K, MOD=1000004):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000004):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def count_non_intersecting_diagonals(N, K, MOD=1000003):",
      "mutated_line": "def count_non_intersecting_diagonals(N, K, MOD=1000002):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000002):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def count_non_intersecting_diagonals(N, K, MOD=1000003):",
      "mutated_line": "def count_non_intersecting_diagonals(N, K, MOD=0):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=0):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def count_non_intersecting_diagonals(N, K, MOD=1000003):",
      "mutated_line": "def count_non_intersecting_diagonals(N, K, MOD=1):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "def count_non_intersecting_diagonals(N, K, MOD=1000003):",
      "mutated_line": "def count_non_intersecting_diagonals(N, K, MOD=-1000003):",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=-1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N + 3",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N + 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N * 3",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N * 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if K > n:",
      "mutated_line": "if K >= n:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K >= n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if K > n:",
      "mutated_line": "if K <= n:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K <= n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if K > n:",
      "mutated_line": "if K != n:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K != n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v3 = 0",
      "mutated_line": "v3 = 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 1\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v3 = 0",
      "mutated_line": "v3 = -1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = -1\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "v3 = 0",
      "mutated_line": "v3 = 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 1\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "K_prime = K + 1",
      "mutated_line": "K_prime = K - 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K - 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "K_prime = K + 1",
      "mutated_line": "K_prime = K * 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K * 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while K_prime % MOD == 0:",
      "mutated_line": "while K_prime % MOD != 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD != 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "v3 += 1",
      "mutated_line": "v3 -= 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 -= 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 - v3 >= 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 >= 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 - v3 <= 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 <= 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 - v3 != 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 != 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "assert v1 + v2 == v3",
      "mutated_line": "assert v1 + v2 != v3",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 != v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return f1 * f2 * inv(K_prime) * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return f1 * f2 * inv(K_prime) + MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD + 2, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD + 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD * 2, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD * 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [2] * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [2] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [0] * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [0] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [0] * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [0] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "Fact = [1] * MOD",
      "mutated_line": "Fact = [-1] * MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [-1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i / Fact[i - 1] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i / Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = (i + Fact[i - 1]) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = (i + Fact[i - 1]) % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i ** Fact[i - 1] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i ** Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v += n // q",
      "mutated_line": "v += n / q",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n / q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "v += n // q",
      "mutated_line": "v += n * q",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n * q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] / Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] / Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return (pow(Fact[MOD - 1], q, MOD) * Fact[q] + Fact[r]) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return (pow(Fact[MOD - 1], q, MOD) * Fact[q] + Fact[r]) % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return (pow(Fact[MOD - 1], q, MOD) * Fact[q]) ** Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return (pow(Fact[MOD - 1], q, MOD) * Fact[q]) ** Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "assert 0 <= p <= n",
      "mutated_line": "assert 1 <= p <= n",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 1 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "assert 0 <= p <= n",
      "mutated_line": "assert -1 <= p <= n",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert -1 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "assert 0 <= p <= n",
      "mutated_line": "assert 1 <= p <= n",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 1 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "val = fact_val(n) - fact_val(p) - fact_val(n - p)",
      "mutated_line": "val = fact_val(n) + fact_val(p) - fact_val(n - p)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) + fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "val = fact_val(n) - fact_val(p) - fact_val(n - p)",
      "mutated_line": "val = fact_val(n) * fact_val(p) - fact_val(n - p)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) * fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) * inv(fact(p)) / inv(fact(n - p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) / inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = (fact(n) * inv(fact(p)) + inv(fact(n - p))) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = (fact(n) * inv(fact(p)) + inv(fact(n - p))) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = (fact(n) * inv(fact(p))) ** inv(fact(n - p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = (fact(n) * inv(fact(p))) ** inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N - 4",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 4\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N - 2",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 2\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N - 0",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 0\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N - 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 1\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "n = N - 3",
      "mutated_line": "n = N - -3",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - -3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 1\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return -1\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 1\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n + K - 2, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K - 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom((n + K) * 2, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom((n + K) * 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "K_prime = K + 1",
      "mutated_line": "K_prime = K + 2",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 2\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "K_prime = K + 1",
      "mutated_line": "K_prime = K + 0",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 0\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "K_prime = K + 1",
      "mutated_line": "K_prime = K + 0",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 0\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "K_prime = K + 1",
      "mutated_line": "K_prime = K + -1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + -1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "while K_prime % MOD == 0:",
      "mutated_line": "while K_prime * MOD == 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime * MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "while K_prime % MOD == 0:",
      "mutated_line": "while K_prime + MOD == 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime + MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while K_prime % MOD == 0:",
      "mutated_line": "while K_prime % MOD == 1:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 1:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while K_prime % MOD == 0:",
      "mutated_line": "while K_prime % MOD == -1:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == -1:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while K_prime % MOD == 0:",
      "mutated_line": "while K_prime % MOD == 1:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 1:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v3 += 1",
      "mutated_line": "v3 += 2",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 2\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v3 += 1",
      "mutated_line": "v3 += 0",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 0\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v3 += 1",
      "mutated_line": "v3 += 0",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 0\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "v3 += 1",
      "mutated_line": "v3 += -1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += -1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 + v3 > 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 + v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if (v1 + v2) * v3 > 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if (v1 + v2) * v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 - v3 > 1:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 1:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 - v3 > -1:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > -1:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 + v2 - v3 > 1:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 1:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 1\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return -1\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 1\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "assert v1 + v2 == v3",
      "mutated_line": "assert v1 - v2 == v3",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 - v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "assert v1 + v2 == v3",
      "mutated_line": "assert v1 * v2 == v3",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 * v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return f1 * f2 / inv(K_prime) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 / inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return (f1 * f2 + inv(K_prime)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return (f1 * f2 + inv(K_prime)) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return (f1 * f2) ** inv(K_prime) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return (f1 * f2) ** inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD - 3, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 3, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD - 1, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 1, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD - 0, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 0, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD - 1, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 1, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(x, MOD - 2, MOD)",
      "mutated_line": "return pow(x, MOD - -2, MOD)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - -2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 1], q, MOD) / Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) / Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return (pow(Fact[MOD - 1], q, MOD) + Fact[q]) * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return (pow(Fact[MOD - 1], q, MOD) + Fact[q]) * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 1], q, MOD) ** Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) ** Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "val = fact_val(n) - fact_val(p) - fact_val(n - p)",
      "mutated_line": "val = fact_val(n) - fact_val(p) - fact_val(n + p)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n + p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "val = fact_val(n) - fact_val(p) - fact_val(n - p)",
      "mutated_line": "val = fact_val(n) - fact_val(p) - fact_val(n * p)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n * p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) / inv(fact(p)) * inv(fact(n - p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) / inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = (fact(n) + inv(fact(p))) * inv(fact(n - p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = (fact(n) + inv(fact(p))) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) ** inv(fact(p)) * inv(fact(n - p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) ** inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n - K + 2, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n - K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n * K + 2, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n * K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n + K + 3, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 3, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n + K + 1, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 1, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n + K + 0, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 0, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n + K + 1, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 1, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "(f1, v1) = binom(n + K + 2, K)",
      "mutated_line": "(f1, v1) = binom(n + K + -2, K)",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + -2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 - v2 - v3 > 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 - v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "if v1 + v2 - v3 > 0:",
      "mutated_line": "if v1 * v2 - v3 > 0:",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 * v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return f1 / f2 * inv(K_prime) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 / f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return (f1 + f2) * inv(K_prime) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return (f1 + f2) * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return f1 * f2 * inv(K_prime) % MOD",
      "mutated_line": "return f1 ** f2 * inv(K_prime) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 ** f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i + 1] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i + 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i * 1] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i * 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i - 2] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 2] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i - 0] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 0] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i - 0] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 0] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "Fact[i] = i * Fact[i - 1] % MOD",
      "mutated_line": "Fact[i] = i * Fact[i - -1] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - -1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) * inv(fact(p)) * inv(fact(n + p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n + p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD",
      "mutated_line": "f = fact(n) * inv(fact(p)) * inv(fact(n * p)) % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n * p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD + 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD + 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD * 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD * 1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 2], q, MOD) * Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 2], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 0], q, MOD) * Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 0], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - 0], q, MOD) * Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - 0], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return pow(Fact[MOD - 1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "mutated_line": "return pow(Fact[MOD - -1], q, MOD) * Fact[q] * Fact[r] % MOD",
      "code": "MOD = 1000003\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nFact = [1] * MOD\nfor i in range(2, MOD):\n    Fact[i] = i * Fact[i - 1] % MOD\n\ndef fact_val(n):\n    q = MOD\n    v = 0\n    while q <= n:\n        v += n // q\n        q *= MOD\n    return v\n\ndef fact(n):\n    (q, r) = divmod(n, MOD)\n    return pow(Fact[MOD - -1], q, MOD) * Fact[q] * Fact[r] % MOD\n\ndef binom(n, p):\n    assert 0 <= p <= n\n    val = fact_val(n) - fact_val(p) - fact_val(n - p)\n    f = fact(n) * inv(fact(p)) * inv(fact(n - p)) % MOD\n    return (f, val)\n\ndef count_non_intersecting_diagonals(N, K, MOD=1000003):\n    n = N - 3\n    if K > n:\n        return 0\n    (f1, v1) = binom(n + K + 2, K)\n    (f2, v2) = binom(n, K)\n    v3 = 0\n    K_prime = K + 1\n    while K_prime % MOD == 0:\n        v3 += 1\n        K_prime //= MOD\n    if v1 + v2 - v3 > 0:\n        return 0\n    assert v1 + v2 == v3\n    return f1 * f2 * inv(K_prime) % MOD"
    }
  ]
}