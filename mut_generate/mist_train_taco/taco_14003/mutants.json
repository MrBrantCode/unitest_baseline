{
  "task_id": "taco_14003",
  "entry_point": "min_moves_and_sequences",
  "mutant_count": 171,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 - 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 * 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] / (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] / (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] + (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] + (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] ** (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] ** (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] / (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] / (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] + (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] + (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] ** (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] ** (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[0] = +1000",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = +1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[0] = 2",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 2\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[0] = 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 0\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[0] = 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 0\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[0] = -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = -1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[0] = 0",
      "mutated_line": "f[0] = 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 1\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[0] = 0",
      "mutated_line": "f[0] = -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = -1\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[0] = 0",
      "mutated_line": "f[0] = 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 1\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 * 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 + 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 8\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 6\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 0\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 1\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + -7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "positions = [0]",
      "mutated_line": "positions = [1]",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [1]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "positions = [0]",
      "mutated_line": "positions = [-1]",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [-1]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "positions = [0]",
      "mutated_line": "positions = [1]",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [1]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) - len(t) - 1):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) - 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range((len(s) - len(t)) * 1):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range((len(s) - len(t)) * 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if s[i:i + len(t)] == t:",
      "mutated_line": "if s[i:i + len(t)] != t:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] != t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] * (len(positions) - 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) - 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] * (len(positions) * 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) * 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] * (len(positions) - 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) - 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] * (len(positions) * 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) * 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[1] = -1000",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[1] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[-1] = -1000",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[-1] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[1] = -1000",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[1] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[0] = -1001",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1001\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[0] = -999",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -999\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[0] = -0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -0\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[0] = -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "positions[0] = -1000",
      "mutated_line": "positions[0] = --1000",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = --1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[1] = 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[1] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[-1] = 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[-1] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "g[0] = 1",
      "mutated_line": "g[1] = 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[1] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[0] = 0",
      "mutated_line": "f[1] = 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[1] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[0] = 0",
      "mutated_line": "f[-1] = 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[-1] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[0] = 0",
      "mutated_line": "f[1] = 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[1] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "positions.append(len(s) + len(t))",
      "mutated_line": "positions.append(len(s) - len(t))",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) - len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "positions.append(len(s) + len(t))",
      "mutated_line": "positions.append(len(s) * len(t))",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) * len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = i + 1",
      "mutated_line": "j = i - 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i - 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "j = i + 1",
      "mutated_line": "j = i * 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i * 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) or positions[j] <= positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) or positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j -= 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) or positions[k] <= positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) or positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k -= 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] + 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] + 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] * 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] * 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 11 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 9 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 0 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 1 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = -10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 10 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 8 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 0 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 1 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10**9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** -9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) + len(t) + 1):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) + len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) * len(t) + 1):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) * len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) - len(t) + 2):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 2):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) - len(t) + 0):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 0):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) - len(t) + 0):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 0):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(s) - len(t) + 1):",
      "mutated_line": "for i in range(len(s) - len(t) + -1):",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + -1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1001] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1001] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [999] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [999] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [0] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [0] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [-1000] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [-1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] * (len(positions) + 2)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 2)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] * (len(positions) + 0)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 0)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] * (len(positions) + 0)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 0)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "f = [1000] * (len(positions) + 1)",
      "mutated_line": "f = [1000] * (len(positions) + -1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + -1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [1] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [1] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [-1] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [-1] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [1] * (len(positions) + 1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [1] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] * (len(positions) + 2)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 2)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] * (len(positions) + 0)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 0)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] * (len(positions) + 0)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 0)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "g = [0] * (len(positions) + 1)",
      "mutated_line": "g = [0] * (len(positions) + -1)",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + -1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 2",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 2\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 0\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 0\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = i + 1",
      "mutated_line": "j = i + -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + -1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j <= len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j <= len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j >= len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j >= len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j != len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j != len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] < positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] < positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] > positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] > positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] == positions[i] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] == positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 2\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 0\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 0\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += -1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k <= len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k <= len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k >= len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k >= len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k != len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k != len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] < positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] < positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] > positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] > positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] == positions[j] + len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] == positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + 1 <= f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 <= f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + 1 >= f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 >= f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + 1 != f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 != f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 2\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 0\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 0\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += -1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 2, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 2, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 0, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 0, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 0, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 0, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - -1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - -1, g[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 1, g[+1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[+1])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) + 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) + 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= (positions[i] + len(t)) * 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= (positions[i] + len(t)) * 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) + 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) + 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= (positions[j] + len(t)) * 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= (positions[j] + len(t)) * 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] - 1 < f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] - 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] * 1 < f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] * 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "f[k] = f[i] + 1",
      "mutated_line": "f[k] = f[i] - 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] - 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "f[k] = f[i] + 1",
      "mutated_line": "f[k] = f[i] * 1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] * 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] + 1 != f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 != f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[+1] - 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[+1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 1, g[-2])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-2])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 1, g[-0])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 1, g[-0])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-1] - 1, g[--1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[--1])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if s[i:i + len(t)] == t:",
      "mutated_line": "if s[i:i - len(t)] == t:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i - len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "if s[i:i + len(t)] == t:",
      "mutated_line": "if s[i:i * len(t)] == t:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i * len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] - len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] - len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] * len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] * len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 2:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 2:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 0:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 0:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 0:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 0:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:",
      "mutated_line": "while j < len(positions) and positions[j] <= positions[i] + len(t) - -1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - -1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] - len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] - len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] * len(t) - 1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] * len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 2:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 2:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 0:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 0:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 0:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 0:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:",
      "mutated_line": "while k < len(positions) and positions[k] <= positions[j] + len(t) - -1:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - -1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + 2 < f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 2 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + 0 < f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 0 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + 0 < f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 0 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if f[i] + 1 < f[k]:",
      "mutated_line": "if f[i] + -1 < f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + -1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f[k] = f[i] + 1",
      "mutated_line": "f[k] = f[i] + 2",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 2\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f[k] = f[i] + 1",
      "mutated_line": "f[k] = f[i] + 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 0\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f[k] = f[i] + 1",
      "mutated_line": "f[k] = f[i] + 0",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 0\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "f[k] = f[i] + 1",
      "mutated_line": "f[k] = f[i] + -1",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + -1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] - 1 == f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] - 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] * 1 == f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] * 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[k] = (g[k] + g[i]) % MOD",
      "mutated_line": "g[k] = (g[k] + g[i]) * MOD",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) * MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[k] = (g[k] + g[i]) % MOD",
      "mutated_line": "g[k] = g[k] + g[i] + MOD",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = g[k] + g[i] + MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-2] - 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-2] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-0] - 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-0] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[-0] - 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-0] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return f[-1] - 1, g[-1]",
      "mutated_line": "return (f[--1] - 1, g[-1])",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[--1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] + 2 == f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 2 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] + 0 == f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 0 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] + 0 == f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 0 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif f[i] + 1 == f[k]:",
      "mutated_line": "elif f[i] + -1 == f[k]:",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + -1 == f[k]:\n                g[k] = (g[k] + g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[k] = (g[k] + g[i]) % MOD",
      "mutated_line": "g[k] = (g[k] - g[i]) % MOD",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = (g[k] - g[i]) % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "g[k] = (g[k] + g[i]) % MOD",
      "mutated_line": "g[k] = g[k] * g[i] % MOD",
      "code": "def min_moves_and_sequences(s: str, t: str) -> (int, int):\n    MOD = 10 ** 9 + 7\n    positions = [0]\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            positions.append(i)\n    f = [1000] * (len(positions) + 1)\n    g = [0] * (len(positions) + 1)\n    positions[0] = -1000\n    g[0] = 1\n    f[0] = 0\n    positions.append(len(s) + len(t))\n    for i in range(len(positions)):\n        j = i + 1\n        while j < len(positions) and positions[j] <= positions[i] + len(t) - 1:\n            j += 1\n        k = j\n        while k < len(positions) and positions[k] <= positions[j] + len(t) - 1:\n            if f[i] + 1 < f[k]:\n                f[k] = f[i] + 1\n                g[k] = g[i]\n            elif f[i] + 1 == f[k]:\n                g[k] = g[k] * g[i] % MOD\n            k += 1\n    return (f[-1] - 1, g[-1])"
    }
  ]
}