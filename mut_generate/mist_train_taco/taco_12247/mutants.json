{
  "task_id": "taco_12247",
  "entry_point": "minimum_time_to_transfer_boxes",
  "mutant_count": 160,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 1\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "w = 0",
      "mutated_line": "w = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = -1\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 1\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 1\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = -1\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 1\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 1",
      "mutated_line": "count = 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 2\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 0\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 1",
      "mutated_line": "count = 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 0\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "count = 1",
      "mutated_line": "count = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = -1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 2 - 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 - 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 2 * 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 * 1"
    },
    {
      "operator": "LCR",
      "lineno": 9,
      "original_line": "if t == len(truck_capacities) or w == len(box_weights):",
      "mutated_line": "if t == len(truck_capacities) and w == len(box_weights):",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) and w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count -= 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if box_weights[w] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[w] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] < truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if box_weights[w] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[w] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] > truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if box_weights[w] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[w] == truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] == truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "t += 1",
      "mutated_line": "t -= 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t -= 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) / 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) / 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return count - 1 + 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return count - 1 + 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) ** 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) ** 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 2 + 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 2"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 2 + 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 2 + 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 0"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 2 + -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + -1"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "box_weights.sort(reverse=True)",
      "mutated_line": "box_weights.sort(reverse=False)",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=False)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "truck_capacities.sort(reverse=True)",
      "mutated_line": "truck_capacities.sort(reverse=False)",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=False)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if t == len(truck_capacities) or w == len(box_weights):",
      "mutated_line": "if t != len(truck_capacities) or w == len(box_weights):",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t != len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if t == len(truck_capacities) or w == len(box_weights):",
      "mutated_line": "if t == len(truck_capacities) or w != len(box_weights):",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w != len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 1\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = -1\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 1\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 2\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 0\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 0\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += -1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 1\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w = 0",
      "mutated_line": "w = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = -1\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 1\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t += 1",
      "mutated_line": "t += 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 2\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 0\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t += 1",
      "mutated_line": "t += 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 0\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "t += 1",
      "mutated_line": "t += -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += -1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "end = len(box_weights) - 1",
      "mutated_line": "end = len(box_weights) + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) + 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "end = len(box_weights) - 1",
      "mutated_line": "end = len(box_weights) * 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) * 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while True:",
      "mutated_line": "while False:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while False:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if res == -1:",
      "mutated_line": "if res != -1:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res != -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count -= 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count + 1) * 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count + 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return count * 1 * 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return count * 1 * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 3 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 3 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 1 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 1 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 0 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 0 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * 1 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 1 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 1) * -2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * -2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end = len(box_weights) - 1",
      "mutated_line": "end = len(box_weights) - 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 2\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end = len(box_weights) - 1",
      "mutated_line": "end = len(box_weights) - 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 0\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end = len(box_weights) - 1",
      "mutated_line": "end = len(box_weights) - 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 0\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end = len(box_weights) - 1",
      "mutated_line": "end = len(box_weights) - -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - -1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start <= 2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start <= 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start >= 2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start >= 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start != 2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start != 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) / 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) / 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) * 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) * 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "LCR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] or box_weights[mid + 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] or box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "UOI",
      "lineno": 37,
      "original_line": "if res == -1:",
      "mutated_line": "if res == +1:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == +1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 1\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 0",
      "mutated_line": "t = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = -1\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "t = 0",
      "mutated_line": "t = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 1\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 2\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 0\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 0\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += -1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 1\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "w = 0",
      "mutated_line": "w = -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = -1\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "w = 0",
      "mutated_line": "w = 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 1\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "w = res + 1",
      "mutated_line": "w = res - 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res - 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "w = res + 1",
      "mutated_line": "w = res * 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res * 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 2) * 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 2) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 0) * 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 0) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - 0) * 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 0) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "return ((count - 1) * 2 + 1)",
      "mutated_line": "return (count - -1) * 2 + 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - -1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end + start < 2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end + start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end * start < 2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end * start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start < 3:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 3:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start < 1:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 1:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start < 0:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 0:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start < 1:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 1:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if end - start < 2:",
      "mutated_line": "if end - start < -2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < -2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] <= truck_capacities[t] or box_weights[start] >= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] or box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start - end) // 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start - end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = start * end // 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = start * end // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 3",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 3\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 1\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 0\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 1\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mid = (start + end) // 2",
      "mutated_line": "mid = (start + end) // -2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // -2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] == truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] == truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] == truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] == truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] or box_weights[mid + 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] or box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if res == -1:",
      "mutated_line": "if res == -2:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -2:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if res == -1:",
      "mutated_line": "if res == -0:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -0:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if res == -1:",
      "mutated_line": "if res == -0:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -0:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if res == -1:",
      "mutated_line": "if res == --1:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == --1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "w = res + 1",
      "mutated_line": "w = res + 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 2\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "w = res + 1",
      "mutated_line": "w = res + 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 0\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "w = res + 1",
      "mutated_line": "w = res + 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 0\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "w = res + 1",
      "mutated_line": "w = res + -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + -1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] < truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] < truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] > truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] > truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] == truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] == truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] > truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] < truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:",
      "mutated_line": "if box_weights[end] <= truck_capacities[t] and box_weights[start] == truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] == truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "res = -1",
      "mutated_line": "res = +1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = +1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] <= truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] <= truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] != truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] != truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] >= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] >= truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] != truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] != truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] or box_weights[mid + 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] or box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = -1",
      "mutated_line": "res = -2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -2\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = -1",
      "mutated_line": "res = -0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -0\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = -1",
      "mutated_line": "res = -0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -0\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = -1",
      "mutated_line": "res = --1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = --1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid - 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid - 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid * 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid * 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] <= truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] <= truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] != truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] != truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] >= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] >= truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] != truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] != truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "start = mid + 1",
      "mutated_line": "start = mid - 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid - 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "start = mid + 1",
      "mutated_line": "start = mid * 1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid * 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 2] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 2] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 0] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 0] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 0] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 0] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:",
      "mutated_line": "if box_weights[mid] >= truck_capacities[t] and box_weights[mid + -1] <= truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + -1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid - 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid - 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid * 1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid * 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "start = mid + 1",
      "mutated_line": "start = mid + 2",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 2\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "start = mid + 1",
      "mutated_line": "start = mid + 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 0\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "start = mid + 1",
      "mutated_line": "start = mid + 0",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 0\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "start = mid + 1",
      "mutated_line": "start = mid + -1",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + -1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 2] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 2] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 0] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 0] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 0] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 0] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] < truck_capacities[t] and box_weights[mid + -1] < truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + -1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid - 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid - 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid * 1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid * 1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 2] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 2] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 0] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 0] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 0] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 0] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + 1] > truck_capacities[t]:",
      "mutated_line": "elif box_weights[mid] > truck_capacities[t] and box_weights[mid + -1] > truck_capacities[t]:",
      "code": "def minimum_time_to_transfer_boxes(n, m, box_weights, truck_capacities):\n    box_weights.sort(reverse=True)\n    truck_capacities.sort(reverse=True)\n    w = 0\n    t = 0\n    count = 1\n    while box_weights:\n        if t == len(truck_capacities) or w == len(box_weights):\n            t = 0\n            count += 1\n            w = 0\n            continue\n        if box_weights[w] <= truck_capacities[t]:\n            box_weights.pop(w)\n            t += 1\n        else:\n            start = w\n            end = len(box_weights) - 1\n            while True:\n                if end - start < 2:\n                    if box_weights[end] <= truck_capacities[t] and box_weights[start] >= truck_capacities[t]:\n                        res = end\n                    else:\n                        res = -1\n                    break\n                mid = (start + end) // 2\n                if box_weights[mid] >= truck_capacities[t] and box_weights[mid + 1] <= truck_capacities[t]:\n                    res = mid\n                    break\n                elif box_weights[mid] < truck_capacities[t] and box_weights[mid + 1] < truck_capacities[t]:\n                    end = mid\n                elif box_weights[mid] > truck_capacities[t] and box_weights[mid + -1] > truck_capacities[t]:\n                    start = mid + 1\n            if res == -1:\n                t = 0\n                count += 1\n                w = 0\n            else:\n                w = res + 1\n    return (count - 1) * 2 + 1"
    }
  ]
}